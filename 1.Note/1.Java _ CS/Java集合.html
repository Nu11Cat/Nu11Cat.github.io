<!doctype html>
<html lang="en-US" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.23" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.88" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme="dark"] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <script data-goatcounter="https://nu11cat.goatcounter.com/count" async src="//gc.zgo.at/count.js"></script><title>Java集合 | Nu11CatJava</title><meta name="description" content="一个Java学习者记录学习过程、积累知识、分享经验、陪伴同行者一起成长的网站">
    <link rel="preload" href="/assets/style-ClTTZfAw.css" as="style"><link rel="stylesheet" href="/assets/style-ClTTZfAw.css">
    <link rel="modulepreload" href="/assets/app-CE9h3O9H.js"><link rel="modulepreload" href="/assets/Java集合.html-BUapXDhL.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-czFsCq-Y.js" as="script"><link rel="prefetch" href="/assets/index.html-Dchkdhy0.js" as="script"><link rel="prefetch" href="/assets/index.html-DD3YS-6c.js" as="script"><link rel="prefetch" href="/assets/位运算.html--dlQZEc5.js" as="script"><link rel="prefetch" href="/assets/技巧_设计_语言特性.html-SvqbOB-_.js" as="script"><link rel="prefetch" href="/assets/index.html-CHeuDpCu.js" as="script"><link rel="prefetch" href="/assets/JVM.html-nE8IclmO.js" as="script"><link rel="prefetch" href="/assets/Java IO.html-C7ktAx8m.js" as="script"><link rel="prefetch" href="/assets/Java.html-BceYL-VR.js" as="script"><link rel="prefetch" href="/assets/Java多线程.html-BQ7E2VIG.js" as="script"><link rel="prefetch" href="/assets/Linux _ Shell.html-CNx5LV1K.js" as="script"><link rel="prefetch" href="/assets/操作系统.html-BFla9dXc.js" as="script"><link rel="prefetch" href="/assets/计算机网络.html-2S1XAYhy.js" as="script"><link rel="prefetch" href="/assets/设计模式.html-Cv0je5SA.js" as="script"><link rel="prefetch" href="/assets/ORM.html-0hpA08iG.js" as="script"><link rel="prefetch" href="/assets/Spring Boot.html-BZbsevUH.js" as="script"><link rel="prefetch" href="/assets/Spring Cloud.html-CpC_Ia9M.js" as="script"><link rel="prefetch" href="/assets/Spring Framework.html-Jf8S2cYZ.js" as="script"><link rel="prefetch" href="/assets/Elasticsearch.html-P7_VMlWf.js" as="script"><link rel="prefetch" href="/assets/MQ.html-CR97ONYn.js" as="script"><link rel="prefetch" href="/assets/MongoDB.html-CNHY7YpL.js" as="script"><link rel="prefetch" href="/assets/MySQL.html-D8FlQlkd.js" as="script"><link rel="prefetch" href="/assets/Redis.html-jJ0zWPKd.js" as="script"><link rel="prefetch" href="/assets/基础.html-C21MlS8i.js" as="script"><link rel="prefetch" href="/assets/Docker.html-sivXR52H.js" as="script"><link rel="prefetch" href="/assets/Git.html-ALeBDKPm.js" as="script"><link rel="prefetch" href="/assets/Maven.html-BFq5hbpp.js" as="script"><link rel="prefetch" href="/assets/k8s.html-D_8VyX-Q.js" as="script"><link rel="prefetch" href="/assets/二分.html-ivts-N0w.js" as="script"><link rel="prefetch" href="/assets/前缀和.html-DOmjDXy3.js" as="script"><link rel="prefetch" href="/assets/动态规划.html-COtg9RDZ.js" as="script"><link rel="prefetch" href="/assets/双指针.html-A0noW1JX.js" as="script"><link rel="prefetch" href="/assets/排序.html-BHacY9er.js" as="script"><link rel="prefetch" href="/assets/模拟.html-CL8dJToF.js" as="script"><link rel="prefetch" href="/assets/贪心.html-DYzShKfv.js" as="script"><link rel="prefetch" href="/assets/HASH.html-ChCCwL83.js" as="script"><link rel="prefetch" href="/assets/二叉树.html-ewKXzBN1.js" as="script"><link rel="prefetch" href="/assets/数组.html-36nSs3fP.js" as="script"><link rel="prefetch" href="/assets/栈.html-D70iX9WO.js" as="script"><link rel="prefetch" href="/assets/矩阵.html-CNenk7bL.js" as="script"><link rel="prefetch" href="/assets/链表.html-DGjEVT5E.js" as="script"><link rel="prefetch" href="/assets/关于作者.html-a3yt9SZO.js" as="script"><link rel="prefetch" href="/assets/Github操作.html-DNIGhPKI.js" as="script"><link rel="prefetch" href="/assets/工具网站.html-BfWfCxnE.js" as="script"><link rel="prefetch" href="/assets/404.html-C82jZ2K3.js" as="script"><link rel="prefetch" href="/assets/index.html-DkS5PbkZ.js" as="script"><link rel="prefetch" href="/assets/index.html-Cgiq-c6E.js" as="script"><link rel="prefetch" href="/assets/index.html-CgbXfNPK.js" as="script"><link rel="prefetch" href="/assets/index.html-DvfwPJt6.js" as="script"><link rel="prefetch" href="/assets/index.html-B9xXphgq.js" as="script"><link rel="prefetch" href="/assets/index.html-Cr1iUxi8.js" as="script"><link rel="prefetch" href="/assets/index.html-B_Uiq4pb.js" as="script"><link rel="prefetch" href="/assets/index.html-Bpc1BgFQ.js" as="script"><link rel="prefetch" href="/assets/index.html-ZfRDZ4qe.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-DXWKOczD.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">Skip to main content</a><!--]--><!--[--><div class="theme-container external-link-icon has-toc" vp-container><!--[--><header id="navbar" class="vp-navbar" vp-navbar><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!--[--><a class="route-link vp-brand" href="/" aria-label="Take me home"><!----><!----><span class="vp-site-name">Nu11CatJava</span></a><!--]--></div><div class="vp-navbar-center"><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/" aria-label="首页"><!---->首页<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/1.学习篇/" aria-label="学习篇"><!---->学习篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/2.面试篇/" aria-label="面试篇"><!---->面试篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/3.算法篇/" aria-label="算法篇"><!---->算法篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/4.项目篇/" aria-label="项目篇"><!---->项目篇<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/5.资源整理/" aria-label="资源整理"><!---->资源整理<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/6.关于我/" aria-label="关于我"><!---->关于我<!----></a></div></nav><!--]--></div><div class="vp-navbar-end"><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/Nu11Cat/Nu11Cat.github.io" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar" vp-sidebar><!----><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/" aria-label="首页"><!---->首页<!----></a></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">1. Note</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">1. Java &amp; CS</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/Java.html" aria-label="Java"><!---->Java<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/1.Note/1.Java%20_%20CS/Java%E9%9B%86%E5%90%88.html" aria-label="Java集合"><!---->Java集合<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/Java%20IO.html" aria-label="Java I/O"><!---->Java I/O<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B.html" aria-label="Java多线程"><!---->Java多线程<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/JVM.html" aria-label="JVM"><!---->JVM<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html" aria-label="设计模式"><!---->设计模式<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html" aria-label="计算机网络"><!---->计算机网络<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html" aria-label="操作系统"><!---->操作系统<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/1.Java%20_%20CS/Linux%20_%20Shell.html" aria-label="Linux &amp; Shell"><!---->Linux &amp; Shell<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">2. Spring&amp; Framework</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">3. Database&amp; MQ</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">4. Tool</span><span class="vp-arrow end"></span></button><!----></section></li><li><a class="route-link auto-link vp-sidebar-link" href="/1.Note/" aria-label="Catalogue"><!---->Catalogue<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">2. Algorithm</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">3. Practice</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">4. Others</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><!---->Java集合</h1><div class="page-info"><!----><!----><span class="page-date-info" aria-label="Writing Date📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span data-allow-mismatch="text">7/24/25</span><meta property="datePublished" content="2025-07-24T08:02:25.000Z"></span><!----><span class="page-reading-time-info" aria-label="Reading Time⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>About 29 min</span><meta property="timeRequired" content="PT29M"></span><!----><!----></div><hr></div><!----><div class="" vp-content><!----><div id="markdown-content"><h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h1><p>Java集合分为 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><code>Collection</code> 接口又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><h1 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span><code>List</code></span></a></h1><h2 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span><code>ArrayList</code></span></a></h2><h3 id="和数组的区别" tabindex="-1"><a class="header-anchor" href="#和数组的区别"><span>和数组的区别</span></a></h3><p>数组是 Java 最基本的数据结构，特点是长度固定、访问效率高。它适合用在对性能要求比较高、元素数量明确的场景，比如底层算法、缓存之类的。</p><p>ArrayList 是 Java 集合框架中的一个类，它的底层其实就是数组，但它在上层做了封装，支持动态扩容。还提供了很多方便的 API，比如 add、remove、contains 等。</p><p>数组可以存基本类型，比如 int[]，但是 ArrayList 只能存引用类型，这是因为泛型不支持基本类型，要通过自动装箱来处理。</p><h3 id="机制" tabindex="-1"><a class="header-anchor" href="#机制"><span>机制</span></a></h3><p><code>ArrayList</code>是基于数组实现的可变长度的列表。它实现了<code>RadomAccess</code>标记接口，支持索引快速访问。底层就是一个Object[]数组。线程不安全。</p><p><strong>懒加载</strong>：如果你没有指定大小那它是懒加载的，创建了一个<code>ArrayList</code>的时候并不会立刻分配数组，而是把内部的<code>elementDate</code>指向一个共享的空数组<code>EMPTY_ELEMENTDATA</code>，真正的初始化发生在第一次添加元素的时候，这样的目的是为了节省内存。只有在第一次添加元素时，才会初始化为默认容量 <strong>10</strong> 的数组。</p><p><strong>扩容</strong>：当你调用add()会进行元素个数和容量的判断，判断是否达到数组容量，如果是就会触发扩容，这里的扩容是一个懒触发的过程，只有在满了的那一刻才扩容，会触发grow()方法，把原数组的容量扩大到1.5倍，实际上是创建了一个新数组然后<code>Arrays.copyOf()</code>方法复制的。</p><p>至于为什么是1.5倍，从源码上看是因为<code>oldCapacity + (oldCapacity &gt;&gt; 1);</code>，&gt;&gt;右移一位就是除以2^1，从设计上讲，这是一个性能和空间的权衡折中方案，因为频繁的扩容会导致性能浪费，而扩太多就会导致空间浪费。</p><p>但是删除元素不会自动缩容，逻辑大小会减少，但是底层容量仍然保留原扩容后的大小。这种设计的初衷是为了提高性能，减少频繁的内存复制操作，适用于大多数场景。然而，这也带来了内存浪费的问题。为了避免浪费，如果元素减少得较多，可以手动调用 <code>trimToSize()</code> 来缩容。</p><p><strong>复杂度</strong>：至于插入删除的复杂度，如果是头部和指定位置都是O(n)，如果是尾部插入，又分为需要扩容和不需要扩容的情况，如果需要扩容，那么会新建数组然后<code>copyOf()</code>，复杂度是O(n)，如果不需要扩容就是O(1)。</p><h2 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span><code>LinkedList</code></span></a></h2><p><code>LinkedList</code>是基于双向链表实现的（JDK1.6 之前为循环链表，JDK1.7 改为普通双向链表），底层是由多个节点（<code>Node</code>）连接成的链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问。包括前后节点的引用和存储的元素。线程不安全。</p><p><strong>复杂度</strong>：元素的添加都是O(1)，删除头尾也都是O(1)，但是删除中间节点的时候需要定位到节点，所以是O(n)。</p><p>并且它实现了 <code>List</code>、<code>Deque</code> 和 <code>Queue</code> 接口，所以既能当列表用，也能当队列、双端队列、栈来用，功能还是很丰富的。</p><h2 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist"><span><code>CopyOnWriteArrayList</code></span></a></h2><p><code>CopyOnWriteArrayList</code>是Java的一个List的线程安全实现，专门为解决多线程并发场景中的数据一致性的高效读取提供解决方案。</p><p>底层是一个<code>Obejec[]</code>数组。</p><p>核心思想是每次写操作都创建底层数组的一个新副本，修改副本会再将副本替换原数组，复杂度为O(n)。读操作直接访问底层数组，复杂度是O(1)。</p><p>优点是写操作创建新数组并替换，不需要额外的同步操作，确保了线程安全。并且读操作非常高效。</p><p>缺点是每次写操作都要复制整个数组，频繁写入的情况下不仅写操作的时间复杂度为O(n)性能低，并且内存消耗大。</p><p>另外它在某些情况下会导致读出来的数据不是最新的，尤其是在写操作发生时。解决方法就是使用锁机制(如，<code>synchronized</code>)或者其他线程安全的集合(如<code>ConcurrentLinkedQueue</code>)；</p><p>所以它适用于读多写少的场景，以及作为事件监听器。</p><h2 id="collections-synchronizedlist" tabindex="-1"><a class="header-anchor" href="#collections-synchronizedlist"><span><code>Collections.synchronizedList()</code></span></a></h2><p><code>Collections.synchronizedList()</code> 是 Java 中的一个工具方法，用于将一个普通的 <code>List</code> 包装成一个线程安全的 <code>List</code>。它是通过对所有的 <code>List</code> 操作加锁来保证线程安全的。</p><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><h3 id="arraylist-vs-linkedlist" tabindex="-1"><a class="header-anchor" href="#arraylist-vs-linkedlist"><span><code>ArrayList</code> vs <code>LinkedList</code></span></a></h3><p><strong>相同点</strong>：</p><ul><li>都实现了 Java 的 List 接口：它们都支持相同的基本操作，例如添加元素、删除元素、查找元素、获取元素等</li><li>都是有序的集合：都保证按顺序存储元素</li><li>都允许存储重复元素：可以有多个相同的元素，并且都允许存储 null 元素。</li><li>都不线程安全</li></ul><p><strong>不同点</strong>：</p><ul><li><strong>底层数据结构</strong>：ArrayList的底层是动态数组，有扩容机制；LinkedList的底层是双向链表。</li><li><strong>操作复杂度</strong>：ArrayList的插入删除的复杂度，如果是头部和指定位置都是O(n)，如果是尾部插入，又分为需要扩容和不需要扩容的情况，如果需要扩容，那么会新建数组然后<code>copyOf()</code>，复杂度是O(n)，如果不需要扩容就是O(1)； LinkedList元素的添加都是O(1)，删除头尾也都是O(1)，但是删除中间节点的时候需要定位到节点，所以是O(n)。</li><li><strong>快速随机访问</strong>：<code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</li><li><strong>内存空间占用</strong>：</li><li><code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li><li><strong>应用场景</strong>：ArrayList 适合查询多，修改少的场景；LinkedList 适合插入和删除操作多的场景。</li></ul><h1 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span><code>Map</code></span></a></h1><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span><code>HashMap</code></span></a></h2><p>TreeMap和HashMap都继承自AbstractMap</p><p>HashMap的底层是数组+链表/红黑树，是非线程安全的，核心原理是<strong>通过 key 的 hash 值快速定位元素在数组中的位置</strong>，然后通过 <code>equals()</code> 判断是否为同一个 key，实现快速查找和插入；<strong>当put插入数据的时候</strong>，首先调用hashcode方法计算哈希值，然后hash方法又会对这个哈希值进行扰动处理（本质是添加高位信息的计算，降低低位重复的风险），目的是为了让哈希值更均匀，减少碰撞。然后回对数组长度取模得到数组下标，也就是桶的索引，如果这个位置是空的，就直接在这个位置放一个Node节点（键值对的封装对象），如果已经有数据了，说明发生了哈希冲突，这个时候会遍历桶的链表/红黑树，先用hash筛选可能的key，然后使用equals方法判断是不是同一个key，如果key已经存在，就更新value，反之，就添加这个节点，走链表（8之前头插，之后尾插，性能稍慢但是并发扩容不会造成<strong>循环链表</strong>）或红黑树的添加逻辑。如果某个桶的链表长度超过8并且总容量大于64，就会<strong>转化成红黑树</strong>，效率是O（logn）；当<strong>查找元素</strong>的时候，首先计算key的哈希值，再去桶遍历链表/红黑树，找hash值相等的节点，然后用equals判断是不是目标key，如果找到了就返回value；<strong>扩容</strong>：HashMap的默认初始容量是16，记载因子是0.75，当元素数量超过16*0.75=12的时候，发生扩容，扩容会把原数组容量扩大为原来的2倍，然后把原来的元素再次hash放到新位置，这一步的开销较大，因为涉及所有元素的重新计算和移动。</p><p><strong>优先扩容而不是优先转化为红黑树</strong>，因为数组扩容能减少哈希冲突的概率，并且红黑树需要维持自平衡，维护成本较高，并且红黑树会增加复杂度（节点占用内存更大）。</p><p><strong>为什么扩容是8和64</strong>：因为泊松分布表明，链表长度到达8的情况非常非常少。设为8可以保证性能和空间的平衡。64也是实践验证的经验值，优先扩容而不是优先转化红黑树，当数组大小达到64的时候，冲突概率较高，转化成红黑树的性能优势就明显了。</p><p><strong>为什么扩容*2</strong>：目的是为了让hash计算更加高效；首先，HashMap的容量是2的幂，hash取模可以使用位运算代替，（n-1）&amp; hash；扩容后的再次hash更容易判断元素是否发生位置移动，重新hash后我们只需要看新增的哪一位是0还是1就能判断出来是否需要后移oldCapacity（是1就移）；</p><p>**为什么HashMap线程不安全？**1.7之前头插法导致在多线程环境下扩容操作可能存在死循环问题；另外无论是7还是8都存在一个数据丢失的问题，实际上是数据覆盖，一种情况是线程1发现hash冲突并且equals满足，即将覆盖数据的时候，CPU执行权被线程2抢走，数据2覆盖了数据，等到线程1再次操作的时候就会把线程2的数据覆盖。还有一种情况是两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题。</p><p><strong>常见的遍历方式</strong>：第一种是通过 <code>entrySet()</code> 方法遍历，这是最常用也是效率最高的一种方式。它返回的是键值对的集合，可以在一次迭代中同时获取 key 和 value，适合需要同时操作键和值的场景。</p><p>第二种是遍历 <code>keySet()</code>，然后再通过 <code>get(key)</code> 获取对应的 value。这种方式在只关心 key 的情况下可以使用，但如果每次还要去查 value，相比 <code>entrySet()</code> 会多一次查找操作，性能略差。</p><p>第三种是遍历 <code>values()</code>，这种方式适合只关注所有 value 的情况，不关心对应的 key。</p><p>除此之外，如果是使用 Java 8 或更高版本，也可以使用 <code>forEach()</code> 方法配合 Lambda 表达式进行遍历，写法更简洁，也更符合函数式编程风格。</p><h3 id="hashmap-和-hashset-区别" tabindex="-1"><a class="header-anchor" href="#hashmap-和-hashset-区别"><span><code>HashMap</code> 和 <code>HashSet</code> 区别</span></a></h3><p><code>HashMap</code> 是一个键值对集合，用来存储 key 和 value 的映射关系；而 <code>HashSet</code> 是一个不重复的集合，只存储元素本身，没有键值对的概念。</p><p>从实现上来看，<code>HashSet</code> 内部其实就是通过一个 <code>HashMap</code> 来实现的。我们每往 <code>HashSet</code> 加一个元素，底层就是把这个元素作为 <code>HashMap</code> 的 key，value 用一个固定的对象（通常是 <code>PRESENT</code>）。也就是说，<code>HashSet</code> 借用了 <code>HashMap</code> 的 key 去实现唯一性约束。</p><p>此外，在元素唯一性判断上，两者都靠 key 的 hashCode 和 equals 来判断唯一性，但 HashMap 还需要关注和操作与 key 相关联的 value，如<code>get(key)</code>，<code>putIfAbsent()</code> 等方法，而 HashSet 根本不涉及 value 的变化。</p><h3 id="treemap-和-hashmap-区别" tabindex="-1"><a class="header-anchor" href="#treemap-和-hashmap-区别"><span><code>TreeMap</code> 和 <code>HashMap</code> 区别</span></a></h3><p>首先，<strong>排序方式</strong>是最显著的区别。<code>HashMap</code> 不保证任何顺序，它是无序的，元素的顺序是由哈希函数决定的。而 <code>TreeMap</code> 是基于红黑树实现的，它会根据键的自然顺序（即 <code>Comparable</code>）或者自定义的 <code>Comparator</code> 对键进行排序。因此，<code>TreeMap</code> 保证键的顺序是有序的。</p><p>第二，<strong>底层数据结构</strong>不同。<code>HashMap</code> 底层是基于哈希表实现的，键通过哈希值定位到桶（bucket）中，这使得它的查找、插入和删除操作平均时间复杂度是 O(1)，但是它的顺序是不可预测的。而 <code>TreeMap</code> 底层是基于红黑树的，操作时间复杂度是 O(log N)，但是它能够提供有序的键值对。</p><p>第三，<strong>线程安全性</strong>，<code>HashMap</code> 和 <code>TreeMap</code> 都是非线程安全的。如果在多线程环境下需要使用线程安全的 <code>Map</code>，需要使用 <code>ConcurrentHashMap</code> 或者通过显式加锁来实现。</p><p>最后，<strong>性能上的差异</strong>。由于 <code>TreeMap</code> 需要维护键的顺序，插入、删除、查找等操作的时间复杂度是 O(log N)，相较于 <code>HashMap</code> 的 O(1) 要慢。如果不需要排序，<code>HashMap</code> 会更快</p><h2 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap"><span><code>TreeMap</code></span></a></h2><p><code>TreeMap</code> 是 Java 中 <code>Map</code> 接口的一个实现类，最大的特点就是它可以对键进行自动排序。这个排序要么是按照键的自然顺序，也就是键实现了 <code>Comparable</code> 接口，要么是通过我们在构造时传入的 <code>Comparator</code> 进行自定义排序。</p><p>它的底层是基于红黑树实现的，也就是一种自平衡的二叉搜索树，所以它在插入、删除、查找时都能保证 logN 的时间复杂度。相比于 <code>HashMap</code> 来说，虽然性能略低一些，但它能保持顺序，这在需要范围查找、按序遍历时非常有用。</p><p>值得注意的是，<code>TreeMap</code> 不允许键为 null，因为排序时会涉及键的比较，而 null 不能参与比较操作。值是可以为 null 的。</p><p>另外，<code>TreeMap</code> 不是线程安全的，在并发场景下我们需要自己加锁或者使用工具方法进行同步包装。</p><p>总的来说，如果我们在业务中需要一个按照键排序的 Map，比如做排行榜、区间查找、时间线数据等，<code>TreeMap</code> 是一个很合适的选择。</p><h2 id="concurrehashmap" tabindex="-1"><a class="header-anchor" href="#concurrehashmap"><span><code>ConcurreHashMap</code></span></a></h2><p>ConcurreHashMap是线程安全版的hashmap。</p><p><strong>1.8之前</strong></p><p>在 JDK1.7 及之前，<code>ConcurrentHashMap</code> 的线程安全是通过**分段锁（Segment Lock）**实现的。它将整个哈希表分为若干个段（Segment），每个 Segment 其实是一个小的哈希表，同时每个 Segment 都维护一个独立的锁。</p><p>当我们对 <code>ConcurrentHashMap</code> 进行 put、get 或 remove 操作时，只会锁住对应的某个 Segment，而不是整个 map。这样多个线程只要访问的 Segment 不同，就可以并发执行操作，避免了 <code>Hashtable</code> 那种全表锁带来的性能瓶颈。</p><p>Segment 的数量一般是 2 的幂次方，比如默认是 16 个，也就是说最多可以有 16 个线程并发写入而不阻塞，从而提升了并发性能。</p><p>不过它的缺点也很明显：Segment 的数量是固定的，粒度不能再细，某个 Segment 上仍然可能成为热点，限制了更高的并发性。</p><p><strong>1.8之后</strong></p><p>到了 JDK1.8，<code>ConcurrentHashMap</code> 的结构完全重写，不再使用 Segment，而是用<strong>数组 + 链表 + 红黑树</strong>的结构，同时结合了 <strong>CAS（无锁操作）</strong> 和 <strong>synchronized（细粒度同步）</strong>。</p><p>插入数据时，先通过 CAS 操作尝试将节点插入到桶中，如果该位置是空的，直接写入，无需加锁；如果该位置已经有元素（比如链表或红黑树），才会用 synchronized 加锁，但只锁当前桶的头节点，锁的粒度更细。</p><p>扩容时，多个线程可以<strong>协同迁移数据</strong>，称为协助扩容，避免了单线程扩容造成的阻塞。</p><p>get 操作是无锁的，通过 volatile 保证可见性，读取效率非常高。</p><p>相比 JDK1.7，1.8 的 <code>ConcurrentHashMap</code> 在并发性能、内存占用、锁竞争等方面都做了很大优化，彻底解决了分段锁机制下的扩展瓶颈。</p><p><strong>不允许为 null</strong></p><p><code>HashMap</code> 的 key 和 value 都能为 null，但 key 最多只能有一个为 null；而 <code>ConcurrentHashMap</code> 两者都不允许为 null，因为二义性，你没办法是不存在才返回null还是因为值本身就是null。多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p><strong><code>ConcurrentHashMap</code> 是否支持复合操作的原子性时</strong></p><p>第一，它本身只保证单个方法的线程安全，比如 <code>get</code>、<code>put</code>、<code>remove</code> 等，内部都有并发控制机制，比如 CAS 或 synchronized。但如果我组合多个方法，比如 <code>if (!map.containsKey(k)) map.put(k, v)</code>，这就不是原子的，中间可能被其他线程修改，导致逻辑错误。</p><p>第二，JDK 1.8 开始提供了一些专门应对复合操作的原子方法，比如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code>、<code>computeIfPresent</code> 和 <code>merge</code>，这些方法内部已经做了同步控制，可以安全地执行复合操作，所以我们要优先使用这些方法来避免并发问题。</p><p>第三，如果遇到更加复杂的逻辑，<code>ConcurrentHashMap</code> 没有提供直接支持的原子操作，那就需要 开发者自己加锁 来保证原子性，通常可以使用外部 <code>ReentrantLock</code> 或 <code>synchronized</code>。</p><h3 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable"><span><code>Hashtable</code></span></a></h3><p><code>Hashtable</code> 是 Java 中最早期提供的哈希表实现，已经过时，更推荐使用 <code>ConcurrentHashMap</code> 来替代它。</p><p>最大的特点是线程安全。<code>Hashtable</code> 的所有方法几乎都通过 <code>synchronized</code> 实现了同步控制，保证了多线程并发访问时的数据一致性。但也正因为如此，它的性能在高并发环境下会受到一定影响，因为每次访问都需要加锁，容易成为性能瓶颈。</p><p>从底层结构上看，<code>Hashtable</code> 和早期的 <code>HashMap</code> 类似，都是基于数组加链表的结构实现的哈希表。通过键的 <code>hashCode()</code> 方法计算哈希值，再定位到数组的某个槽位，发生哈希冲突时通过拉链法解决。</p><p>值得注意的是，<code>Hashtable</code> 不允许键或值为 <code>null</code>。这和 <code>HashMap</code> 不同，<code>HashMap</code> 允许一个 <code>null</code> 键和多个 <code>null</code> 值。</p><h3 id="concurrenthashmap-和-hashtable-的区别" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-和-hashtable-的区别"><span><code>ConcurrentHashMap</code> 和 <code>Hashtable</code> 的区别</span></a></h3><p>首先，在实现线程安全的方式上，<code>Hashtable</code> 是通过对整个方法加上 <code>synchronized</code> 来实现同步的，也就是说每次读写操作都需要加锁，锁的粒度非常大，线程只能串行访问，性能比较低。而 <code>ConcurrentHashMap</code> 则是通过分段锁或者更细粒度的同步机制来实现并发控制的。在 JDK1.7 中，它使用的是分段锁结构，把整个桶数组分成多个 Segment，每个 Segment 有自己的锁，可以支持更高并发；到了 JDK1.8，它优化为使用 CAS 和 <code>synchronized</code> 结合的方式，锁粒度更小，性能进一步提升。</p><p>其次，<code>Hashtable</code> 在多线程下容易成为性能瓶颈，而 <code>ConcurrentHashMap</code> 在保证线程安全的同时兼顾了并发性能，是并发场景下更推荐的选择。</p><p>还有一点比较重要的是，<code>Hashtable</code> 不允许键或值为 <code>null</code>，<code>ConcurrentHashMap</code> 也不允许。这个设计是为了避免在并发场景下使用 <code>null</code> 带来的歧义，比如不能判断是没有映射还是映射为 null。</p><p>从实际开发角度来说，<code>Hashtable</code> 已经属于过时的类，几乎不会在新项目中使用了；而 <code>ConcurrentHashMap</code> 是目前在并发环境下使用最广泛的线程安全 Map 实现。</p><h1 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span><code>Set</code></span></a></h1><p>HashSet，LinedHashSet，TreeSet，都是Set接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p><p>HashSet是基于HasmMap的Key唯一的特性实现的，用来实现HashSet的HasmMap的value是一个固定常量，一般是PRESENT。</p><blockquote><p>这个 <code>PRESENT</code> 是 <code>HashSet</code> 内部的一个 <code>private static final Object</code>，只用来占位，没有实际意义。每当我们往 <code>HashSet</code> 添加一个元素，底层就是执行 <code>map.put(element, PRESENT)</code>。</p><p><strong>不能是Null</strong></p><p>如果用 <code>null</code> 作为 value，那在调用 <code>map.get(key)</code> 的时候，永远返回的是 <code>null</code>，我们就无法区分到底这个 key 是真的存在，只是值是 null，还是这个 key 根本不存在。</p></blockquote><h2 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset"><span>LinkedHashSet</span></a></h2><p><code>LinkedHashSet</code> 是 <code>Set</code> 接口的一个实现类，它继承自 <code>HashSet</code>。</p><ol><li><strong>保持插入顺序</strong>： <code>LinkedHashSet</code> 通过双向链表来维护元素的插入顺序，这意味着在遍历时，它会按照元素添加的顺序进行输出。与 <code>HashSet</code> 不同，<code>HashSet</code> 是无序的，无法保证元素的顺序。</li><li><strong>底层实现</strong>： <code>LinkedHashSet</code> 是基于 <code>HashMap</code> 实现的，每个元素作为 <code>HashMap</code> 的 key，value 使用一个固定的对象（通常是 <code>PRESENT</code>）。同时，它通过双向链表来保持插入顺序。</li><li><strong>性能</strong>： <ul><li>和 <code>HashSet</code> 一样，<code>LinkedHashSet</code> 的 <code>add</code>、<code>remove</code>、<code>contains</code> 等操作的时间复杂度都是 O(1)。</li><li>由于需要维护插入顺序，它相较于 <code>HashSet</code> 会稍微多一些内存开销，因为它要额外存储双向链表的信息。</li></ul></li><li><strong>适用场景</strong>： <code>LinkedHashSet</code> 适用于那些需要保证元素顺序的场景，且不需要重复元素的集合。如果你需要元素的唯一性且保持插入顺序，就可以使用 <code>LinkedHashSet</code>。</li></ol><h2 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset"><span>TreeSet</span></a></h2><p><code>TreeSet</code> 是 <code>Set</code> 接口的一个实现类，底层基于 <code>TreeMap</code> 实现。</p><ol><li><strong>元素有序</strong>： <code>TreeSet</code> 会根据元素的自然顺序（即元素实现了 <code>Comparable</code> 接口）或者自定义的排序规则（通过构造函数传入 <code>Comparator</code>）对元素进行排序，遍历时是有序的。</li><li><strong>不允许重复元素</strong>： <code>TreeSet</code> 和其他 Set 一样，不能存储重复元素。它是通过比较元素的大小来判断是否重复的，而不是 <code>equals()</code>，所以自定义比较器或 <code>compareTo</code> 的逻辑要和 <code>equals</code> 保持一致，否则会出现逻辑冲突。</li><li><strong>底层实现</strong>： <code>TreeSet</code> 底层是基于 <code>TreeMap</code> 实现的，具体是将元素作为 <code>TreeMap</code> 的 key，value 是一个固定的常量。它本质上是一个红黑树结构，因此所有操作的时间复杂度是 O(log N)。</li><li><strong>不允许存储 <code>null</code> 元素</strong>： 因为比较时会抛出空指针异常，所以插入 <code>null</code> 会直接抛出 <code>NullPointerException</code>。</li><li><strong>适用场景</strong>： 当我们需要一个自动排序且不重复的集合时，就可以使用 <code>TreeSet</code>，比如处理排行榜、自动去重并排序的一些数据集合等。</li></ol><h1 id="queue" tabindex="-1"><a class="header-anchor" href="#queue"><span><code>Queue</code></span></a></h1><h2 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue"><span><code>PriorityQueue</code></span></a></h2><p><code>PriorityQueue</code> 是 Java 提供的一个<strong>基于优先级的队列</strong>实现，它实现了 <code>Queue</code> 接口，用来存储一组按照优先级自动排序的元素。</p><p>和普通队列不同，普通队列是先进先出，而 <code>PriorityQueue</code> 中的元素并不是按照插入顺序来出队的，而是按照优先级<strong>最小的元素优先出队</strong>，也就是默认是一个<strong>小顶堆结构</strong>。</p><p>它的底层是基于<strong>最小堆（binary heap）实现的数组结构</strong>，插入和删除操作的时间复杂度都是 O(logN)。元素入队后会自动按照优先级进行调整。</p><p>默认情况下，队列中的元素必须实现 <code>Comparable</code> 接口，使用元素的自然顺序进行排序；如果我们需要自定义排序方式，也可以在构造方法中传入一个 <code>Comparator</code>，从而按照指定的优先级进行排序。</p><p>值得注意的是，<code>PriorityQueue</code> 允许重复元素，但<strong>不允许插入 null</strong>，因为 null 会与内部比较操作冲突。此外，它<strong>不是线程安全的</strong>，在多线程环境下需要通过外部同步或使用并发版本的队列，比如 <code>PriorityBlockingQueue</code>。</p><p>典型应用场景包括：任务调度器、带权重的消息处理系统、Dijkstra 最短路径算法、Top-K 问题等。</p><h2 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue"><span><code>BlockingQueue</code></span></a></h2><p><code>BlockingQueue</code> 是 Java 中用于<strong>线程间通信</strong>和<strong>任务调度</strong>的一个接口，广泛用于生产者-消费者模型的实现。它的特点是：当队列为空时，消费者线程会被阻塞，直到有新元素加入；而当队列满时，生产者线程会被阻塞，直到队列有空间可以插入新元素。</p><p><code>BlockingQueue</code> 主要有两个特性：</p><ol><li><strong>阻塞</strong>：如果队列为空，调用 <code>take()</code> 方法的线程会被阻塞，直到队列中有元素可用。如果队列已满，调用 <code>put()</code> 方法的线程会被阻塞，直到队列有空位。</li><li><strong>线程安全</strong>：通过内部的锁机制（如使用 ReentrantLock 或其他同步机制）来确保多个线程同时访问时，不会产生数据不一致的问题，保证在高并发情况下的正确性和一致性。</li></ol><p><code>BlockingQueue</code> 接口有几个常用实现类：</p><ul><li><strong><code>ArrayBlockingQueue</code></strong>：基于数组实现的有界阻塞队列，队列的容量是固定的。</li><li><strong><code>LinkedBlockingQueue</code></strong>：基于链表实现的有界阻塞队列，可以设置最大容量，也可以不设置，默认是无界队列。</li><li><strong><code>PriorityBlockingQueue</code></strong>：基于优先级队列实现的阻塞队列，元素会按照优先级顺序排序。</li><li><strong><code>DelayQueue</code></strong>：一个支持延迟获取元素的队列，元素必须实现 <code>Delayed</code> 接口，适用于定时任务的场景。</li><li><strong><code>SynchronousQueue</code></strong>：没有任何容量的阻塞队列，每一个 <code>put</code> 操作必须等待另一个 <code>take</code> 操作才能完成，常用于任务传递。</li></ul><p>在实际应用中，<code>BlockingQueue</code> 被广泛应用于多线程的任务调度、线程池的实现、生产者-消费者模型等场景。</p><blockquote><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>区别</p><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 都是常用的阻塞队列，具备线程安全和阻塞特性，但它们在底层结构、容量控制和性能表现上有明显区别。</p><p>首先，底层实现不同。<code>ArrayBlockingQueue</code> 是基于数组实现的，内部使用一个固定长度的数组作为存储结构，因此它的容量必须在创建时指定，无法动态扩容。而 <code>LinkedBlockingQueue</code> 是基于链表实现的，每个元素是一个独立的节点，通过链表串联起来，它支持有界和无界两种模式。如果构造时没有指定容量，默认容量是 Integer.MAX_VALUE，相当于一个理论上的无界队列。</p><p>其次，在性能和资源使用上也有区别。由于数组是连续内存，<code>ArrayBlockingQueue</code> 的内存利用更紧凑，内存开销相对较小，适合对内存敏感的场景。而 <code>LinkedBlockingQueue</code> 每个元素都需要额外的节点对象，内存开销相对更大，但在高并发场景下，它的插入和移除操作更加平稳，适合大规模数据流动。</p><p>此外，<code>LinkedBlockingQueue</code> 的 put 和 take 操作内部使用的是两把锁（分别用于读和写），而 <code>ArrayBlockingQueue</code> 只使用一把锁来控制整个队列，因此在某些高并发情况下，<code>LinkedBlockingQueue</code> 的吞吐量可能会更好一些。</p><p>应用场景上，如果我清楚队列的容量范围，比如用于线程池中的任务提交队列，我更倾向于使用 <code>ArrayBlockingQueue</code>，因为它更简单、内存开销更小。但如果任务量无法预估，或者系统允许更大的弹性空间，那么 <code>LinkedBlockingQueue</code> 会更适合一些。</p></blockquote><h2 id="queue和deque" tabindex="-1"><a class="header-anchor" href="#queue和deque"><span><code>Queue</code>和<code>Deque</code></span></a></h2><p><strong>Queue</strong> 是一个<strong>单端队列</strong>，遵循的是典型的“先进先出”（FIFO）原则。我们通常使用 <code>offer()</code> 添加元素，用 <code>poll()</code> 或 <code>remove()</code> 移除元素，从队首出，从队尾入。常见的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>，像任务调度、消息队列等场景都是使用 Queue。</p><p>而 <strong>Deque</strong> 是“双端队列”，全称是 Double Ended Queue，它既可以从队头添加或移除元素，也可以从队尾进行相同的操作。也就是说，<code>Deque</code> 同时支持 FIFO 和 LIFO（后进先出），因此它<strong>既可以当队列用，也可以当栈用</strong>。常用方法比如 <code>addFirst()</code>、<code>addLast()</code>、<code>removeFirst()</code>、<code>removeLast()</code>，而实现类像 <code>ArrayDeque</code> 和 <code>LinkedList</code> 都支持 Deque 接口。</p><p>所以总结来说，<strong>Queue 只能一端进、一端出，Deque 两端都能进出，更灵活</strong>，适合处理双向数据结构或实现栈这种结构。</p><h2 id="arraydeque-和-linkedlist" tabindex="-1"><a class="header-anchor" href="#arraydeque-和-linkedlist"><span><code>ArrayDeque</code> 和 <code>LinkedList</code></span></a></h2><p><strong><code>ArrayDeque</code> 是基于动态数组实现的</strong>，它内部用一个循环数组来存储元素。因为是数组结构，它在两端插入和删除元素时效率很高，几乎都是 O(1) 时间，并且由于没有指针开销，它的内存利用率也更好。</p><p>相比之下，<strong><code>LinkedList</code> 是基于双向链表实现的</strong>，每个节点都有前后指针。它的优势是插入和删除不会涉及数组扩容或元素移动，也支持插入 null 元素，但缺点是内存开销更大，随机访问效率低，性能波动也可能更明显。</p><p>此外，<strong><code>ArrayDeque</code> 不允许插入 null 元素</strong>，而 <code>LinkedList</code> 是允许的；另外在栈结构（比如替代 <code>Stack</code> 类）或队列结构中，<code>ArrayDeque</code> 通常比 <code>LinkedList</code> 表现更优，也更推荐使用。</p><h2 id="arraydeque-和-arraylist" tabindex="-1"><a class="header-anchor" href="#arraydeque-和-arraylist"><span><code>ArrayDeque</code> 和 <code>ArrayList</code></span></a></h2><p>虽然 <code>ArrayList</code> 和 <code>ArrayDeque</code> 的名字都带有 &quot;Array&quot;，而且底层都是用数组（Object[]）来存储数据，但它们的设计目的、使用方式以及性能特点有很大的不同。</p><p>首先，<strong><code>ArrayList</code> 实现了 <code>List</code> 接口</strong>，主要用于按顺序存储元素，强调的是<strong>随机访问和按索引管理数据</strong>。它的底层是一个<strong>线性动态数组</strong>，支持快速的索引访问，比如 <code>get(index)</code> 或 <code>set(index)</code> 的时间复杂度是 O(1)。但是如果在中间插入或删除元素，就会涉及到大量元素的移动，性能相对较差。</p><p>而 <strong><code>ArrayDeque</code> 实现了 <code>Deque</code> 接口</strong>，也就是双端队列，它的重点是支持从<strong>队头和队尾进行高效的插入和删除操作</strong>。它底层虽然也是数组，但用的是<strong>循环数组结构</strong>。当数组尾部空间不足时，它会自动绕回到数组头部去使用未占用的位置，这种<strong>环形结构</strong>可以避免频繁的数据移动，使得两端操作的性能非常稳定，都是 O(1) 的时间复杂度。</p><p>还有一些细节上的差异，比如：</p><ul><li><code>ArrayList</code> 允许插入 <code>null</code> 元素，而 <code>ArrayDeque</code> 明确禁止 <code>null</code>，因为它用 <code>null</code> 表示队列为空，这样更容易区分是否出队成功。</li><li>在扩容机制上，两者都支持动态扩容，但 <code>ArrayList</code> 是线性扩容（一般是原来容量的 1.5 倍），<code>ArrayDeque</code> 的容量总是 2 的幂次方，这有助于在循环数组中通过位运算快速定位元素位置。</li></ul><p>使用场景上也有差别：</p><ul><li>如果我们要频繁地访问元素，尤其是按下标访问，那肯定首选 <code>ArrayList</code>。</li><li>如果我们实现的是栈（LIFO）或队列（FIFO），尤其需要在两端进行频繁插入/删除，<code>ArrayDeque</code> 的性能和空间利用率都比 <code>LinkedList</code> 更好，更推荐使用。</li></ul><h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h1><h2 id="双向链表和双向循环链表" tabindex="-1"><a class="header-anchor" href="#双向链表和双向循环链表"><span>双向链表和双向循环链表</span></a></h2><p>在 JDK 1.6 之前，<code>LinkedList</code> 的实现是<strong>循环链表</strong>。而从 JDK 1.7 开始，Java 的 <code>LinkedList</code> 底层实现就不再使用循环链表，改用了<strong>普通的双向链表</strong>。</p><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><strong>为什么这么改？<strong>这个变化的主要原因是</strong>循环链表并不带来明显的性能优势</strong>，而反而可能带来一些复杂性和潜在的错误。例如，处理尾节点指向头节点的引用可能引发无限循环的问题，尤其是在垃圾回收时。改成普通双向链表后，结构更简单，代码也更加直观。</p><h2 id="randomaccess" tabindex="-1"><a class="header-anchor" href="#randomaccess"><span><code>RandomAccess</code></span></a></h2><p><code>RandomAccess</code> 接口不过是一个标识接口。标识实现这个接口的类具有随机访问功能。</p><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。究其原因还是和底层数据结构有关，数组天然支持随机访问，而链表需要遍历到特定位置才能访问特定位置的元素。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RandomAccess</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="fail-fast和fail-safe" tabindex="-1"><a class="header-anchor" href="#fail-fast和fail-safe"><span><code>fail-fast</code>和<code>fail-safe</code></span></a></h2><p>Fail-fast 是一种设计策略，它会在集合被修改的情况下<strong>立即抛出异常</strong>。通常，当你在迭代集合时，如果集合被修改了，迭代器就会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>Fail-safe 是另一种设计策略，它允许在遍历集合的同时<strong>修改集合的结构</strong>，并且不会抛出异常。即使在迭代过程中发生修改，迭代器也能继续正常工作。</p><p><strong>fail-fast</strong> 更侧重于提前发现错误，<strong>fail-safe</strong> 更侧重于保证并发环境下的安全操作。</p><p><code>ArrayList</code> 和 <code>HashMap</code> 的迭代器就是 <strong>fail-fast</strong> 类型的。</p><p><code>CopyOnWriteArrayList</code> 和 <code>ConcurrentHashMap</code>，它们采用了 <strong>fail-safe</strong> 策略</p><h2 id="comparable和comparator" tabindex="-1"><a class="header-anchor" href="#comparable和comparator"><span><code>Comparable</code>和<code>Comparator</code></span></a></h2><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口</p><p>首先，<code>Comparable</code> 是一个 <strong>内部比较器</strong>，它是由类自己实现的排序规则。也就是说，如果一个类实现了 <code>Comparable</code> 接口，它就必须重写 <code>compareTo()</code> 方法，并在方法中定义自己的“自然排序规则”。比如像 <code>String</code>、<code>Integer</code>、<code>Date</code> 这些类本身就实现了 <code>Comparable</code>，可以直接进行排序。</p><p>而 <code>Comparator</code> 是一个 <strong>外部比较器</strong>，它通常在我们无法修改目标类源码，或者需要灵活定义多种排序规则时使用。通过实现 <code>Comparator</code> 接口中的 <code>compare()</code> 方法，我们可以在类的外部定义排序逻辑。像我们用 <code>Collections.sort(list, comparator)</code> 或 <code>TreeMap</code> 传入比较器时，都是在使用 <code>Comparator</code>。</p><p>简单理解的话，<code>Comparable</code> 是让“对象自己可比较”，而 <code>Comparator</code> 是“通过外部工具比较对象”。另外值得注意的是，<code>Comparator</code> 支持 Lambda 表达式，所以在 Java 8 之后我们可以用非常简洁的方式写出比较逻辑。</p></div><!----><!----><!----></div><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/Nu11Cat/Nu11Cat.github.io/edit/main/docs/1.Note/1.Java &amp; CS/Java集合.md" aria-label="Edit this page" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->Edit this page<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">Last Updated:</span><time class="vp-meta-info" datetime="2025-07-24T08:02:25.000Z" data-allow-mismatch>7/24/25, 8:02 AM</time></div><div class="contributors"><span class="vp-meta-label">Contributors: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 2111867383@qq.com">Nu11Cat</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/1.Note/1.Java%20_%20CS/Java.html" aria-label="Java"><div class="hint"><span class="arrow start"></span>Prev</div><div class="link"><!---->Java</div></a><a class="route-link auto-link next" href="/1.Note/1.Java%20_%20CS/Java%20IO.html" aria-label="Java I/O"><div class="hint">Next<span class="arrow end"></span></div><div class="link">Java I/O<!----></div></a></nav><!----><!----><!--]--></main><!--]--><!----></div><!--]--><!--]--><!--[--><!----><!--[--><!--]--><!--]--><!--]--></div>
    <script type="module" src="/assets/app-CE9h3O9H.js" defer></script>
  </body>
</html>
