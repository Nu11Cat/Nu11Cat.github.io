---
title : 3.ORM 框架
---

# 目录

## 一、ORM 是什么？为什么我们需要 ORM？

- ORM 的本质：对象-关系映射
- JDBC 与 ORM 的关系与区别
- ORM 的优劣对比：开发效率 vs 性能控制

## 二、MyBatis 入门与核心概念

- MyBatis 的基本结构：Mapper、XML、SqlSession
- 配置文件详解（mybatis-config.xml / 映射器配置）
- 第一个 MyBatis 项目：如何从零构建？

## 三、MyBatis 进阶：动态 SQL 与复杂查询

- if/where/choose 标签用法详解
- foreach 处理集合（IN 查询、批量操作）
- 动态 SQL 性能问题与代码整洁度控制

## 四、MyBatis 实践：多表操作与关联映射

- 一对一 / 一对多 / 多对多 映射配置
- association / collection 标签使用详解
- 多表 join 查询封装技巧

## 五、MyBatis 插件与自定义扩展机制

- 插件拦截机制：Interceptor 原理与编写实战
- 常见三大拦截点：Executor、StatementHandler、ParameterHandler
- 分页插件 PageHelper 的工作原理与使用方式

## 六、MyBatis 与 Spring/Spring Boot 整合

- Spring 整合配置（MapperScannerConfigurer）
- Spring Boot 快速整合（starter 配置、yml）
- 与事务管理、连接池、统一异常处理联动

## 七、MyBatis 缓存机制详解

- 一级缓存与二级缓存机制
- 缓存清除、同步与冲突场景分析
- 使用与禁用缓存的实践建议

## 八、MyBatis Generator 与代码自动生成

- MBG 使用流程与配置详解
- 自定义模板生成代码
- 优化生成代码结构与风格

## 九、Hibernate 简介与对比理解

- Hibernate 与 MyBatis 的核心区别
- Hibernate 的优缺点与主流企业应用场景
- 为何大厂更偏好 MyBatis？

## 十、常见问题与面试题精选

- MyBatis 中如何防止 SQL 注入？
- 面试题：“MyBatis 和 JDBC 有什么区别？”
- 动态 SQL 写多了怎么办？如何抽象封装？
- 插件、缓存、关联映射是如何实现的？

------

# 一、ORM 是什么？为什么我们需要 ORM？

## 1.ORM 的本质：对象-关系映射

ORM（Object-Relational Mapping）是对象与关系数据库之间的映射技术，它使得开发者可以使用面向对象的方式来操作数据库，而不需要手动编写大量的 SQL 语句。ORM 通过将数据库表中的记录映射到 Java 对象，使得操作数据库变得更加简洁且符合面向对象编程的思想。

- **关系型数据库的表结构**：每个表有多条记录，每条记录都由多个字段组成，通常使用 SQL 来进行数据操作。
- **Java 对象模型**：Java 中的对象由属性和方法组成，属性用来存储数据，方法用来处理数据。对象与数据库表之间并不直接对应。

ORM 技术的核心目的是通过映射将数据库表和 Java 对象关联起来，使得数据库的操作可以通过 Java 对象的方式来完成。例如，将数据库中的一行记录映射为一个 Java 对象的属性，表的每一列映射为 Java 对象的一个字段。

#### 典型的 ORM 框架：

- **MyBatis**：基于 XML 或注解配置 SQL 映射，将 SQL 查询结果映射为 Java 对象。
- **Hibernate**：通过 JPA 标准来进行对象关系映射，使用 Hibernate 来自动生成 SQL 语句并管理持久化对象。

## 2.JDBC 与 ORM 的关系与区别

#### JDBC（Java Database Connectivity）：

- JDBC 是 Java 提供的用于连接数据库的接口，它通过驱动程序与数据库进行通信。
- 使用 JDBC 时，开发者需要手动编写 SQL 语句、处理数据库连接、关闭连接、处理异常等。这些工作相对繁琐且容易出错。

#### ORM 与 JDBC 的关系：

- ORM 实质上是对 JDBC 的一种封装与抽象。它简化了 JDBC 的操作，使得数据库操作变得更加面向对象。
- JDBC 只提供了基本的数据库访问能力，而 ORM 框架则在此基础上进一步封装了 SQL 执行与结果映射，开发者只需要关注对象而无需关注 SQL 语句的编写。

#### JDBC 与 ORM 的区别：

- **开发效率**：ORM 框架通过自动映射 Java 对象和数据库表，减少了编写 SQL 语句的工作，极大提高了开发效率。而 JDBC 需要开发者手动编写 SQL，并且处理查询结果的映射。
- **灵活性**：JDBC 提供了更大的灵活性，开发者可以自由控制 SQL 的执行，而 ORM 框架则受限于框架本身的设计。
- **性能**：JDBC 提供了更高的性能控制能力，开发者可以优化 SQL 查询和数据库操作的每一环节。ORM 框架有时会产生额外的性能开销，尤其是在处理复杂查询时。

## 3.ORM 的优劣对比：开发效率 vs 性能控制

#### ORM 的优点：

1. **开发效率高**：ORM 使得开发者可以更多地关注业务逻辑，减少了编写 SQL 和 JDBC 代码的时间。ORM 框架自动完成了对象与数据库之间的映射，减少了重复性工作。
2. **代码简洁**：通过 ORM，可以避免冗长的 JDBC 代码，直接通过 Java 对象来操作数据库，使代码更加简洁且易于维护。
3. **易于维护**：ORM 将数据库操作与业务逻辑分离，修改数据库表结构时，ORM 可以自动映射更新，减少了代码的耦合度。

#### ORM 的缺点：

1. **性能问题**：由于 ORM 框架会生成 SQL 语句并执行，这有时可能导致不必要的性能开销。比如，在处理复杂查询或大批量数据时，ORM 可能生成效率较低的 SQL。
2. **灵活性不足**：ORM 生成的 SQL 语句不一定符合开发者的最佳优化需求，特别是对于复杂查询，开发者很难完全控制 SQL 的执行过程。
3. **学习曲线**：虽然 ORM 能够提升开发效率，但对于新手开发者而言，理解 ORM 的工作机制和配置可能需要一定时间。开发者需要理解如何将数据库设计转化为对象模型，并且掌握 ORM 提供的查询语言。

#### 性能与开发效率的权衡：

- 对于简单的 CRUD 操作或需要快速开发的项目，ORM 可以显著提高开发效率，减少重复性劳动。
- 对于对性能要求高、数据库结构复杂的系统，开发者可能更倾向于使用 JDBC 或自定义 SQL 来控制性能，避免 ORM 带来的性能开销。

在实际开发中，MyBatis 就是一种良好的折中方案。它结合了 JDBC 和 ORM 的优点，开发者仍然可以手动编写 SQL，同时通过 MyBatis 提供的映射机制减少了 SQL 和 Java 对象之间的转换工作，从而提高了开发效率并且保持了一定的性能控制能力。

## 总结：

ORM 是 Java 开发中不可或缺的技术，能够有效提高开发效率，尤其是在数据库操作频繁的应用中。而 MyBatis 作为一种轻量级的 ORM 框架，通过在 JDBC 和全自动 ORM 之间找到一个平衡点，为开发者提供了一个灵活且高效的解决方案。在选择 ORM 框架时，需要根据具体项目的需求，考虑开发效率与性能控制的权衡。

# 二、MyBatis 入门与核心概念

## 1.MyBatis 的基本结构：Mapper、XML、SqlSession

MyBatis 是一个轻量级的持久层框架，它通过 SQL 映射文件（Mapper XML）与 Java 对象之间进行映射，简化了 JDBC 中 SQL 执行和结果映射的过程。MyBatis 提供了相较于 JDBC 更为灵活的数据库访问方式，并能通过映射文件将 SQL 与业务逻辑分离。MyBatis 的核心组成部分包括：

1. **Mapper**：
   - Mapper 是 MyBatis 中定义 SQL 操作的接口，类似于 DAO 层。它将 SQL 语句与 Java 方法进行映射，提供方法来执行相应的 SQL 查询、更新或删除操作。
   - 每个 Mapper 对应一个 XML 映射文件，XML 文件中定义了具体的 SQL 查询语句。
2. **XML 映射文件**：
   - 映射文件是 MyBatis 的核心配置文件之一。它定义了 SQL 查询、插入、更新和删除等操作。每个 SQL 语句会被标注为一个 `id`，并通过 `<select>`, `<insert>`, `<update>`, `<delete>` 等标签定义。
   - 映射文件的作用是将 Java 方法与 SQL 语句相对应，执行时将参数与返回结果进行自动映射。
3. **SqlSession**：
   - SqlSession 是 MyBatis 的主要接口之一，它负责管理数据库连接、执行 SQL 语句，并处理 SQL 语句执行的事务管理。
   - 在 MyBatis 中，每个数据库操作都需要通过 SqlSession 来执行，它是 MyBatis 与数据库交互的核心。

## 2.配置文件详解（mybatis-config.xml / 映射器配置）

1. **mybatis-config.xml 配置**：

   - `mybatis-config.xml` 是 MyBatis 的全局配置文件，主要用于配置 MyBatis 的运行环境，如数据源、事务管理器、全局设置等。

   典型的 `mybatis-config.xml` 配置内容如下：

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <configuration>
       <!-- 配置全局属性 -->
       <settings>
           <setting name="cacheEnabled" value="true"/>
           <setting name="lazyLoadingEnabled" value="false"/>
       </settings>
   
       <!-- 配置数据源 -->
       <environments default="development">
           <environment id="development">
               <transactionManager type="JDBC"/>
               <dataSource type="POOLED">
                   <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                   <property name="url" value="jdbc:mysql://localhost:3306/mydb"/>
                   <property name="username" value="root"/>
                   <property name="password" value="password"/>
               </dataSource>
           </environment>
       </environments>
   
       <!-- 配置映射器 -->
       <mappers>
           <mapper resource="com/example/mapper/UserMapper.xml"/>
       </mappers>
   </configuration>
   ```

   该配置文件中包括：

   - **settings**：定义 MyBatis 的全局设置，例如缓存、延迟加载等。
   - **environments**：配置数据库连接和事务管理器。
   - **mappers**：指定 Mapper 文件路径，将接口与映射文件关联。

2. **映射器配置（Mapper XML 文件）**：

   - Mapper 文件是 MyBatis 中 SQL 映射的核心部分，通常与接口类一一对应。每个 SQL 语句通过 `<select>`, `<insert>`, `<update>`, `<delete>` 标签来定义。

   例如，定义一个查询用户的 SQL：

   ```xml
   <?xml version="1.0" encoding="UTF-8" ?>
   <mapper namespace="com.example.mapper.UserMapper">
       <!-- 查询单个用户 -->
       <select id="getUserById" resultType="com.example.model.User">
           SELECT * FROM users WHERE id = #{id}
       </select>
   
       <!-- 插入用户 -->
       <insert id="insertUser" parameterType="com.example.model.User">
           INSERT INTO users(name, age) VALUES(#{name}, #{age})
       </insert>
   </mapper>
   ```

   - `namespace`：指定映射器的命名空间，通常与接口类名一致。
   - `id`：指定 SQL 语句的唯一标识符，通常对应接口中的方法名。
   - `parameterType` 和 `resultType`：指定 SQL 查询的输入参数和返回结果类型。

### 3.第一个 MyBatis 项目：如何从零构建？

接下来，我们将构建一个简单的 MyBatis 项目，步骤如下：

1. **创建项目结构**：

   - 创建一个简单的 Maven 项目，添加 MyBatis 和数据库驱动的依赖：

   ```xml
   <dependencies>
       <dependency>
           <groupId>org.mybatis</groupId>
           <artifactId>mybatis</artifactId>
           <version>3.5.6</version>
       </dependency>
       <dependency>
           <groupId>mysql</groupId>
           <artifactId>mysql-connector-java</artifactId>
           <version>8.0.23</version>
       </dependency>
   </dependencies>
   ```

2. **创建数据库表**：

   - 在 MySQL 中创建一个简单的 `users` 表：

   ```sql
   CREATE TABLE users (
       id INT PRIMARY KEY AUTO_INCREMENT,
       name VARCHAR(50),
       age INT
   );
   ```

3. **配置 MyBatis 配置文件**：

   - 按照前面提到的配置步骤，创建 `mybatis-config.xml`，配置数据源和 Mapper。

4. **编写 Mapper 接口和 XML 映射文件**：

   - 创建 `UserMapper.java` 接口和 `UserMapper.xml` 映射文件，定义查询用户和插入用户的 SQL。

5. **编写 Java 代码进行测试**：

   - 创建一个简单的 Java 程序，使用 MyBatis 的 `SqlSession` 执行 SQL 操作：

   ```java
   import org.apache.ibatis.session.SqlSession;
   import org.apache.ibatis.session.SqlSessionFactory;
   import org.apache.ibatis.session.SqlSessionFactoryBuilder;
   
   public class MyBatisExample {
       public static void main(String[] args) {
           SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(MyBatisExample.class.getResourceAsStream("/mybatis-config.xml"));
           try (SqlSession session = sqlSessionFactory.openSession()) {
               UserMapper userMapper = session.getMapper(UserMapper.class);
               
               // 查询用户
               User user = userMapper.getUserById(1);
               System.out.println("User: " + user);
               
               // 插入用户
               User newUser = new User("John", 30);
               userMapper.insertUser(newUser);
               session.commit();
           }
       }
   }
   ```

   这段代码演示了如何使用 MyBatis 来查询和插入数据。

## 总结

通过上述步骤，您已经成功创建了第一个 MyBatis 项目，了解了 MyBatis 的基本结构、配置文件的作用、以及如何使用 `SqlSession` 执行 SQL 语句。MyBatis 提供了比 JDBC 更简洁的数据库操作方式，但仍然保持了灵活性和性能控制，特别适用于需要自定义 SQL 查询的场景。

# 三、MyBatis 进阶：动态 SQL 与复杂查询

在 MyBatis 中，动态 SQL 使得 SQL 语句能够根据不同的条件和需求进行灵活生成。通过动态 SQL，开发者可以避免编写大量的重复 SQL 语句，提高代码的可维护性和复用性。在这部分内容中，我们将详细探讨 MyBatis 提供的动态 SQL 标签及其使用方法。

## if/where/choose 标签用法详解

1. **`<if>` 标签**：

   - `<if>` 标签用来根据某些条件判断是否包含某一段 SQL 语句。在 `if` 标签的 `test` 属性中，提供一个表达式，只有当表达式的值为 `true` 时，SQL 中才会加入该条件。

   **示例**：

   ```xml
   <select id="findUsers" resultType="User">
       SELECT * FROM users
       <where>
           <if test="name != null">
               AND name = #{name}
           </if>
           <if test="age != null">
               AND age = #{age}
           </if>
       </where>
   </select>
   ```

   在这个示例中，只有当 `name` 或 `age` 不为空时，对应的条件才会被加入到 SQL 语句中。

2. **`<where>` 标签**：

   - `<where>` 标签用于生成动态 SQL 语句时自动处理 `AND` 或 `OR` 的前置条件。它会在 SQL 语句的开始部分自动加上 `WHERE` 关键字，并且会去除第一个条件前多余的 `AND` 或 `OR`。

   **示例**：

   ```xml
   <select id="findUsers" resultType="User">
       SELECT * FROM users
       <where>
           <if test="name != null">AND name = #{name}</if>
           <if test="age != null">AND age = #{age}</if>
       </where>
   </select>
   ```

   使用 `<where>` 标签，可以避免在 SQL 语句中手动处理 `AND` 的前置条件。

3. **`<choose>` 标签**：

   - `<choose>` 标签提供类似于 `if-else` 语句的功能，它会根据条件判断选择执行某个 SQL 片段。通常与 `<when>` 和 `<otherwise>` 标签一起使用。

   **示例**：

   ```xml
   <select id="findUserByStatus" resultType="User">
       SELECT * FROM users
       <where>
           <choose>
               <when test="status == 'active'">
                   AND status = 'active'
               </when>
               <when test="status == 'inactive'">
                   AND status = 'inactive'
               </when>
               <otherwise>
                   AND status = 'unknown'
               </otherwise>
           </choose>
       </where>
   </select>
   ```

   `<choose>` 标签确保只有一个条件会被选中执行，而 `otherwise` 则用于当没有任何条件符合时提供默认行为。

## foreach 处理集合（IN 查询、批量操作）

1. **`<foreach>` 标签**：

   - `<foreach>` 标签用于在 SQL 中处理集合，特别是用于 `IN` 查询或批量插入操作。通过 `<foreach>` 标签，可以将 Java 集合中的每个元素都作为参数插入到 SQL 中，避免了手动拼接字符串的麻烦。

   **IN 查询示例**：

   ```xml
   <select id="findUsersByIds" resultType="User">
       SELECT * FROM users WHERE id IN
       <foreach item="id" collection="ids" open="(" close=")" separator=",">
           #{id}
       </foreach>
   </select>
   ```

   在这个例子中，`ids` 是一个传入的集合，`foreach` 标签将集合中的每个元素用逗号分隔并构建成 `IN` 查询条件。

2. **批量操作示例**：

   - `<foreach>` 标签也可用于批量操作，如批量插入或批量更新。

   **批量插入示例**：

   ```xml
   <insert id="batchInsertUsers">
       INSERT INTO users (name, age) VALUES
       <foreach item="user" collection="users" open="(" close=")" separator=",">
           #{user.name}, #{user.age}
       </foreach>
   </insert>
   ```

   在这个例子中，`users` 是一个传入的集合，`foreach` 标签将集合中的每个元素通过逗号分隔拼接成一条批量插入的 SQL 语句。

## 动态 SQL 性能问题与代码整洁度控制

1. **性能问题**：

   - 动态 SQL 在增加灵活性的同时，也可能带来性能问题，特别是在处理大量复杂查询时。MyBatis 的动态 SQL 解析会有一定的性能开销，因此在使用时需要避免过度复杂的动态查询，尽量将条件逻辑简化。

   **优化建议**：

   - 使用 `<trim>` 标签来移除多余的 `AND` 或 `OR` 条件，避免在 SQL 中产生不必要的冗余。
   - 对于复杂的查询，考虑在 Java 代码中进行条件判断，避免在 Mapper XML 中写太多复杂的动态 SQL。

2. **代码整洁度控制**：

   - 过多的动态 SQL 会使得 Mapper 文件变得难以维护和调试，影响代码的整洁度。为了避免 Mapper 文件过于臃肿，建议：
     - 将动态 SQL 拆分成多个简单的 SQL 片段，尽量保持每个 SQL 语句的简洁性。
     - 对于复杂的动态 SQL，可以考虑使用 Java 代码中的条件判断，而不是在 XML 中直接处理复杂逻辑。
     - 使用 SQL 片段和 SQL 组件来重用常见的条件和逻辑。

### 总结

MyBatis 的动态 SQL 功能提供了极大的灵活性，可以帮助开发者根据不同条件生成不同的 SQL 语句。通过 `if`、`choose`、`foreach` 等标签，开发者可以灵活控制查询条件，避免手动拼接 SQL 字符串，提高了代码的可维护性。然而，在使用动态 SQL 时需要注意性能优化和代码整洁度，避免编写过于复杂的 SQL 语句，确保系统的性能和可读性。

# 四、MyBatis 实践：多表操作与关联映射

在 MyBatis 中，涉及到多个表的操作时，我们通常会进行表之间的关联查询。MyBatis 提供了 `association` 和 `collection` 标签来支持一对一、一对多、多对多等关系映射。通过这些标签，我们可以将多个表的数据映射成 Java 对象的关系，极大地提高了代码的简洁性和可维护性。

## 一对一 / 一对多 / 多对多 映射配置

1. **一对一映射（One-to-One）**：

   - 一对一映射意味着一个对象只关联另一个对象。常见的场景是一个用户信息表与一个用户详细信息表之间的关联。

   **示例：** 假设有 `user` 表和 `user_detail` 表，其中每个 `user` 只对应一个 `user_detail`。

   ```xml
   <resultMap id="userResultMap" type="User">
       <id property="id" column="id"/>
       <result property="name" column="name"/>
       <association property="userDetail" javaType="UserDetail">
           <id property="id" column="detail_id"/>
           <result property="address" column="address"/>
           <result property="phone" column="phone"/>
       </association>
   </resultMap>
   
   <select id="getUserById" resultMap="userResultMap">
       SELECT u.id, u.name, ud.detail_id, ud.address, ud.phone
       FROM user u
       LEFT JOIN user_detail ud ON u.id = ud.user_id
       WHERE u.id = #{id}
   </select>
   ```

   这个例子中，`<association>` 标签用于将 `user` 和 `user_detail` 两个表的数据进行一对一的关联映射。

2. **一对多映射（One-to-Many）**：

   - 一对多映射表示一个对象关联多个对象，通常应用于父子表的关系。例如，一个用户可以有多个订单。

   **示例：** 假设有 `user` 表和 `order` 表，`user` 表和 `order` 表之间是一对多的关系。

   ```xml
   <resultMap id="userWithOrders" type="User">
       <id property="id" column="id"/>
       <result property="name" column="name"/>
       <collection property="orders" ofType="Order">
           <id property="orderId" column="order_id"/>
           <result property="orderDate" column="order_date"/>
           <result property="amount" column="amount"/>
       </collection>
   </resultMap>
   
   <select id="getUserWithOrders" resultMap="userWithOrders">
       SELECT u.id, u.name, o.order_id, o.order_date, o.amount
       FROM user u
       LEFT JOIN order o ON u.id = o.user_id
       WHERE u.id = #{id}
   </select>
   ```

   在这个示例中，`<collection>` 标签表示一对多关系，每个 `user` 对象可能会有多个 `order` 关联到它。

3. **多对多映射（Many-to-Many）**：

   - 多对多映射表示两个表之间存在互相关联的情况。例如，用户和角色之间通常是多对多的关系，一个用户可以拥有多个角色，而一个角色也可以被多个用户拥有。

   **示例：** 假设有 `user` 表、`role` 表和 `user_role` 表，其中 `user_role` 表是中间表，用于维护用户和角色的关系。

   ```xml
   <resultMap id="userWithRoles" type="User">
       <id property="id" column="id"/>
       <result property="name" column="name"/>
       <collection property="roles" ofType="Role">
           <id property="roleId" column="role_id"/>
           <result property="roleName" column="role_name"/>
       </collection>
   </resultMap>
   
   <select id="getUserWithRoles" resultMap="userWithRoles">
       SELECT u.id, u.name, r.role_id, r.role_name
       FROM user u
       LEFT JOIN user_role ur ON u.id = ur.user_id
       LEFT JOIN role r ON ur.role_id = r.role_id
       WHERE u.id = #{id}
   </select>
   ```

   在这个示例中，`<collection>` 标签表示多对多的关系。每个 `user` 对象会关联多个 `role` 对象。

## association / collection 标签使用详解

- **`<association>` 标签**：用于一对一关联映射。通常用来映射父表与子表之间的关系。
- **`<collection>` 标签**：用于一对多或多对多关联映射。用于将一个父对象映射为多个子对象。

#### `association` 标签示例：

```xml
<association property="userDetail" javaType="UserDetail">
    <id property="id" column="detail_id"/>
    <result property="address" column="address"/>
    <result property="phone" column="phone"/>
</association>
```

此标签会将查询结果中与 `user` 关联的 `user_detail` 通过 `userDetail` 属性映射到 `UserDetail` 对象。

#### `collection` 标签示例：

```xml
<collection property="orders" ofType="Order">
    <id property="orderId" column="order_id"/>
    <result property="orderDate" column="order_date"/>
    <result property="amount" column="amount"/>
</collection>
```

此标签会将查询结果中的多个 `order` 记录通过 `orders` 属性映射到一个 `List<Order>` 集合。

## 多表 join 查询封装技巧

在实际开发中，MyBatis 允许我们通过 `JOIN` 操作来进行多表查询，并且可以通过 `association` 和 `collection` 标签将查询结果封装到相应的 Java 对象中。

1. **封装技巧**：
   - 使用 `<resultMap>` 标签进行多表查询时，结合 `association` 和 `collection` 标签，可以有效地封装查询结果。例如，一对多的查询可以通过 `LEFT JOIN` 将所有关联的数据拿到，并通过 `collection` 将多条记录封装成一个集合。
   - 在复杂查询时，尽量通过合理的 `resultMap` 配置来减少重复查询，避免性能问题。
2. **优化查询**：
   - 对于多表查询，特别是涉及大量数据时，建议使用 `select` 子查询来减少返回的数据量，从而提高性能。
   - 可以结合分页查询的方式，避免一次性查询过多数据导致的性能瓶颈。

### 总结

MyBatis 的 `association` 和 `collection` 标签为我们处理多表关联映射提供了强大的支持。通过合理的配置和使用这些标签，我们可以轻松实现一对一、一对多和多对多的映射关系，简化代码的同时提升了开发效率。然而，在进行复杂查询时，我们需要注意查询的性能，避免出现过度复杂的 SQL 语句或不必要的嵌套查询，确保系统的高效性。

# 五、MyBatis 插件与自定义扩展机制

MyBatis 提供了一个灵活的插件扩展机制，让开发者能够对框架的执行过程进行自定义拦截和修改。通过自定义插件，可以在 MyBatis 执行某些操作时插入自己的业务逻辑，极大地提高了框架的扩展性和灵活性。

## 插件拦截机制：Interceptor 原理与编写实战

MyBatis 插件机制基于 `Interceptor` 接口，它允许我们在执行 SQL 时拦截 `Executor`、`StatementHandler`、`ResultSetHandler` 和 `ParameterHandler` 等对象的操作，进而对 SQL 执行过程、参数设置、结果映射等进行定制化处理。

#### `Interceptor` 接口的工作原理

- **Interceptor** 接口的核心方法是 `intercept`，该方法接收一个 `Invocation` 对象作为参数，`Invocation` 对象用于表示当前方法的调用（比如执行 SQL 操作）。我们可以在该方法中进行一些前置和后置的处理。
- 在插件类中，我们需要实现 `intercept` 方法，并通过 `Invocation` 对象获取当前被拦截的目标对象。然后，我们可以决定是否继续调用目标方法，或者替换目标方法的实现。

#### 自定义插件的实现步骤：

1. **实现 `Interceptor` 接口**：

   - 创建一个自定义的插件类，实现 `Interceptor` 接口，并重写 `intercept` 方法。
   - `intercept` 方法中可以处理被拦截对象的逻辑，例如修改 SQL 语句、打印日志、修改查询结果等。

2. **配置插件**：

   - 在 `mybatis-config.xml` 配置文件中注册自定义插件。

   ```xml
   <plugins>
       <plugin interceptor="com.example.MyBatisPlugin"/>
   </plugins>
   ```

#### 插件实现实例：

假设我们需要实现一个插件来记录每次 SQL 查询的执行时间：

```java
public class MyBatisPlugin implements Interceptor {

    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = invocation.proceed(); // 执行目标方法
        long endTime = System.currentTimeMillis();
        
        // 打印执行时间
        System.out.println("SQL执行时间: " + (endTime - startTime) + "ms");
        return result;
    }

    @Override
    public Object plugin(Object target) {
        // 如果目标对象是我们需要拦截的类，返回一个代理对象
        if (target instanceof Executor) {
            return Plugin.wrap(target, this); // 这里通过 Plugin.wrap 方法返回代理对象
        }
        return target;
    }

    @Override
    public void setProperties(Properties properties) {
        // 可以在这里获取插件的配置属性
    }
}
```

## 常见三大拦截点：Executor、StatementHandler、ParameterHandler

在 MyBatis 中，插件可以拦截以下三个核心对象：

1. **Executor**：负责执行 SQL 语句，通常是最核心的执行者。通过插件拦截 `Executor`，我们可以对整个查询、更新、删除操作进行修改，例如对 SQL 查询结果进行缓存等。
2. **StatementHandler**：负责构建 SQL 语句并将其发送到数据库。我们可以在这个阶段拦截 SQL 语句，进行 SQL 语句的修改、增强（例如为 SQL 动态添加条件）等操作。
3. **ParameterHandler**：负责将参数绑定到 SQL 语句中。通过拦截 `ParameterHandler`，我们可以修改传递给 SQL 的参数，例如添加额外的查询条件。

通过这些拦截点，我们可以精确控制 MyBatis 的执行过程，实现多种定制化的功能。

#### 示例：拦截 Executor 进行 SQL 打印

```java
public class SqlLoggingInterceptor implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        // 只拦截 Executor 类
        if (invocation.getTarget() instanceof Executor) {
            System.out.println("正在执行 SQL...");
        }
        
        // 执行目标方法
        return invocation.proceed();
    }
    
    @Override
    public Object plugin(Object target) {
        // 如果是 Executor 类型的对象，创建代理对象
        if (target instanceof Executor) {
            return Plugin.wrap(target, this);
        }
        return target;
    }

    @Override
    public void setProperties(Properties properties) {
        // 可以读取插件的配置
    }
}
```

## 分页插件 PageHelper 的工作原理与使用方式

PageHelper 是一个非常流行的 MyBatis 分页插件，它能够让我们非常轻松地实现 SQL 查询的分页功能。PageHelper 不需要修改原来的 SQL 查询，而是通过对 MyBatis 执行的 SQL 语句进行拦截，在查询时自动添加分页条件。

#### 使用方式：

1. **添加依赖**： 在 `pom.xml` 中添加 PageHelper 依赖：

   ```xml
   <dependency>
       <groupId>com.github.pagehelper</groupId>
       <artifactId>pagehelper</artifactId>
       <version>5.2.0</version>
   </dependency>
   ```

2. **配置 PageHelper 插件**： 在 `mybatis-config.xml` 中配置 PageHelper 插件：

   ```xml
   <plugins>
       <plugin interceptor="com.github.pagehelper.PageInterceptor">
           <property name="dialect" value="mysql"/>
       </plugin>
   </plugins>
   ```

3. **在查询方法中使用 PageHelper**： 在调用查询方法前，使用 `PageHelper.startPage` 设置分页参数，查询结果会自动分页。

   ```java
   // 使用 PageHelper 进行分页
   PageHelper.startPage(1, 10); // 第1页，每页10条数据
   List<User> users = userMapper.selectUsers();
   PageInfo<User> pageInfo = new PageInfo<>(users);
   System.out.println(pageInfo.getTotal()); // 获取总记录数
   ```

#### PageHelper 工作原理：

- 在执行查询前，PageHelper 会拦截 SQL 语句，自动为 SQL 语句添加 `LIMIT` 子句，使查询仅返回指定页数的数据。
- PageHelper 使用 MyBatis 的插件机制拦截执行过程，在查询时动态修改 SQL 语句。
- 分页结果由 `PageInfo` 对象封装，包含分页所需的基本信息，如总记录数、当前页数、每页记录数等。

### 总结

MyBatis 插件机制为开发者提供了强大的定制功能，通过自定义插件可以在 SQL 执行过程中加入额外的逻辑，如日志打印、缓存处理、性能监控等。常见的拦截点包括 `Executor`、`StatementHandler` 和 `ParameterHandler`，通过这些拦截点可以细粒度地控制 SQL 执行过程。分页插件 PageHelper 是一个非常常见的使用插件，它能够自动为查询添加分页条件，简化分页功能的实现。通过这些功能，开发者能够轻松地实现更加灵活和高效的数据访问层。

# 六、MyBatis 与 Spring/Spring Boot 整合

MyBatis 是 Java 开发中非常流行的 ORM 框架，它能够将 SQL 查询与 Java 对象之间的映射工作进行简化。与 Spring 和 Spring Boot 整合，能够充分发挥两者的优势，提升开发效率、代码的可维护性及项目的扩展性。

## Spring 整合配置（MapperScannerConfigurer）

在传统的 Spring 项目中，整合 MyBatis 需要进行一些手动配置，最常见的方式是通过 `MapperScannerConfigurer` 来扫描 Mapper 接口并自动注册到 Spring 容器中。

#### 1.1 配置数据源与 MyBatis 相关 Bean

首先，配置数据源，并在 Spring 的配置文件中设置 `SqlSessionFactoryBean` 和 `MapperScannerConfigurer`。这些配置通常放在 `applicationContext.xml` 或 Java 配置类中。

```xml
<!-- 配置数据源 -->
<bean id="dataSource" class="org.apache.commons.dbcp2.BasicDataSource">
    <property name="driverClassName" value="com.mysql.cj.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC"/>
    <property name="username" value="root"/>
    <property name="password" value="root"/>
</bean>

<!-- SqlSessionFactoryBean 配置 -->
<bean id="sqlSessionFactory" class="org.apache.ibatis.session.SqlSessionFactoryBean">
    <property name="dataSource" ref="dataSource"/>
    <property name="mapperLocations" value="classpath:mapper/*.xml"/>
</bean>

<!-- 配置 MapperScannerConfigurer，用于扫描 Mapper 接口 -->
<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
    <property name="basePackage" value="com.example.mapper"/>
</bean>
```

#### 1.2 配置事务管理器

在 Spring 配置文件中，还需要配置事务管理器，确保事务能够在 MyBatis 和 Spring 之间流畅地管理。

```xml
<!-- 配置事务管理器 -->
<bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
    <property name="dataSource" ref="dataSource"/>
</bean>
```

通过这些配置，Spring 就能够管理 MyBatis 的 SQL 会话以及事务。

## Spring Boot 快速整合（starter 配置、yml）

Spring Boot 的出现极大地简化了 Java 应用程序的配置与集成。对于 MyBatis，Spring Boot 提供了官方的 `mybatis-spring-boot-starter`，只需要在 `pom.xml` 中添加依赖并进行少量配置，即可快速整合 MyBatis。

#### 2.1 添加 MyBatis Starter 依赖

在 Spring Boot 项目中，可以直接使用 `mybatis-spring-boot-starter`，如下所示：

```xml
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.2.0</version>
</dependency>
```

#### 2.2 配置数据源与 MyBatis 设置

MyBatis 配置通常都可以放到 `application.yml` 或 `application.properties` 文件中。以下是 `application.yml` 配置的示例：

```yaml
spring:
  datasource:
    url: jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=UTC
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 10

  mybatis:
    mapper-locations: classpath:mapper/*.xml
    type-aliases-package: com.example.model
    configuration:
      log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
```

在 `application.yml` 中，我们通过 `spring.datasource` 配置了数据源，`spring.mybatis` 配置了 MyBatis 的映射文件和类型别名。

#### 2.3 创建 Mapper 接口与 XML 文件

1. **Mapper 接口**：定义数据访问方法。

```java
@Mapper
public interface UserMapper {
    User findUserById(int id);
}
```

1. **Mapper XML 文件**：定义 SQL 查询语句。

```xml
<mapper namespace="com.example.mapper.UserMapper">
    <select id="findUserById" resultType="com.example.model.User">
        SELECT * FROM users WHERE id = #{id}
    </select>
</mapper>
```

## 与事务管理、连接池、统一异常处理联动

#### 3.1 事务管理

在 Spring Boot 中，事务管理非常简单。我们可以通过 `@Transactional` 注解来标记需要事务支持的方法。Spring 会自动管理事务的开启、提交与回滚。

```java
@Service
public class UserService {

    @Autowired
    private UserMapper userMapper;

    @Transactional
    public void updateUser(User user) {
        userMapper.update(user);
        // 执行其他业务逻辑
    }
}
```

#### 3.2 连接池配置

Spring Boot 默认使用 `HikariCP` 作为连接池，但你也可以根据需要切换成其他连接池（如 DBCP、C3P0）。连接池的配置可以通过 `application.yml` 进行管理。

```yaml
spring:
  datasource:
    hikari:
      minimum-idle: 5
      maximum-pool-size: 20
      idle-timeout: 30000
      max-lifetime: 600000
```

#### 3.3 统一异常处理

在项目中，可能会有多种数据库操作抛出异常（如 SQL 异常、事务回滚等）。为了提高代码的可维护性，我们可以通过统一的异常处理机制来捕获并处理所有的数据库相关异常。

1. **自定义异常类**：

```java
public class DatabaseException extends RuntimeException {
    public DatabaseException(String message) {
        super(message);
    }
}
```

1. **统一异常处理**：

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(DatabaseException.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<String> handleDatabaseException(DatabaseException ex) {
        return new ResponseEntity<>("Database error: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(Exception.class)
    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR)
    public ResponseEntity<String> handleGlobalException(Exception ex) {
        return new ResponseEntity<>("An unexpected error occurred: " + ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

通过上述方式，我们可以确保在应用中所有的数据库异常都能被捕获并统一处理，从而提高系统的可靠性。

### 总结

MyBatis 与 Spring/Spring Boot 的整合极大地简化了数据库操作，开发者只需要专注于业务逻辑即可。Spring 配置通过 `MapperScannerConfigurer` 或 `@Mapper` 注解实现 Mapper 的扫描和注册，而 Spring Boot 更通过 `mybatis-spring-boot-starter` 实现了快速集成。事务管理、连接池和统一异常处理是项目中的基础功能，它们通过注解、配置文件和统一处理机制提升了开发效率和系统健壮性。

# 七、MyBatis 缓存机制详解

MyBatis 提供了强大的缓存机制，通过缓存可以显著提升数据库查询的性能。MyBatis 的缓存主要分为 **一级缓存** 和 **二级缓存**，每种缓存有不同的应用场景和使用方法。在本节中，我们将详细探讨 MyBatis 的缓存机制，并给出一些实践建议。

## 一级缓存与二级缓存机制

#### 1.1 一级缓存

**一级缓存**是 MyBatis 默认启用的缓存，它的作用范围是 **SqlSession**，也就是说，同一个 SqlSession 在一次操作中会复用已经查询到的数据。一级缓存是 **缓存到内存中**，当相同的查询语句在同一个 SqlSession 中多次执行时，MyBatis 会直接从缓存中读取结果，而不会去数据库查询。

- **特点：**

  - 作用范围：同一个 `SqlSession` 内有效
  - 生命周期：随着 `SqlSession` 的创建和销毁而创建和销毁
  - 默认启用：MyBatis 默认启用一级缓存
  - 线程安全：每个 SqlSession 是线程隔离的，因此一级缓存是线程安全的

- **示例代码：**

  ```java
  SqlSession sqlSession = sqlSessionFactory.openSession();
  User user1 = sqlSession.selectOne("com.example.mapper.UserMapper.selectUser", 1);
  User user2 = sqlSession.selectOne("com.example.mapper.UserMapper.selectUser", 1);
  
  // 两次查询都会使用一级缓存，查询结果不会被实际执行 SQL
  assert user1 == user2;  // true, 因为是同一个 SqlSession 内部缓存的数据
  ```

- **缓存清除：** 一级缓存会在以下情况时清除：

  - `SqlSession` 关闭时，缓存会被清除
  - `clearCache()` 方法被调用时，缓存会被清除
  - 执行更新、插入或删除操作时，缓存也会被清除

#### 1.2 二级缓存

**二级缓存**是跨 `SqlSession` 共享的缓存。也就是说，多个 SqlSession 之间可以共享缓存中的数据。二级缓存是 **基于 Mapper 映射文件**进行的，它可以缓存查询结果，减少对数据库的查询次数，从而提高系统性能。

- **特点：**

  - 作用范围：跨 `SqlSession`，即同一个 Mapper 的多个 SqlSession 之间共享缓存
  - 生命周期：在整个 SqlSessionFactory 生命周期内有效，直到应用关闭或者手动清除
  - 需要显式启用：MyBatis 默认没有启用二级缓存，需要在 `mybatis-config.xml` 文件中进行配置
  - 支持自定义缓存实现：MyBatis 允许使用自定义的缓存实现类，甚至可以集成 Redis 等外部缓存系统

- **二级缓存的配置：**

  1. **启用二级缓存：** 在 `mybatis-config.xml` 中启用二级缓存：

     ```xml
     <configuration>
         <settings>
             <setting name="cacheEnabled" value="true"/>
         </settings>
     </configuration>
     ```

  2. **在 Mapper XML 中启用二级缓存：** 在对应的 Mapper XML 文件中，配置 `<cache>` 标签启用二级缓存：

     ```xml
     <mapper namespace="com.example.mapper.UserMapper">
         <cache/>
         <select id="selectUser" resultType="com.example.model.User">
             SELECT * FROM users WHERE id = #{id}
         </select>
     </mapper>
     ```

  3. **清空缓存：** 你可以手动清空二级缓存，调用 `SqlSession.clearCache()` 方法。

- **示例代码：**

  ```java
  SqlSession sqlSession1 = sqlSessionFactory.openSession();
  User user1 = sqlSession1.selectOne("com.example.mapper.UserMapper.selectUser", 1);
  
  SqlSession sqlSession2 = sqlSessionFactory.openSession();
  User user2 = sqlSession2.selectOne("com.example.mapper.UserMapper.selectUser", 1);
  
  // 使用二级缓存时，如果缓存启用并且数据未被更新，则这两个查询会从缓存中获取数据
  assert user1 == user2;  // true, 因为是跨 SqlSession 的二级缓存
  ```

## 缓存清除、同步与冲突场景分析

#### 2.1 缓存清除

缓存的清除是 MyBatis 缓存机制中的一个重要概念。如果数据发生了变化（例如插入、更新、删除操作），缓存中的数据应该被清除，以保证数据的一致性。缓存清除通常有以下几种场景：

1. **手动清除缓存：**
   - 你可以在执行数据库更新操作后，手动调用 `SqlSession.clearCache()` 清除缓存。
2. **自动清除缓存：**
   - 插入、更新或删除操作会自动清除相应的缓存数据。
3. **使用 `flushCache`：**
   - 在某些特殊场景下，你可能需要强制刷新缓存。可以使用 `flushCache` 属性来控制。

```xml
<insert id="insertUser" flushCache="true">
    INSERT INTO users (name, age) VALUES (#{name}, #{age});
</insert>
```

#### 2.2 缓存同步

MyBatis 默认情况下，二级缓存是不同 `SqlSession` 之间共享的，但这意味着当某个 `SqlSession` 更新了数据库的数据时，其他缓存中的数据可能会变得不一致。因此，缓存同步非常重要。

- **同步机制：** 你可以使用缓存的 `flushCache` 属性来同步缓存。例如，当你执行数据库更新操作时，`flushCache="true"` 会确保其他 `SqlSession` 缓存中的数据被刷新。

#### 2.3 缓存冲突

在使用二级缓存时，可能会出现缓存冲突的情况。例如，多个 `SqlSession` 同时访问并修改缓存中的同一条数据，这时就可能导致缓存的脏读问题。为了避免这种问题，可以采取以下措施：

- **使用事务：** 确保同一个事务中的数据修改操作能够同步到缓存中，防止多个 `SqlSession` 读取脏数据。
- **细粒度的缓存清理：** 在执行数据修改操作后，及时清除缓存，确保缓存中始终保持最新的数据。

## 使用与禁用缓存的实践建议

#### 3.1 使用缓存的场景

- **高并发读操作：** 对于一些频繁查询且更新不频繁的业务场景，使用二级缓存可以显著减少数据库的压力，提升系统性能。
- **只读操作：** 如果某些数据基本不发生变化，可以考虑启用二级缓存，从而减少查询次数。

#### 3.2 禁用缓存的场景

- **高频更新操作：** 如果某些数据经常发生变更，启用缓存反而会导致数据不一致，因此可以考虑禁用缓存。
- **不需要缓存的操作：** 对于一些数据量较小或查询不频繁的操作，可以选择不使用缓存，避免缓存带来的开销。

#### 3.3 实践建议

- **谨慎使用二级缓存：** 在频繁更新的表中使用二级缓存时要小心，可能会导致缓存不一致的问题。
- **清除缓存时机：** 对于更新、插入、删除操作，及时清理相关缓存，防止脏读。

## 总结

MyBatis 的缓存机制是提升数据库性能的重要手段，通过合理使用一级缓存和二级缓存，可以显著减少数据库访问次数，提升系统响应速度。然而，缓存的使用也需要权衡数据一致性和性能之间的关系，确保在正确的场景中使用缓存。我们需要根据实际业务场景来合理配置缓存、清除缓存，并避免缓存冲突，以保证系统的稳定性和性能。

# 八、MyBatis Generator 与代码自动生成

MyBatis Generator (MBG) 是 MyBatis 官方提供的一个工具，旨在自动化生成 MyBatis 的相关代码，尤其是数据访问层的代码，如实体类、Mapper 接口、Mapper XML 文件等。通过使用 MBG，可以极大地提高开发效率，避免重复工作，并确保代码的一致性和规范性。

在这一节中，我们将深入探讨 MyBatis Generator 的使用，包括如何配置 MBG，如何自定义代码模板，以及如何优化生成的代码结构和风格。

## 1. MBG 使用流程与配置详解

#### 1.1 MBG 简介

MyBatis Generator 是一个代码生成工具，能够自动根据数据库表结构生成对应的实体类、Mapper 接口以及 XML 配置文件。它支持 MyBatis、MyBatis3 和 MyBatis-Spring 等不同版本的配置，并且具有较强的扩展性。

MBG 的主要生成目标包括：

- **实体类**（POJO）：数据库表的对应 Java 对象。
- **Mapper 接口**：提供基本的 CRUD 操作。
- **Mapper XML 文件**：对应的 SQL 映射文件，包含与数据库交互的 SQL 语句。

#### 1.2 配置文件解析

MyBatis Generator 的核心配置文件是 `generatorConfig.xml`。在该文件中，你可以定义数据库连接信息、生成目标路径、以及需要生成的表。

**示例配置文件：**

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>

    <!-- 数据库连接配置 -->
    <context id="MySql" targetRuntime="MyBatis3">
        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3306/mydatabase" userId="root" password="password" />
        
        <!-- 生成的代码放在哪个包 -->
        <javaModelGenerator targetPackage="com.example.model" targetProject="src/main/java"/>
        <sqlMapGenerator targetPackage="com.example.mapper" targetProject="src/main/resources"/>
        <javaClientGenerator targetPackage="com.example.mapper" targetProject="src/main/java" type="XMLMAPPER"/>

        <!-- 需要生成代码的表 -->
        <table tableName="user" domainObjectName="User"/>
        <table tableName="order" domainObjectName="Order"/>

    </context>

</generatorConfiguration>
```

- **jdbcConnection**：配置数据库连接信息。
- **javaModelGenerator**：配置生成的实体类存放位置。
- **sqlMapGenerator**：配置生成的 Mapper XML 文件存放位置。
- **javaClientGenerator**：配置生成的 Mapper 接口存放位置。
- **table**：指定需要生成代码的表，并定义生成的实体类名称。

#### 1.3 执行生成操作

配置完成后，你可以使用 MBG 提供的插件或命令行工具来执行代码生成操作。常见的执行方式是通过 Maven 插件。

**Maven 配置：**

在 `pom.xml` 中配置 MBG 插件：

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.mybatis.generator</groupId>
            <artifactId>mybatis-generator-maven-plugin</artifactId>
            <version>1.3.7</version>
            <executions>
                <execution>
                    <goals>
                        <goal>generate</goal>
                    </goals>
                    <configuration>
                        <configurationFile>src/main/resources/generatorConfig.xml</configurationFile>
                    </configuration>
                </execution>
            </executions>
        </plugin>
    </plugins>
</build>
```

然后执行 `mvn mybatis-generator:generate` 命令，MBG 会根据 `generatorConfig.xml` 配置自动生成代码。

## 2. 自定义模板生成代码

MyBatis Generator 提供了自定义模板的功能，允许开发者根据自己的需求修改生成的代码风格、结构和内容。MBG 使用的是 Velocity 模板引擎来生成代码。

#### 2.1 自定义模板配置

要定制生成的代码，首先需要在配置文件中指定自定义模板路径。例如，修改实体类的模板文件：

```xml
<javaModelGenerator targetPackage="com.example.model" targetProject="src/main/java">
    <property name="enableSubPackages" value="true"/>
    <property name="trimStrings" value="true"/>
    <property name="template" value="src/main/resources/templates/Model.java.vm"/>
</javaModelGenerator>
```

在此配置中，`template` 指定了自定义的 Velocity 模板路径。模板文件 `Model.java.vm` 需要包含 MyBatis Generator 需要的变量和语法。

#### 2.2 自定义模板示例

假设我们希望生成的实体类有一些额外的字段（例如 `createdAt` 和 `updatedAt`），可以在模板中使用 Velocity 的语法来实现：

```velocity
public class ${domainObjectName} {
    private Integer id;
    private String name;
    private Date createdAt;
    private Date updatedAt;

    // getter 和 setter
}
```

通过修改模板，开发者可以控制生成代码的结构、样式和功能。

#### 2.3 自定义插件

MBG 还允许通过自定义插件来扩展生成逻辑。例如，某些表需要额外的字段或方法，可以通过插件在生成过程中注入额外的内容。

自定义插件通常通过实现 `Plugin` 接口来扩展 MBG 的行为。

## 3. 优化生成代码结构与风格

MBG 自动生成的代码虽然功能完备，但有时并不符合企业的代码规范。为了使生成的代码更加符合实际应用，开发者可以对生成的代码结构和风格进行优化。

#### 3.1 统一命名规范

通过在模板中使用自定义的命名规则，确保生成的代码符合项目的命名规范。例如，统一使用 `CamelCase` 命名法来生成类和属性名。

#### 3.2 增加自定义方法

除了生成基本的 CRUD 方法外，开发者可以通过自定义模板为生成的 `Mapper` 添加一些通用方法，比如 `findById`、`findByName` 等常用查询方法。

#### 3.3 整理代码结构

对于生成的 `Mapper` 和 `Service` 层代码，开发者可以在生成后手动进行优化，例如合并重复代码、规范注释、添加日志等，以提高代码的可维护性。

## 4. 总结

MyBatis Generator 是一个非常强大的工具，可以自动化生成 MyBatis 相关的代码，大大减少了手动编写代码的工作量。通过合理配置 `generatorConfig.xml` 文件、使用自定义模板以及优化生成的代码结构，开发者可以生成符合项目规范、高质量的代码，提高开发效率，并且避免低级的错误。

然而，尽管 MBG 生成的代码在很多场景下足够使用，开发者仍然需要在项目中根据具体业务需求对代码进行进一步的调整和优化。

# 九、Hibernate 简介与对比理解

Hibernate 是一种流行的 Java ORM（对象关系映射）框架，它为开发者提供了对象和数据库之间的映射机制，可以将 Java 对象映射为数据库表，从而简化了开发人员操作数据库的复杂性。与 MyBatis 相比，Hibernate 是一种更为“自动化”的框架，减少了大量 SQL 语句的编写，而更多地依赖于框架自动生成的 SQL。

在这一部分，我们将深入探讨 Hibernate 与 MyBatis 的区别、Hibernate 的优缺点，以及它在主流企业中的应用场景，最后分析为何一些大厂和中小企业更倾向于选择 MyBatis 而不是 Hibernate。

## 1. Hibernate 与 MyBatis 的核心区别

Hibernate 和 MyBatis 都是广泛使用的 Java 持久化框架，但它们的设计理念和使用方式有所不同。

#### 1.1 ORM 与 SQL 映射

- **Hibernate**：是一个全面的 ORM 框架，提供了完整的对象关系映射（Object-Relational Mapping）功能。它通过注解或者 XML 配置文件自动完成 Java 对象与数据库表之间的映射。Hibernate 自动处理 SQL 的生成，因此开发者不需要关注 SQL 的编写，更多地关注于对象的设计和业务逻辑。
- **MyBatis**：则是一种半自动化的框架，更关注 SQL 语句的编写。MyBatis 通过映射文件（XML）将 SQL 语句与 Java 对象映射，开发者可以完全控制 SQL 的执行逻辑。MyBatis 不像 Hibernate 那样依赖于自动生成 SQL，而是要求开发者手动编写 SQL 查询。

#### 1.2 SQL 控制粒度

- **Hibernate**：采用了“隐式”的方式来处理 SQL，许多 SQL 操作由 Hibernate 自动生成，这意味着开发者不需要手写 SQL，但这也减少了对 SQL 控制的灵活性。Hibernate 会根据对象的变化自动生成适合的 SQL 语句。
- **MyBatis**：则提供了更高的灵活性和控制权，开发者可以直接编写复杂的 SQL 语句。MyBatis 通过 XML 映射文件或者注解支持 SQL 与对象之间的映射，使得开发者可以在数据库操作中直接控制 SQL 语句，适用于复杂的查询和优化。

#### 1.3 数据库性能与优化

- **Hibernate**：为了简化开发，Hibernate 采取了延迟加载、缓存等机制来优化数据库操作。然而，默认情况下，Hibernate 可能会执行较多的数据库查询，尤其是当存在复杂的关联时（如一对多、多对多关系），这可能导致性能下降。
- **MyBatis**：由于开发者手动编写 SQL，因此可以针对特定场景进行更精细的优化。例如，通过优化查询语句、减少不必要的查询等方式，MyBatis 可以更精确地控制 SQL 执行，通常在性能要求较高的场景下表现更好。

## 2. Hibernate 的优缺点与主流企业应用场景

#### 2.1 优点

- **简化开发**：Hibernate 自动管理对象与数据库之间的映射，简化了开发者的工作，避免了大量的重复 SQL 编写。
- **自动化管理**：支持一级缓存、二级缓存和查询缓存，减少了数据库的访问频率，提升了性能。
- **跨数据库支持**：Hibernate 对不同数据库具有良好的支持，开发者可以通过配置轻松切换不同的数据库。
- **高级特性**：支持对象级的事务管理、延迟加载、级联操作等高级功能，适合复杂的数据模型。

#### 2.2 缺点

- **性能开销**：由于 Hibernate 是一个全自动化的框架，它通常会引入性能上的一些开销。特别是在处理复杂查询或者关系映射时，生成的 SQL 可能不够高效。
- **学习曲线较陡**：Hibernate 需要较为深入的理解，如映射关系、查询语言 HQL、缓存机制等，学习曲线相对较高。
- **SQL 可控性差**：在复杂查询场景下，Hibernate 自动生成的 SQL 语句可能不如手写的 SQL 高效，特别是在 SQL 优化的细节上。

#### 2.3 应用场景

Hibernate 适用于以下场景：

- **复杂的数据模型**：当应用程序的数据模型复杂，包含大量的关联、继承等关系时，Hibernate 能够通过其强大的映射功能有效简化开发。
- **跨数据库支持**：如果系统需要支持多个不同的数据库，Hibernate 的数据库独立性是一个重要优势。
- **快速开发**：对于快速开发和原型设计，Hibernate 可以帮助开发者快速构建应用，减少 SQL 语句的编写。

## 3. 为何大厂更偏好 MyBatis？

尽管 Hibernate 拥有很多优点，但大多数国内大厂和开发者在项目中更倾向于使用 MyBatis，主要有以下几个原因：

#### 3.1 SQL 控制权

MyBatis 给予开发者更多的 SQL 控制权，使得开发者能够精细地优化每一个 SQL 查询。在一些对性能有严格要求的应用中，手动控制 SQL 语句是非常重要的，MyBatis 在这方面的灵活性使其更适用于大规模、高性能的系统。

#### 3.2 学习曲线平缓

与 Hibernate 相比，MyBatis 的学习曲线较为平缓。开发者只需熟悉 SQL 和 Java，对 SQL 的优化和调试也更为直观。而 Hibernate 的自动化特性，虽然能提高开发效率，但在性能优化方面相对麻烦，开发者需要理解更多复杂的配置和机制。

#### 3.3 复杂查询需求

许多企业应用中，查询语句往往比较复杂，尤其是多表联接、分页查询、动态查询等。MyBatis 的 XML 映射方式可以灵活处理复杂的 SQL，而 Hibernate 在处理复杂查询时可能会产生性能瓶颈。

#### 3.4 适应性与灵活性

MyBatis 允许开发者自定义 SQL，能够灵活地根据项目需求调整和优化数据库访问。相反，Hibernate 的自动生成 SQL 有时可能无法满足开发者对 SQL 语句的精细控制，导致性能问题。

#### 3.5 社区与支持

MyBatis 作为一个轻量级框架，得到了广泛的支持，特别是在国内，MyBatis 的社区非常活跃，开发者可以容易找到解决方案和最佳实践。同时，MyBatis 的文档也相对简单易懂，使得团队成员能更快上手。

## 4. 总结

Hibernate 与 MyBatis 是两种不同的持久化框架，各有优缺点。Hibernate 适合于需要快速开发、跨数据库支持以及处理复杂数据模型的场景，但其性能开销和 SQL 优化方面相对较弱。MyBatis 在性能控制、复杂查询和 SQL 优化上具有更大的灵活性，因此在国内很多大厂和企业中更受欢迎。

对于开发者来说，选择 Hibernate 还是 MyBatis 需要根据具体的项目需求来决定。如果项目中有复杂的业务逻辑和数据模型，并且对性能有较高要求，MyBatis 可能是更合适的选择。而如果团队更注重开发速度和数据库独立性，Hibernate 可能会更具吸引力。

# 十、常见问题与面试题精选

在这一部分，我们将列举一些在 MyBatis 使用中常见的问题以及面试中高频出现的相关题目，帮助你更好地理解和准备 MyBatis 相关知识点。

## 1. **MyBatis 中如何防止 SQL 注入？**

**SQL 注入**是指攻击者通过构造恶意 SQL 语句，将其插入到应用程序的数据库查询中，进而访问、修改甚至删除数据库中的数据。MyBatis 作为 SQL 映射框架，在防止 SQL 注入方面具有天然优势，但仍需开发者注意一些细节。

**防止 SQL 注入的方法：**

- **使用 `PreparedStatement` 替代 `Statement`**：MyBatis 默认使用 `PreparedStatement` 来执行 SQL 查询，这就意味着 SQL 语句中的参数是通过占位符（`?`）传递的，而不是直接拼接在 SQL 语句中，从而有效避免了 SQL 注入的问题。参数的值会被绑定到占位符上，而不被执行为 SQL 语句。

- **使用 MyBatis 的参数映射**：MyBatis 的 `#{}` 占位符会将参数作为预编译参数传递给数据库，避免了拼接 SQL 语句的问题。例如：

  ```xml
  <select id="getUserByUsername" parameterType="String" resultType="User">
      SELECT * FROM users WHERE username = #{username}
  </select>
  ```

  上述方式避免了将用户输入直接拼接到 SQL 中。

- **避免拼接动态 SQL 时直接插入用户输入的值**：如果你使用 MyBatis 的动态 SQL（如 `<if>`、`<choose>`、`<where>` 等标签）时，必须谨慎避免直接将用户输入的值拼接进 SQL 中。确保所有用户输入的参数都通过 `#{}` 进行绑定。

**总结**：MyBatis 本身已经做好了防止 SQL 注入的基本保障，关键在于开发者不要直接拼接 SQL 查询，而是要始终使用参数映射。

------

## 2. **面试题：“MyBatis 和 JDBC 有什么区别？”**

这是一个常见的面试问题，面试官希望考察你对 MyBatis 和 JDBC 之间区别的理解。

**区别点：**

- **开发效率**：
  - **JDBC**：需要开发者手动编写 SQL 语句，进行参数绑定、结果集解析等工作。通常要编写大量的 boilerplate 代码，工作量大。
  - **MyBatis**：通过 XML 映射文件或者注解来映射 SQL 查询，减少了很多重复代码，开发效率更高。
- **SQL 控制**：
  - **JDBC**：开发者完全控制 SQL 语句的编写，能够灵活处理各种查询。
  - **MyBatis**：MyBatis 通过配置文件或注解映射 SQL，但开发者依然可以完全控制 SQL，且相比 Hibernate 具有更高的 SQL 可控性。
- **对象关系映射（ORM）**：
  - **JDBC**：没有 ORM 特性，开发者需要手动处理对象与数据库之间的转换。
  - **MyBatis**：虽然 MyBatis 不是全自动的 ORM 框架，但它提供了对对象和数据库的映射支持，简化了对象的转换。
- **性能**：
  - **JDBC**：由于是纯手动操作 SQL，开发者可以更精确地控制性能，但需要自己优化。
  - **MyBatis**：虽然性能略低于 JDBC，但 MyBatis 提供了缓存机制、批量处理等优化手段，性能足够满足大多数应用需求。

**总结**：JDBC 提供了更高的灵活性和控制能力，但需要大量的重复性代码，而 MyBatis 提供了一个更高层次的抽象，简化了数据库操作的开发工作。

------

## 3. **动态 SQL 写多了怎么办？如何抽象封装？**

在使用 MyBatis 时，动态 SQL 是常见的需求，但如果过度依赖动态 SQL，可能会使得代码变得难以维护和理解。

**解决方案：**

- **抽象封装**：可以通过创建独立的 Mapper 方法来封装复杂的动态 SQL，将动态 SQL 的逻辑封装在 XML 文件中。这样，在业务逻辑层面，开发者只需调用封装好的 Mapper 方法，而不需要直接处理复杂的 SQL。

  例如，在查询条件非常复杂时，可以把动态 SQL 的构建逻辑封装到一个方法里：

  ```xml
  <select id="searchUsers" resultType="User">
      <trim prefix="SELECT * FROM users WHERE" suffixOverrides="AND">
          <if test="username != null"> AND username = #{username}</if>
          <if test="age != null"> AND age = #{age}</if>
      </trim>
  </select>
  ```

  上面的 SQL 逻辑会根据实际条件自动拼接，开发者无需直接处理 SQL 的拼接。

- **使用 `<sql>` 标签进行复用**：在 MyBatis 中，可以使用 `<sql>` 标签将常用的 SQL 片段进行复用，避免重复编写相同的 SQL 逻辑。例如：

  ```xml
  <sql id="userBaseColumns">
      username, age, email
  </sql>
  
  <select id="selectUsers" resultType="User">
      SELECT <include refid="userBaseColumns"/> FROM users WHERE age &gt; #{age}
  </select>
  ```

  通过这种方式，动态 SQL 的冗余代码可以得到有效复用。

- **利用注解简化 SQL**：对于简单的动态查询，MyBatis 支持使用注解方式定义 SQL 查询，可以减少 XML 配置的复杂度。

**总结**：合理抽象封装和复用是避免动态 SQL 过多而使代码复杂化的好方法。避免直接在业务代码中写复杂的动态 SQL，通过 Mapper 层来管理 SQL。

------

## 4. **插件、缓存、关联映射是如何实现的？**

**插件机制：**

- MyBatis 提供了一个插件机制，允许开发者通过编写 `Interceptor` 来拦截和修改 MyBatis 的行为。插件可以用于监控、日志记录、性能监控、缓存等。MyBatis 支持以下三种主要的拦截点：

  - **Executor**：用于拦截数据库操作，如增、删、改、查。
  - **StatementHandler**：用于拦截 SQL 的执行前后，可以修改 SQL 语句。
  - **ParameterHandler**：用于拦截 SQL 参数的设置。

  示例：

  ```java
  public class MyBatisInterceptor implements Interceptor {
      @Override
      public Object intercept(Invocation invocation) throws Throwable {
          // 插件逻辑
          return invocation.proceed();
      }
  }
  ```

**缓存机制：**

- **一级缓存**：MyBatis 内置的一级缓存是基于 `SqlSession` 的，默认开启，并且在同一个 `SqlSession` 内部，查询相同数据时会直接从缓存中获取，避免重复查询数据库。

- **二级缓存**：二级缓存是跨 `SqlSession` 的缓存，缓存的是查询结果。当多个 `SqlSession` 请求相同的数据时，MyBatis 会首先检查二级缓存。如果缓存中有结果，则直接返回，否则再从数据库加载。二级缓存需要显式配置并启用。

  配置二级缓存：

  ```xml
  <cache />
  ```

**关联映射：**

- MyBatis 支持一对一、一对多、多对多的关系映射。通过 `association` 和 `collection` 标签，可以方便地处理对象之间的关联关系。

  示例（`association`）：

  ```xml
  <resultMap id="userResultMap" type="User">
      <id property="id" column="id"/>
      <result property="username" column="username"/>
      <association property="address" column="address_id" javaType="Address" 
                   select="selectAddressById"/>
  </resultMap>
  ```

**总结**：MyBatis 的插件、缓存和关联映射机制使得开发者可以灵活地扩展功能并优化性能，同时在处理复杂的数据关系时，能够保持代码的简洁性和可维护性。