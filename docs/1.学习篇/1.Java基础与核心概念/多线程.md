---
5.多线程
---

## 基本概念

**进程**就是程序的基本执行实体

**线程**是操作系统进行运算调度的最小单位，包含在进程之中，是进程中的实际运作单位。互相独立，同时运行。

因为每次程序的运行都需要时间，线程的意义就在于CPU在程序运行的“等待”时间去其他程序做事情，提高运行效率。

**并发**是在同一时刻，多个指令在单个cpu交替执行。

**并行**是在同一时刻，多个指令在多个cpu同时执行。

## 实现方式

1，继承Thread类

```java
package cn.nullcat;

public class MyThread extends Thread {

    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName()+" myThread: " + i);
        }
    }
}
```

```java
package cn.nullcat;

public class thread1 {
    public static void main(String[] args) {
        /**
         * 多线程的启动方式1
         * 1，写一个类继承thread
         * 2，重写run方法
         * 3.创建对象，启动线程
         */
        MyThread myThread1 = new MyThread();
        myThread1.start();
        myThread1.setName("myThread1");
        MyThread myThread2 = new MyThread();
        myThread2.start();
        myThread2.setName("myThread2");
    }
}
```

2，实现Runnable接口

```java
package cn.nullcat.thread2;

public class MyThread2 implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 15; i++) {
            Thread t = Thread.currentThread();
            //用来获取“当前执行这段代码的线程对象”的方法
            System.out.println(t.getName()+"   "+i);
            //或者链式编程
            System.out.println(Thread.currentThread().getName()+"   "+i);
        }
    }
}
```

```java
package cn.nullcat.thread2;

import cn.nullcat.MyThread;

public class thread {
    public static void main(String[] args) {
        /**
         * 1.创建对象实现Runnable接口
         * 2.重写run方法
         * 3.创建自己的对象
         * 4.创建thread对象，开启线程
         */
        MyThread2 mr = new MyThread2();
        MyThread2 mr2 = new MyThread2();
        Thread thread1 = new Thread(mr);//OOP的对象行为传递，
        // mr 是包含线程执行逻辑的对象，逻辑传给了thread1，它自动调用mr.run()
        thread1.setName("thread1");
        Thread thread2 = new Thread(mr2);
        thread2.setName("thread2");
        thread1.start();
        thread2.start();
    }
}
```

3，利用Callable接口和Future接口

```java
package cn.nullcat.thread3;

import java.util.concurrent.Callable;

public class MyCallable implements Callable<Integer> {
    @Override
    public Integer call() throws Exception {
        int sum = 0;
        for (int i = 0; i < 10; i++) {
            sum += i;
        }
        return sum;
    }
}

```

```java
package cn.nullcat.thread3;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class thread {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        /**
         * 第三种线程创建方式：
         * 1.创建类MyCallable实现Callable接口
         * 2.重写call （有返回值）
         *
         * 3.创建MyCallable对象  (表示任务)
         * 4.创建FutureTask对象 （管理运行结果）
         * 5.创建Thread类对象，启动
         */
        MyCallable mc = new MyCallable();
        FutureTask<Integer> futureTask = new FutureTask<>(mc);
        //FutureTask是Runnable的实现类,可以传给Thread
        Thread t1 = new Thread(futureTask);
        t1.start();

        System.out.println(futureTask.get());
    }
}
//输出55
```

三种方法的对比：

前两种不能获取运行结果，而第三种可以

第一种扩展性差，因为单继承。

## 常见的成员方法

 ```java
 package cn.nullcat.method;
 
 public class thread {
     public static void main(String[] args) throws InterruptedException {
         /**
          * 常用方法
          */
         MyThread mt1 = new MyThread("坦克");
         MyThread mt2 = new MyThread("飞机");
         //mt1.setName("名字");
         //设置名字，默认Thread-0，源码就是“Thread-”+自增变量（ThreadInitNumber）
         //或者Alt+insert添加父类的构造方法，然后直接命名：MyThread mt2 = new MyThread("飞机")
         mt1.start();
         mt2.start();
 
         //currentTread可以获取当前线程的对象，当没有线程的时候是main
         //解释：当JVM启动后，自动启动多条线程，其中有一条线程就叫做main，这个线程的作用就算调用main，并且执行里面的代码
         Thread t = Thread.currentThread();
         System.out.println(t.getName());
 
 
         //sleep，让线程休眠指定时间，毫秒，结束后线程自动醒来
         //也可以在run方法写，但是要try处理异常
         System.out.println("------------");
         Thread.sleep(5000);
         System.out.println(".............");
     }
 }
 ```

Java是抢占式调度，各个线程抢夺cpu执行权，强调“随机”，优先级越高，抢到的概率越大，范围1-10，默认5

```java
package cn.nullcat.method2;

public class thread {
    public static void main(String[] args) throws InterruptedException {
        /**
         * 设置优先级
         */
        MyThread mt1 = new MyThread("坦克");
        MyThread mt2 = new MyThread("飞机");

        mt1.setPriority(1);
        mt2.setPriority(10);

        mt1.start();
        mt2.start();
    }
}

```

守护线程会在被守护的线程结束的时候很快结束

```java
package cn.nullcat.method2;

public class thread {
    public static void main(String[] args) throws InterruptedException {

        /**
         * 守护线程
         */
        MyThread t1 = new MyThread("主线程");
        MyThread2 t2 = new MyThread2("备胎");

        t2.setDaemon(true);

        t1.start();
        t2.start();
    }
}


```

jion方法能让线程插入到main线程之前（一般情况下是先运行main线程）

```java
package cn.nullcat.method2;

public class thread {
    public static void main(String[] args) throws InterruptedException {
        /**
         * jion方法
         */
        Thread t1 = new MyThread("土豆");
        t1.start();

        t1.join();

        for (int i = 0; i < 10; i++) {
            System.out.println("main"+i);
        }
    }
}

```



//另外还有出让/礼让线程的方法
//在run方法yield出让执行权，那么会在执行完一步后让出
//能让多线程的执行尽可能均匀  

















































