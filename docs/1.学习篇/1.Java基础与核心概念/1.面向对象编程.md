---
title: 1.面向对象编程
---

# 目录





## OOP基础

>讲个笑话：
>
>如果你没有对象可以来学习Java，因为Java是面向对象编程语言，没有对象你可以new一个出来

#### 什么是面向对象编程（OOP）

面向对象编程（Object-Oriented Programming，简称 OOP）是一种以**对象为基础**，通过**封装、继承和多态**来组织软件系统的编程范式，旨在提高程序的**可重用性、可扩展性和可维护性**。

是的，我们常说的面向对象编程的本质是一种**编程范式**,编程范式其实就是写程序的方法论，用来指导我们**“怎么思考问题”和“怎么组织代码”**的一种思维模式或风格。

>**编程范式**是程序设计中一套**基本的风格、方法和理论基础**，用于指导如何组织、构建和表达程序逻辑。它规定了程序的**结构方式、控制流程**以及**状态管理方式**，并体现出特定的**抽象机制**和**计算模型**。

那么什么是对象？

在OOP中，“对象”是**类的实例**，包含属性和行为。通俗讲：**对象 = 数据 + 操作这些数据的方法**。

那什么是类？

类（Class）**是**对象的模板或蓝图。

从代码上理解：

```Java
//这是类，它不实际占用内存
class Person {
    String name;         // 属性
    int age;

    void speak() {       // 方法
        System.out.println("Hello");
    }
}
```

```java
//这是对象，变量 p 就是对象
Person p = new Person();  // 创建对象
p.name = "Alice";         // 设置属性
p.speak();                // 调用方法
```

所以就能体现“对象是类的实例”，类是模板，对象是示例。

~~很好，你已经掌握了面向对象编程，把“精通面向对象编程”写到你的简历上吧~~

那么我们为什么要用面向对象编程？为什么要使用这种范式？我的代码我做主，我凭什么要使用这种风格？

#### 为什么有面向对象？它怎么来的？

其实一开始，大家写程序都是，第一步...第二步.....第三步.....OK写完啦下班~

这是**命令式编程**。写起来简单，但程序越大，越**乱成一锅粥**，逻辑全堆在一起，改一点东西容易全崩。

后面有人想，代码能不能也像现实一样，比如“人”，把“人”当成一个整体，给它属性（名字、年龄）和行为（走路、说话）？

于是，**面向对象**就诞生了。

以前写程序像这样

>“先切菜，再开火，再炒，再加盐，再盛盘……”

现在写程序像这样

>“叫厨师对象干活，他自己会切、炒、加盐。”

这样更接近人类思维，更容易维护和扩展，而且代码可以复用

就像.....

>我现在给厨师对象加一个“写Java代码”方法，不影响他做饭等一系列，而且我可以new一个厨师帮我写代码，桀桀桀.....

#### 你可能也听说过面向过程编程（PP）？那它又是什么？

其实我们刚刚提到的命令式编程和面向过程编程是一样的，但是命令式编程>面向对象编程

**命令式编程**就是通过**命令/步骤**让计算机做事的一种编程风格，但是面向过程编程特别强调**过程/函数**的组织。

```text
你可以这样想：  面向过程是编年体;面向对象是纪传体
```

>但是这两者并不是你死我活，现代语言（如 Java、Kotlin、Scala）都在**融合这两种范式**，这也反映出：**编程思想的演化从不是你死我活，而是彼此借鉴、共同发展**。

所以面向对象编程把软件世界映射为对象世界 —— 像现实中一样思考问题，而不是像计算机那样思考。

面向对象的本质，不是类和对象这些术语，而是背后的哲学：**如何像现实世界那样组织程序，让软件“长得像”问题本身。**让系统更加**模块化、可读、可扩展**。

#### 那么，我们开始学习面向对象编程吧！

“封装、继承、多态”是面向对象的**机制性三大特征**，而“抽象”是它们背后的**思想基础**，在系统设计中地位非常高，有时也被视为“第四大特征”。

#### 1.封装

将**数据（属性）和行为（方法）**绑定在一起，并隐藏内部实现细节，对外暴露清晰接口。

- 只暴露业务必需的接口
- 利用访问控制（private/protected/public）
- 加上不可变性（final、只读接口）进一步封装行为

```text
傻瓜式理解：
封装后你的对象变成了一个控制台，你只能通过“按钮”控制，通过“仪表盘”看到数据。
所以就保证了安全性，我不想让你看见，我不设计这个仪表盘（接口）就行了，不想让你操控这个数据，不设计按钮或者不给你这个按钮的权限就行了。
```

```java
public class Student {
    private int id;//id属性私有化
    private String name;//name属性私有化

    //获取id的方法
    public int getId() {
        return id;
    }

    //设置id的方法
    public void setId(int id) {
        this.id = id;//this关键字用来区分局部变量和成员变量
    }

    //获取name的方法
    public String getName() {
        return name;
    }

    //设置name的方法
    public void setName(String name) {
        this.name = name;
    }
}
```

#### 2.继承

子类可以继承父类的**属性和方法**，从而**复用**已有的代码。

- 子类自动继承父类功能，可以在此基础上扩展或重写。
- 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**
- 子类可以拥有自己属性和方法，即子类可以对父类进行扩展

```java
// 定义一个父类 Person，用于表示人
public class Person {
    // 私有属性：姓名和年龄
    private String name;
    private int age;

    // 公共方法：设置姓名
    public void setName(String name) {
        this.name = name;
    }

    // 公共方法：获取姓名
    public String getName() {
        return name;
    }

    // 公共方法：设置年龄
    public void setAge(int age) {
        this.age = age;
    }

    // 公共方法：获取年龄
    public int getAge() {
        return age;
    }

    // 一种通用行为：自我介绍
    public void introduce() {
        System.out.println("My name is " + name + ", I am " + age + " years old.");
    }
}
```

```java
// Student 类继承自 Person 类，拥有 Person 的所有属性和方法
public class Student extends Person {
    // Student 独有的属性：学号
    private int studentId;

    // 设置学号
    public void setStudentId(int studentId) {
        this.studentId = studentId;
    }

    // 获取学号
    public int getStudentId() {
        return studentId;
    }

    // 重写父类的 introduce 方法，实现学生特有的自我介绍(多态)
    @Override
    public void introduce() {
        System.out.println("I am a student. My name is " + getName() +
                ", I am " + getAge() + " years old, and my student ID is " + studentId + ".");
    }
}
```

>但是**滥用继承**会带来一些问题：
>
>- 子类耦合父类实现，继承层级深容易造成**脆弱设计**
>- 推荐优先考虑**组合（has-a）**代替继承（is-a）
>
>这些将在后续的OOP高级特性详细介绍

#### 3.多态

通过父类引用来调用子类的方法，**同一个方法在不同对象上有不同的表现**。

- 传入 `Shape`，可能是 Circle，也可能是 Square，但都能调用 `.draw()`
- JVM 会在运行时动态绑定具体方法（动态分派）

- **扩展性极强**：新增类不必改旧代码
- **解耦调用者与实现**，是面向接口编程的根本

这个是很简单的，你看一下代码就瞬间明白了：

首先是方法重写：

```java
class Animal {
    void sound() {
        System.out.println("动物发出声音！");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("狗叫！");
    }
}

class Cat extends Animal {
    void sound() {
        System.out.println("猫叫！");
    }
}
```

```
Animal animal1 = new Dog();  // 动物类型，实际是狗
Animal animal2 = new Cat();  // 动物类型，实际是猫

animal1.sound();  // 狗叫
animal2.sound();  // 猫叫
//输出：
//狗叫！
//猫叫！
```

然后是方法重载:

```java
class Dog {
    // 方法重载
    void bark() {
        System.out.println("狗叫！");
    }
    
    void bark(int times) {
        System.out.println("狗叫 " + times + " 次！");
    }
    
    void bark(String sound) {
        System.out.println("狗发出 " + sound + " 的声音！");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog();
        
        dog.bark();  // 调用无参数的方法
        dog.bark(3); // 调用带一个参数的方法
        dog.bark("汪汪"); // 调用带字符串参数的方法
    }
}
```

>那么重写和重载有什么区别：~~这好像是面试篇的内容吧~~
>
>重写：发生在**父类和子类之间**，子类重写父类的方法，方法名、参数都要相同。运行时决定调用哪个版本的函数。也就是运行时多态。
>
>重载：发生在**同一个类**中，方法名相同，但参数不同。编译时决定调用哪个版本的函数。也就是编译时多态。

#### 4.抽象

“抽象”是“封装、继承、多态”背后的**思想基础**，它**更像一种“设计哲学”或能力**，而非单纯语法特性。

抽象是：

- 面向对象“思维方式”的开端（先有抽象，才谈得上封装、继承等）
- 贯穿于类设计、建模、接口提取等各方面
- 和接口、抽象类、泛型等紧密相关

抽象的两种形式：

- **抽象类**：包含部分实现，可被继承

抽象类是不能直接实例化的类，通常包含抽象方法（没有方法体的方法），需要由子类来实现这些方法。

- **接口（interface）**：只定义行为约定，由类去实现

接口是一个完全抽象的类，用来声明一组方法，类通过实现接口来提供这些方法的具体实现。接口通常用于**定义行为**。

```
简单理解(还是你和你爸的例子)：
我们有一个父类（抽象类），它定义了吃饭是一个抽象方法，下蛋则是一个已实现的方法。子类继承父类后，重写吃饭方法。

我们有一个接口EatingAndLaying，它声明了eat()和layEgg()方法。然后，我们的类（Father和Child）都实现了这个接口，并分别提供自己吃饭的方法。
```

```java
// 抽象类，爸爸类
abstract class Father {
    // 已经实现的下蛋方法
    void layEgg() {
        System.out.println("爸爸下蛋！");
    }

    // 抽象的吃饭方法，需要子类重写
    abstract void eat();
}

// 子类继承爸爸类
class Child extends Father {
    // 子类重写爸爸类的吃饭方法
    @Override
    void eat() {
        System.out.println("我用嘴巴吃饭！");
    }
}

public class Main {
    public static void main(String[] args) {
        Father father = new Child();  // 爸爸变成了抽象类，通过子类来实现
        father.layEgg();  // 爸爸下蛋的方法
        father.eat();     // 子类重写的吃饭方法：我用嘴巴吃饭！
    }
}
```

```java
// 接口，定义了吃饭和下蛋的方法
interface EatingAndLaying {
    void eat();   // 吃饭方法
    void layEgg(); // 下蛋方法
}

// 爸爸实现接口
class Father implements EatingAndLaying {
    @Override
    public void eat() {
        System.out.println("爸爸用鼻子吃饭！");
    }

    @Override
    public void layEgg() {
        System.out.println("爸爸下蛋！");
    }
}

// 子类实现接口
class Child implements EatingAndLaying {
    @Override
    public void eat() {
        System.out.println("我用嘴巴吃饭！");
    }

    @Override
    public void layEgg() {
        System.out.println("我下蛋！");
    }
}

public class Main {
    public static void main(String[] args) {
        EatingAndLaying father = new Father();  // 爸爸实现接口
        EatingAndLaying child = new Child();    // 子类实现接口

        father.eat();   // 爸爸用鼻子吃饭
        father.layEgg();  // 爸爸下蛋

        child.eat();    // 我用嘴巴吃饭
        child.layEgg();  // 我下蛋
    }
}
```

>那么抽象类和接口有什么区别： ~~面试篇：你没完了是吧~~
>
>1.**继承关系**：抽象类用 `extends`，只能继承一个；接口用 `implements`，可以实现多个。
>
>2.**方法**：抽象类可以有抽象方法，也可以有已实现的方法；接口的方法默认是抽象的，但从 Java 8 开始可以有 `default` 和 `static` 方法。
>
>3.**变量**：抽象类可以有普通成员变量；接口只能有 `public static final` 常量。
>
>4.**构造器**：抽象类可以有构造方法；接口不能有构造方法。
>
>5.**使用目的**：抽象类用于表达“是什么”（类的模板）；接口用于定义“能做什么”（行为能力）。

这个时候你可以思考一下，当被问到“面向对象编程的三大特性是什么”的时候，你应该怎么精简准确地回答。

#### 下一部分，我们刚才提到类是对象的模板或蓝图，那么类和对象是什么关系？对象new出来在哪？

在面向对象编程中，类是对象的模板，而对象是类的实例。每个类的基本构成元素包括**属性**、**方法**和**构造器**

属性就是描述对象的状态信息，也就是对象的数据成员。

```java
public class Person {
    private String name;  // 属性：姓名
    private int age;      // 属性：年龄
}
```

类的方法定义了对象的行为或操作。方法是类的功能实现，通过输入参数并返回结果来完成某个功能。

```java
public class Person {
    private String name;
    private int age;

    public void introduce() {  // 方法：自我介绍
        System.out.println("Hi, I'm " + name + " and I'm " + age + " years old.");
    }
}
```

构造器是类的一种特殊方法，用于在创建对象时初始化对象的状态。构造器的名称与类名相同，且没有返回类型。

```
public class Person {
    private String name;
    private int age;

    // 无参构造器
    public Person() {
        this.name = "Unknown";
        this.age = 0;
    }

    // 带部分参数的构造器
    public Person(String name) {
        this.name = name;
        this.age = 0;
    }

    // 全参构造器
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    // 拷贝构造器
    public Person(Person other) {
        this.name = other.name;
        this.age = other.age;
    }
}
```

那么我们new一个对象的时候，到底发生了什么，你的对象在哪？

这个时候你要明白有一个东西叫Java的内存模型：[这个视频可以帮助你理解java的内存](https://www.bilibili.com/video/BV1dR4y1o7ER?spm_id_from=333.788.player.switch&vd_source=69dcf0781549d7aefb6c910dc44c7678&p=7)

在 Java 中，对象的内存分配主要分为堆（Heap）和栈（Stack）两个区域

**堆内存（Heap）**：

堆用于存储对象的实例。当我们通过 `new` 关键字创建一个对象时，JVM 会在堆内存中为其分配空间。堆内存中的对象由垃圾回收器（GC）管理，自动进行内存回收。

**栈内存（Stack）**

栈用于存储方法调用和局部变量。每次方法调用时，JVM 会为该方法分配一个栈帧，用于存储方法的局部变量和参数。当方法执行完毕时，栈帧会被销毁，局部变量也会随之消失。

[Java每日一题：对象的生命周期？](https://www.bilibili.com/video/BV1nsC6YcE19/?spm_id_from=333.337.search-card.all.click&vd_source=69dcf0781549d7aefb6c910dc44c7678)

看懂这些你就能知道你的对象在哪，它怎么诞生，以及........怎么消失 

~~别伤心你的对象没了可以再new~~

另外我们还需要介绍一下什么是静态成员，什么是实例成员

- **实例成员**：像每个学生自己随身带的小本子，记录了自己的名字、爱好。
- **静态成员**：像教室黑板，写的是全班共享的信息，所有学生（对象）都能看到，也都能改。

静态成员属于类本身，而不是类的实例。所有类的实例共享同一份静态成员。静态成员通过类名直接访问，也可以通过对象来访问，但不推荐这么做。

```java
public class MathUtil {
    public static final double PI = 3.14159;  // 静态常量
    public static int add(int a, int b) {     // 静态方法
        return a + b;
    }
}

public class Test {
    public static void main(String[] args) {
        System.out.println(MathUtil.PI);    // 通过类名访问静态常量
        System.out.println(MathUtil.add(5, 10)); // 通过类名调用静态方法
    }
}
```

实例成员属于每个对象的实例，每个对象有独立的实例成员。实例成员必须通过对象引用来访问

```java
public class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void introduce() {  // 实例方法
        System.out.println("Hi, I'm " + name + " and I'm " + age + " years old.");
    }
}

public class Test {
    public static void main(String[] args) {
        Person p = new Person("Alice", 30);  // 通过对象引用访问实例成员
        p.introduce();
    }
}
```

#### 对象间交互模式

>就是一个对象怎么和别的对象沟通、配合、合作完成事

- 你不可能永远一个类干完所有事

- 会设计“对象之间怎么配合”，你才能写出**灵活、扩展性强**的程序

1.直接引用：关联

**一个对象中有另一个对象的引用字段**

```java
public class Teacher {
    private Student student; // Teacher 持有 Student 的引用
}
```

2.弱整体关系：聚合

**一个对象聚合了一组其他对象，但彼此生命周期是独立的**

```java
public class ClassRoom {
    private List<Student> students; // 聚合多个学生
}
```

3.强绑定关系：组合

**成员对象“完全归属”父对象，跟随它的生命周期**

```java
public class Computer {
    private final CPU cpu = new CPU(); // 组合：电脑有且完全管理CPU
}
```

4.临时掉用关系：依赖

**对象只是在方法中临时使用另一个对象**

常见于业务层方法，像 Controller、Service 之间的调用

```java
public class OrderService {
    public void printOrder(Order order) {
        System.out.println(order.getId());
    }
}
```

在掌握了 OOP 的四大基本特性等后，你已经具备了构建对象、组织代码的基本能力。但真正的软件开发远不止“写对代码”，而是要写出**可维护、可扩展、低耦合、高内聚**的系统。

>**高内聚与低耦合**后面还会详细介绍

接下来我们从“语法层面”走向“设计层面”：

理解 **接口与抽象的设计取舍**，掌握 **组合优于继承** 的思想，学会用 **多态构建可扩展体系**，并进一步接触 **面向对象设计原则（如 SOLID）与常见设计模式**。这些就是**高级 OOP 的核心内容**。~~叽里咕噜说什么呢，听不懂思密达~~

只有合理应用OOP高级特性，才能写出真正~~清晰、灵活、可维护、可扩展、可复用、低耦合、高内聚、易测试、易理解、易迭代、稳健、健壮、具有良好架构~~牛逼的代码。

#### 接口 vs 抽象类的设计选择

我们知道抽象有两种形式，接口和抽象类，那么我们如何选择呢？

接口的特点：

- 不能存状态（不能有成员变量，除了常量）
- 方法默认是抽象的（也可以用 `default` 加实现）
- 一个类**可以实现多个接口**

抽象类的特点：

- 可以有成员变量（状态）
- 可以有普通方法和抽象方法
- **只能被继承一个**（因为 Java 只允许单继承）

所以说，你想定义“行为规范”，用接口；你想共享代码、状态，用抽象类；你想同时实现多个“能力”，选接口。

>不太严谨地说：“**能接口就接口，不能接口再抽象类**。”

```java
// 接口定义飞行和下蛋能力
interface Flyable {
    void fly(); // 能飞
}

interface EggLaying {
    void layEgg(); // 会下蛋
}

// Bird 类实现这两个接口
class Bird implements Flyable, EggLaying {
    @Override
    public void fly() {
        System.out.println("鸟在飞！");
    }

    @Override
    public void layEgg() {
        System.out.println("鸟下蛋！");
    }
}

public class Main {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.fly();    // 鸟在飞！
        bird.layEgg(); // 鸟下蛋！
    }
}

```

```java
// 抽象类，具备飞行和下蛋的能力
abstract class FlyingEggLayingAnimal {
    // 飞行能力
    abstract void fly();
    
    // 下蛋能力
    abstract void layEgg();
}

// 子类继承抽象类，提供具体实现
class Bird extends FlyingEggLayingAnimal {
    @Override
    void fly() {
        System.out.println("鸟在飞！");
    }

    @Override
    void layEgg() {
        System.out.println("鸟下蛋！");
    }
}

public class Main {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.fly();   // 鸟飞
        bird.layEgg(); // 鸟下蛋
    }
}
```

这两个代码示例通过**接口**和**抽象类**来实现相似的功能

如果选择接口：

**优点**：

- 可以实现多个能力
- 灵活性:一个类可以实现多个接口，这样就可以为类添加不同的行为。

>比如，`Bird` 类不仅可以是会飞的 (`Flyable`)，还可以是会下蛋的 (`EggLaying`)。如果有其他类也需要这两个能力，它们也可以实现这两个接口（比如 `Plane` 类实现 `Flyable`，但不会实现 `EggLaying`）。

**缺点**：

- 没有方法实现:接口只能声明方法，不能有方法的具体实现。所有的方法都必须在类中自己实现。
- **没有共享状态**，如果你希望共享一些状态（比如所有鸟类的飞行速度），接口就无法提供这种功能。

如果选择抽象类：

**优点：**

- **可以共享代码**。比如，抽象类可以包含已经实现的方法，子类可以继承这些方法而不用重新编写。
- **可以包含状态**，抽象类可以有成员变量，保存一些共享状态。比如，所有会飞的动物都可能有一个飞行速度，抽象类可以定义这个变量，所有子类共享。

**缺点：**

- **只能继承一个**，你只能继承一个抽象类。如果你要设计一个类可以具备多种不同的能力（比如鸟能飞且能下蛋），你就不能继承多个抽象类，只能通过组合多个接口来实现。

>**总结来说**，
>
>接口与抽象类的选择，就是**“灵活性”** 与 **“复用性”** 的权衡。
>
>“抽象类给你一套**骨架**，接口给你一堆**零件**。”~~我真是个天才~~

#### 这里扩展一个多重继承问题与解决方案

如果两个接口提供了同名的默认实现，会冲突

```java
interface A {
    default void sayHello() {
        System.out.println("Hello from A");
    }
}

interface B {
    default void sayHello() {
        System.out.println("Hello from B");
    }
}

class C implements A, B {
    // 冲突了，必须手动解决
}
```

编译器会报错说：class C inherits unrelated defaults for sayHello() from types A and B

但是**接口默认方法**（Java 8+）提供了解决办法

```java
class C implements A, B {
    @Override
    public void sayHello() {
        // 指定调用哪个接口的默认方法
        A.super.sayHello(); // 或者 B.super.sayHello();
    }
}
```

>**你有没有这样的疑问：这不是实现接口吗，为什么叫多继承问题，不叫多实现？**
>
>**多继承**本来指的是一个类或对象继承多个父类或接口
>
>**接口**本身不能继承实现类（它没有实现代码），但是它能有 `default` 方法（有实现）。
>
>这种情况下，类 C 实际上继承了两个不同接口中的 `default` 方法，这就变成了多继承的情况。
>
>**那么什么是default？**
>
>以前的接口设计：你实现接口，必须实现接口中的所有方法，这样会导致很多**代码重复**
>
>所以Java 8 引入了 `default` 方法，允许接口直接提供**方法的默认实现**，这样实现接口的类就不必实现这些方法了，**减少了代码冗余**。

#### 组合优于继承（解耦）

我们在前面提到：**滥用继承**会带来一些问题：

- 子类耦合父类实现，继承层级深容易造成**脆弱设计**
- 推荐优先考虑**组合（has-a）**代替继承（is-a）

```tex
说人话：
你继承了你爸，你爸会吃饭，你也会吃饭。
1，你爸改成用鼻子吃了，那你也得跟着鼻子吃饭.....（请勿模仿）
注：也可以通过多态的方法重写解决
2，你继承了你爸的「下蛋」功能.....滥用继承的问题——你拿了一大堆你根本不需要的东西
3，你要是有俩爹，一个教你吃素一个教你吃肉，那你吃什么，不过不用担心，Java只允许单继承
解决方案：组合！
我搞一个新类“饭桶”，它只会吃饭。我在我的类里面创建一个饭桶对象，然后在我的类里面调用饭桶对象的方法，完美解决。如果你听不懂可以看下面的代码：
```

```java
//组合的代码案例
//注意组合和继承不冲突
// 爸爸类，爸爸会叫和用嘴巴吃饭
class Father {
    void call() {
        System.out.println("爸爸叫！");
    }
    void eatWithMouth() {
        System.out.println("爸爸用嘴巴吃饭！");
    }
}

// 饭桶类，饭桶只能用鼻子吃饭
class Eater {
    void eatWithNose() {
        System.out.println("饭桶用鼻子吃饭！");
    }
}
// 我自己的类，继承爸爸并组合饭桶
class Child extends Father {
    Eater eater = new Eater();  // 我请了饭桶，饭桶会用鼻子吃饭

    void eatWithNose() {
        eater.eatWithNose();  // 我用饭桶的鼻子吃饭
    }
}
```

#### 多态的扩展点设计(扩展性)

提前把“变的东西”抽象出来，后面加新功能时，只要加类，不用改类。

>程序里提前留好“钩子”，以后别人只要插上自己的实现，系统就能用新的逻辑。这些“钩子”就是扩展点。
>
>比如支付方式、角色权限、消息通知……那就要想办法用**多态**，提前抽象扩展点。以后加支付宝、加新角色、加邮件通知都不改原来逻辑，**这才叫多态的高级玩法**。

```java
abstract class Animal {
    abstract void speak(); // 留下一个扩展点：speak
}

class Dog extends Animal {
    void speak() {
        System.out.println("汪汪");
    }
}

class Cat extends Animal {
    void speak() {
        System.out.println("喵喵");
    }
}

public class Main {
    public static void makeAnimalSpeak(Animal animal) {
        animal.speak(); // 调用不变，行为可变
    }

    public static void main(String[] args) {
        makeAnimalSpeak(new Dog()); // 汪汪
        makeAnimalSpeak(new Cat()); // 喵喵
    }
}

```

#### SOLID 面向对象设计原则

1. 单一职责原则（SRP）：模块化设计的基础

**定义：** 单一职责原则（Single Responsibility Principle）要求一个类应该仅有一个“**职责**”。换句话说，一个类应该只有一个引起它变化的原因。也就是说，**每个类只应该负责一种功能，过多的责任应该分散到不同的类中**。

**实用意义：**

- **清晰性**：代码更易理解和维护。
- **灵活性**：修改某一部分的功能时，不会影响到其他不相关的部分。

**例子：**

```
class User {
    private String name;
    private String email;

    // 单一职责：用户属性管理
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    public String getEmail() {
        return this.email;
    }
}

class UserPersistence {
    // 违反单一职责：这个类负责了持久化和用户管理两个责任
    public void saveToDatabase(User user) {
        System.out.println("Saving user to DB: " + user.getName());
    }
}
```

改进版（遵守 SRP）：

```
class User {
    private String name;
    private String email;
    // 只管理自己的属性
}

class UserPersistence {
    // 只负责持久化，不管理用户属性
    public void saveToDatabase(User user) {
        System.out.println("Saving user to DB: " + user.getName());
    }
}
```

------

2. 开放-封闭原则（OCP）：扩展与修改的平衡

**定义：** 开放-封闭原则（Open/Closed Principle）要求软件实体（类、模块、函数等）应当对**扩展**开放，对**修改**封闭。也就是说，应该允许在不修改现有代码的情况下进行扩展功能的添加。

**实用意义：**

- **避免修改现有代码**：当需求变化时，我们能通过**扩展**而不是修改来解决问题，这样可以保持已有功能的稳定性。
- **增强灵活性**：通过继承、接口、抽象类等方式实现扩展。

**例子：**



```
// 不遵守 OCP 的代码
class Rectangle {
    private int width;
    private int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    public int calculateArea() {
        return width * height;
    }
}

class AreaCalculator {
    // 修改代码实现更多图形时，需要修改现有代码
    public int calculateRectangleArea(Rectangle rectangle) {
        return rectangle.calculateArea();
    }
}
```

改进版（遵守 OCP）：

```
interface Shape {
    int calculateArea();
}

class Rectangle implements Shape {
    private int width;
    private int height;

    public void setWidth(int width) {
        this.width = width;
    }

    public void setHeight(int height) {
        this.height = height;
    }

    @Override
    public int calculateArea() {
        return width * height;
    }
}

class Circle implements Shape {
    private int radius;

    public void setRadius(int radius) {
        this.radius = radius;
    }

    @Override
    public int calculateArea() {
        return (int) (Math.PI * radius * radius);
    }
}

class AreaCalculator {
    // 新增图形时，不需要修改现有代码
    public int calculateArea(Shape shape) {
        return shape.calculateArea();
    }
}
```

------

3. 里氏替换原则（LSP）：继承关系的约束条件

**定义：** 里氏替换原则（Liskov Substitution Principle）要求子类可以替代父类出现在任何地方，并且程序的行为不会因此改变。也就是说，**子类对象能够完全替代父类对象**。

**实用意义：**

- **继承不应破坏父类行为**：子类不仅继承父类的功能，还应保证父类功能的正确性。

**例子：**



```
class Bird {
    public void fly() {
        System.out.println("Flying...");
    }
}

class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Ostriches can't fly");
    }
}
```

这种做法违反了 LSP，因为 `Ostrich` 是 `Bird` 的子类，却无法替代父类的行为。**正确做法**是通过设计的方式，让不支持的行为不出现在继承层次中。

------

### 4. 接口隔离原则（ISP）：接口粒度的控制

**定义：** 接口隔离原则（Interface Segregation Principle）要求一个类不应依赖于它不需要的接口。接口应该小而专注，不应将不相关的方法强制加入一个接口。

**实用意义：**

- **减少耦合**：避免因接口过大导致的类与类之间的过度依赖。
- **提高可维护性**：小接口更容易理解和修改。

**例子：**



```
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Worker implements Workable, Eatable {
    @Override
    public void work() {
        System.out.println("Working...");
    }

    @Override
    public void eat() {
        System.out.println("Eating...");
    }
}

class Robot implements Workable {
    @Override
    public void work() {
        System.out.println("Robot working...");
    }
}
```

------

### 5. 依赖倒置原则（DIP）：高层模块的解耦策略

**定义：** 依赖倒置原则（Dependency Inversion Principle）要求高层模块不应该依赖低层模块，二者都应该依赖于抽象；而抽象不应该依赖细节，细节应该依赖抽象。

**实用意义：**

- **解耦**：高层模块和低层模块通过抽象来通信，避免直接依赖具体实现。
- **增强灵活性**：使得系统更加易于扩展和维护。

**例子：**



```
// 违反 DIP
class LightBulb {
    public void turnOn() {
        System.out.println("Light on");
    }

    public void turnOff() {
        System.out.println("Light off");
    }
}

class Switch {
    private LightBulb bulb;

    public Switch(LightBulb bulb) {
        this.bulb = bulb;
    }

    public void operate() {
        // 直接依赖 LightBulb
        bulb.turnOn();
    }
}
```

改进版（遵守 DIP）：



```
interface Switchable {
    void turnOn();
    void turnOff();
}

class LightBulb implements Switchable {
    @Override
    public void turnOn() {
        System.out.println("Light on");
    }

    @Override
    public void turnOff() {
        System.out.println("Light off");
    }
}

class Switch {
    private Switchable device;

    public Switch(Switchable device) {
        this.device = device;
    }

    public void operate() {
        device.turnOn();
    }
}
```

### **总结**

**SOLID** 原则帮助我们设计出具有高可维护性、可扩展性和灵活性的代码。它的重点是：

1. **模块化设计**：将复杂的系统拆解成易于理解和修改的模块。
2. **可扩展性**：通过接口、抽象类等方式让系统能灵活扩展，避免修改现有代码。
3. **减少耦合**：通过依赖抽象而非具体实现，降低模块之间的依赖关系。

**简单记忆：**

- **S**：让类只做一件事。
- **O**：让类容易扩展，但不改变已有代码。
- **L**：子类可以替换父类。
- **I**：接口要细化，避免不必要的依赖。
- **D**：依赖于抽象，不依赖于具体实现。

#### 常用设计模式（如策略、工厂、观察者等）

设计模式是对**面向对象编程（OOP）原则的高级应用**，用于**解决软件设计中常见的问题**，强调复用、扩展和解耦。我会专门写一篇文章。

```te
封装 → 强调“隐藏细节、保护数据”

继承 → 强调“代码复用、建立层级”

多态 → 强调“行为可变、便于扩展”

接口 vs 抽象类的设计选择  → “灵活性”** 与 **“复用性” 的权衡

组合优于继承  →  强调“解耦”

多态的扩展点设计   →    强调扩展性

SOLID 面向对象设计原则  →   强调 “高内聚、低耦合” 的系统设计思想
```



**设计模式**、**依赖注入**、**控制反转**、**SOLID 原则** 和 **领域驱动设计**









