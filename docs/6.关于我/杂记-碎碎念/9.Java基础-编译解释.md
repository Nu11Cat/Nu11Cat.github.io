---
title: 9.Java基础-编译解释
---

##  Java 语言“编译与解释并存”

但是本质上偏向“编译型语言”，但结合了解释型的优点

Java 是“先编译、后解释、再优化”的混合模式，编译型为主，解释型为辅

先编译为字节码（跨平台），然后解释执行（动态适应），并通过 JIT 实现性能优化。

补充：随着 JIT 编译器的发展，热点代码最终还是被编译成机器码执行，**性能越来越接近纯编译型语言**

### 为什么说它偏向编译型？

**必须先编译成字节码**（`.class` 文件），才能运行，跟 C/C++ 类似。

编译阶段有**强类型检查、语法验证、异常处理检查**，都是编译型语言的典型特征。

字节码是“脱离源代码”的可执行格式，可以打包、部署、传输。

### 为什么又说它**也有解释特性**？

字节码不是机器码，**JVM 运行时还要解释它**。

JVM 的解释器按需解释执行字节码。

运行过程中动态链接类、处理反射等行为，也靠解释机制。



## 编译器（Compiler）是把你写的 **Java 源码（.java）转成字节码（.class）** 的程序

**编译**是将 Java 源代码（`.java` 文件）通过 `javac` 编译器转化为字节码（`.class` 文件）的过程，在这个过程中，编译器会进行语法、类型、作用域等的严格检查，确保代码的正确性，并生成与平台无关的字节码。

### 编译过程中检查什么？

**语法检查**：确保代码符合 Java 的语法规则。

**类型检查**：验证变量、方法参数和返回值是否类型匹配。

**作用域检查**：确保变量和方法在正确的作用域内使用。（变量只在其声明的范围内使用，方法只在其所属的类或接口范围内调用）

**异常检查**：检查受检异常是否被正确处理或声明。

**符号解析**：确保类、方法、变量等符号已经正确定义。

### javac是怎么把java代码转化成.class的字节码的？

`javac` 编译器会将 `.java` 源文件经过 **词法分析 → 语法分析 → 语义分析 → 字节码生成** 这几个步骤，最终转化为 `.class` 文件（字节码）。

前三步是为了确保代码合法、结构正确、语义清晰，为最后的 **字节码生成** 做准备。

字节码生成是构建抽象语法树（AST），遍历 AST → 生成指令，写入 `.class` 文件结构

### 泛型为什么要“类型擦除”

**类型擦除**发生在编译阶段，是 Java 编译器为了实现**兼容性**和**性能优化**而采用的一种机制。

具体部分见java基础-机制.md

### Lombok 是怎么做到自动生成代码的？

Lombok 通过实现 **Java 注解处理器**（Annotation Processor）来处理这些注解。在编译过程中，Lombok 的注解处理器会扫描源码中的 Lombok 注解，并在编译阶段生成对应的代码（如 getter、setter、构造方法等）。需要注意的是，Lombok 生成的代码**不会**直接修改你的源代码（`.java` 文件）。

### 多个类互相引用怎么编译？

当多个类互相引用时，编译过程需要处理类之间的依赖关系。Java 的编译器（如 `javac`）和现代 IDE（如 IntelliJ IDEA 或 Eclipse）会使用一种称为 **依赖关系解析** 的机制来确保在编译时所有引用的类都能正确编译。

编译器 **会收集全部类定义、建立符号表、一次性分析、统一生成所有 `.class`**；

### .class除了字节码，还有什么？

`.class` 文件 = **字节码指令 + 支撑字节码执行的结构信息**

**换句话说：**

- `.class` 是一种**“字节码文件格式”**；
- **“字节码”** 专指 `.class` 文件中，**方法体里的指令部分（JVM 指令集）**；
- 但 `.class` 文件还包括：常量池、类名、字段、方法签名、注解、调试信息……这些都不是“字节码”，但都在 `.class` 文件中。

### 编译器优化

**编译器优化**指的是编译器在把源代码编译成字节码（或机器码）时，**对代码进行改写或优化处理**，以提升运行效率、减少资源消耗。`javac` 主要做的是 **基础优化**，**更多高级优化**（如 JIT 优化、逃逸分析等）是交给 JVM 在运行时通过 JIT 编译来处理的。

最常用的编译器优化就是“删掉没用的，提前算掉能算的，重复的只做一次，能展开的就不调用”

比如：

常量传播-多文件依赖编译把能够确定的常量值直接替换到代码中，减少计算

死代码消除-删除无法执行的代码，如不可能进入的 `if` 块等

语法糖转换-将高级语言结构（如 `for-each` 循环）转换为低级语法（普通的 `for` 循环）

简化表达式-比如将 `a * 2` 优化为 `a << 1`，减少不必要的计算



```
`javac` 是 Java 的编译器，将 Java 源代码（.java 文件）编译成字节码（.class 文件）。在 Windows 中是 javac.exe,在 Linux 上，javac 就是一个可执行命令，没有 .exe 后缀，直接在终端使用
```

```
字节码是 Java 源代码（.java 文件）经过编译后生成的中间代码（.class 文件），它是平台无关的，只面向 Java 虚拟机（JVM）。字节码是 Java 特有的，但并不排除其他一些语言也使用字节码作为中间代码。JVM 通过解释执行或 JIT 编译将字节码转换为适合当前平台的机器码来执行。这种机制在一定程度上解决了传统解释型语言执行效率低的问题，同时保留了解释型语言的可移植性。由于字节码不依赖于特定的硬件或操作系统，Java 程序无需重新编译即可在多种不同操作系统的计算机上运行。

为什么说“JVM 通过解释执行或 JIT 编译将字节码转换为适合当前平台的机器码来执行在一定程度上解决了传统解释型语言执行效率低的问题，同时保留了解释型语言的可移植性”？
1，通过 JVM 执行字节码。JVM 可以优化和缓存已执行过的字节码，通过 即时编译（JIT） 将频繁执行的字节码编译成机器码，大大提升执行效率，减少了解释执行带来的性能瓶颈。
2，传统解释型语言（如 Python、Ruby 等）通常依赖于每个平台上的解释器来直接解释执行源代码；而 Java 只需在不同平台上通过 JVM 解释或 JIT 编译统一的字节码，从而实现跨平台运行。因此，Java 保留了类似解释型语言的可移植性这一优点。
```

```
抽象语法树（AST） 是编译器在理解源代码时构建的 树状结构，用来表示程序的语法结构和逻辑关系。
简单理解：把代码结构化成“谁包含谁”“谁调用谁”的层级关系。它不会保留所有细节（如括号、分号），只保留语义上重要的结构。
```



## 解释器（Interpreter）是**Java 虚拟机（JVM）的一部分**，它的作用是将编译后的**字节码（.class）逐行执行**，在程序运行时**动态翻译**字节码为机器码并执行。

**解释执行** 是一种执行程序代码的方式，其中程序在运行时逐行被 **解释器** 逐步读取并执行，而不是事先将其编译成机器码。简单来说，就是 **边读边执行**。

### 为什么相同的字节码在不同平台的解释结果不一样？

**主要是由于 JVM 实现的差异、平台特有的硬件和操作系统差异，以及本地方法的不同实现。** 虽然 Java 提供了平台无关的字节码，但 JVM 作为字节码的执行引擎，需要根据特定平台进行调整。

1,不同平台上有不同的 JVM 实现（如 HotSpot、OpenJ9 等），即使它们遵循相同的字节码规范，它们在实现细节上可能存在差异。

2,JVM 在执行字节码时可能会调用一些 **本地方法（native methods）**，这些方法是用平台特定的语言（如 C 或 C++）编写的，依赖于操作系统和硬件的特性。

3,不同平台的硬件架构（如 x86、ARM）对数据处理的方式、浮点数计算等方面可能有所不同。

4,虽然 Java 标准库定义了大部分常用的 API，但不同平台的 JDK 实现可能对一些底层实现有不同的方式，尤其是在多线程、文件系统、网络等方面。

### 解释器的优化

**JVM优化**：JVM 可能通过缓存已经解释过的字节码，减少重复解释的过程，提升性能。

### 解释和jit编译的关系？

JVM 在程序运行过程中，通常是 **解释执行和 JIT 编译并行工作**。

解释执行是最初的执行方式，当 JVM 启动并加载字节码时，解释器负责将字节码逐行解释并执行。

如果某些代码被频繁执行（即**热点代码**），JVM 会使用 JIT 编译将这些字节码转化为机器码，后续的执行将直接使用机器码，而不再通过解释器。

### JVM是怎么把字节码转化成机器码？

**解释执行**：JVM 在启动时，首先通过解释执行逐行执行字节码（查找对应的机器指令，解释，并执行），直到遇到热点代码。

**JIT 编译**：当发现热点代码时，JVM 使用 JIT 编译将字节码转换为平台特定的机器码，缓存并直接执行该机器码，从而提升性能。

**最终效果**：JVM 通过解释执行保证程序的快速启动，通过 JIT 编译提升执行效率，达到平衡启动速度和性能的效果。

### 解释执行如何在多线程环境中优化执行，避免锁竞争和线程调度的开销？

（JVM 如何优化多线程下的解释执行，尤其是在高并发程序中，如何减少线程切换、锁竞争等带来的性能损失？）

解释执行在多线程环境中优化执行，主要通过**减少锁竞争、减少线程间的同步开销、合理利用 JIT 编译优化热点代码、逃逸分析减少内存开销、使用轻量级锁以及合理的线程池管理等方式**，来避免因为锁竞争和线程调度的开销而影响程序性能。同时，JVM 会根据多线程程序的执行情况进行动态优化，确保多线程程序能在不同的硬件平台上高效运行。

**锁优化**（如锁消除、锁粗化）减少不必要的锁操作，避免锁竞争的开销。

**JIT 编译**提升热点代码的执行效率，减少解释执行带来的性能瓶颈。

**垃圾回收优化**（如并行回收、分代垃圾回收）减少垃圾回收对多线程的影响，避免因 GC 停顿导致的性能损失。

**线程本地缓存** 通过让每个线程独立处理自己的数据，减少线程间的同步需求，降低锁竞争。

**逃逸分析** 在某些情况下避免堆内存分配，减少垃圾回收的压力。

**非阻塞算法和轻量级锁** 通过使用无锁或自旋锁等机制，避免线程因等待锁而被阻塞，提高并发性能。

**线程池管理和并行执行** 合理管理线程的生命周期，并确保多线程能够并行高效地执行。

### JVM 提供了哪些工具（如 `jvisualvm`、`jconsole`）来监控和调试解释执行的过程？

`jvisualvm` 是一个图形化的监控工具，能够实时查看和分析 Java 应用程序的运行情况。

`jconsole` 是一个 Java 提供的命令行监控工具，它可以连接到正在运行的 JVM 实例并提供实时的性能数据

`JFR` 是 Java 提供的低开销监控工具，用于捕获 JVM 的运行数据。它通常在生产环境中用于持续监控 Java 应用程序的性能。

`jstack` 是一个命令行工具，允许你查看正在运行的 Java 应用程序的线程堆栈信息。它可以帮助分析程序中线程的状态，是否有阻塞、等待或者死锁的现象。

`jmap` 是一个用于获取 JVM 内存映像的工具，常用于查看堆内存的详细信息。它可以帮助分析 Java 程序的内存分配情况，诊断内存泄漏问题。

## **JIT 编译**（Just-In-Time 编译）是指在程序运行时，**将频繁执行的字节码转换为本地机器码**，以提高执行性能。

### JIT 编译的工作原理

**字节码加载**：首先，JVM 加载字节码文件（`.class` 文件）。

**解释执行**：JVM 初始阶段会通过解释执行逐行解释字节码，保证程序能够尽快启动。

**热点代码检测**：在解释执行过程中，JVM 会监控哪些方法或代码片段被频繁调用，这些就是所谓的“热点代码”。

**触发 JIT 编译**：当一个方法被调用足够多次，JVM 会认为这个方法是热点代码，就会将其编译成本地机器码。此时，JIT 编译器会根据运行时的情况对代码进行优化。

**机器码执行**：JIT 编译后，生成的机器码会被缓存并直接执行。此时，JVM 会跳过解释执行，而直接执行已编译好的机器码。

**代码优化**：JIT 编译不仅仅是将字节码转换为机器码，它还可以进行一些高级优化，如：

- **内联优化**：JIT 可以将小的、经常被调用的方法直接嵌入到调用它的地方，减少方法调用的开销。
- **常量折叠**：将常量表达式预先计算好，避免运行时计算。
- **循环展开**：通过展开循环体来减少循环次数，从而减少循环控制开销。
- **逃逸分析**：判断一个对象的引用是否会“逃逸”出方法的作用域。如果不会，就可以将其分配到栈上，而非堆上，从而减少垃圾回收的负担。
- **死代码消除**：移除程序中不会执行的代码，减少不必要的计算。

```
JIT 编译的核心是“热点代码”。热点代码是指在程序运行过程中多次被调用的代码片段。JVM 会通过 计数器 来跟踪方法调用的次数，或者通过采样的方式来识别热点代码。
```

### JIT 编译的类型

JIT 编译器有不同的编译策略，常见的包括：

**即时编译**：只有在字节码首次执行时，JIT 编译器才会进行编译（通常是针对方法）。

**增量编译**：JVM 会根据执行过程中不断的统计数据，在不同阶段逐渐编译字节码，而不是一次性编译所有字节码。

### JIT 编译的优势和劣势

**优势**：

- **提高执行效率**：通过热点代码的编译和优化，JIT 可以大大提高程序的执行速度。
- **即时优化**：可以根据运行时的实际数据进行优化，生成针对当前硬件和执行环境的最优机器码。

**劣势**：

- **启动延迟**：由于 JIT 编译是在程序运行时进行的，程序启动阶段可能较慢。
- **内存消耗**：JIT 编译会占用一定的内存用于存储编译后的机器码，可能增加内存负担。
- **编译成本**：编译过程需要时间，尤其是在热点代码较多时，JIT 编译的开销可能会对性能产生影响。

### AOT（Ahead-Of-Time）编译

AOT（Ahead-Of-Time）编译，是与 JIT（Just-In-Time）编译相对的一种编译方式。与 JIT 在程序运行时进行编译不同，AOT 编译是在程序运行之前进行的编译。

AOT 编译与 JIT 编译互为补充，AOT 编译适合于那些对启动速度有较高要求的应用程序，而 JIT 编译则适用于那些需要动态优化和提高长期运行性能的应用程序。在实际应用中，AOT 和 JIT 编译往往是并存的，具体选择取决于程序的需求。

#### AOT 编译的工作流程：

**提前编译**：在程序启动前，AOT 编译器会将 Java 字节码（`.class` 文件）转换为平台相关的机器码。

**生成可执行文件**：AOT 编译可以将应用程序打包成一个独立的可执行文件（通常不依赖于 JVM 的运行时），这使得应用程序可以像传统的编译语言（如 C/C++）一样直接运行。

**不需要 JIT**：AOT 编译的程序不需要依赖 JIT 编译，因为所有代码已经被提前编译为机器码，启动速度更快，避免了 JIT 编译的启动延迟。

#### AOT 与 JIT 的区别：

**编译时间**：

- JIT 编译是在程序运行时进行的，即**动态编译**。
- AOT 编译是在程序运行之前进行的，即**静态编译**。

**启动速度**：

- JIT 编译可以导致程序启动较慢，因为它需要时间来编译字节码。
- AOT 编译可以加快启动速度，因为编译已在运行之前完成。

**内存占用**：

- JIT 编译需要额外的内存来存储编译后的机器码。
- AOT 编译不需要 JIT 编译过程中的内存占用，因为所有代码已提前编译为机器码。

**性能优化**：

- JIT 编译可以根据运行时数据进行优化，从而生成更高效的代码。
- AOT 编译不进行运行时优化，优化只能在编译时进行。

#### AOT 编译的优势和劣势

#### 优势：

1. **启动时间快**：由于代码已经编译成机器码，程序启动时无需等待 JIT 编译，因此可以获得更快的启动速度。
2. **更低的内存使用**：没有 JIT 编译器的参与，减少了内存消耗。
3. **更稳定的性能**：没有 JIT 的实时编译开销，性能比较稳定。

#### 劣势：

1. **缺乏运行时优化**：AOT 编译无法像 JIT 编译那样根据实际运行情况进行优化，因此可能无法生成最优的机器码。
2. **编译时间长**：AOT 编译需要在应用程序发布前进行，可能需要较长的时间，特别是在大型应用程序中。
3. **平台依赖性**：AOT 编译通常会生成平台特定的机器码，因此编译后的代码只能在特定平台上运行。