---
title : 其他&技巧
---

## 位运算

#### 异或⊕

>任何数和 0 做异或运算，结果仍然是原来的数，即 a⊕0=a。
>任何数和其自身做异或运算，结果是 0，即 a⊕a=0。
>异或运算满足交换律和结合律，即 a⊕b⊕a=b⊕a⊕a=b⊕(a⊕a)=b⊕0=b。

第二三点特性：[136. 只出现一次的数字 - 力扣（LeetCode）](https://leetcode.cn/problems/single-number/description/?envType=study-plan-v2&envId=top-100-liked)

```java
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;
    }
}
```

#### 判断2的幂

[231. 2 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-two/description/?envType=study-plan-v2&envId=primers-list)

>1. **`n > 0`**
>    2 的幂必须是正数（0 不是 2 的幂）。
>
>2. **`(n & (n - 1)) == 0`**
>    如果 `n` 是 2 的幂，它的二进制表示中 **只有一个 1**，例如：
>
>   - 1: `0001`
>   - 2: `0010`
>   - 4: `0100`
>   - 8: `1000`
>
>   而 `n - 1` 会把这个唯一的 1 变为 0，并将它右边所有位变为 1，例如：
>
>   - `4` 是 `0100`
>   - `4 - 1 = 3` 是 `0011`
>   - `0100 & 0011 = 0000`
>
>   所以只有当 `n` 是 2 的幂时，`n & (n - 1)` 结果才是 0。
>
>这个位运算技巧可以 **高效判断一个数是否是 2 的幂**，时间复杂度是 `O(1)`。

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        return n > 0 && (n & (n - 1)) == 0;
    }
}
```

## 神奇的想法

#### Boyer-Moore 投票算法（同归于尽法）

如果一个数组有大于一半的数相同，那么任意删去两个不同的数字，新数组还是会有相同的性质。

[169. 多数元素 - 力扣（LeetCode）](https://leetcode.cn/problems/majority-element/description/?envType=study-plan-v2&envId=top-100-liked)

首先选取一个候选众数，再维护一个它的计数器，如果有和它一样的就++，反正--，相当于用它和一个不同的数字同归于尽了，就达到了我们说的效果，那么最后剩下的数字就是我们真正的众数。

```java
class Solution {
    public int majorityElement(int[] nums) {
        int count = 0;
        Integer candidate = null;

        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            count += (num == candidate) ? 1 : -1;
        }

        return candidate;
    }
}
```

## 简单题高级写

#### 3的幂

[326. 3 的幂 - 力扣（LeetCode）](https://leetcode.cn/problems/power-of-three/description/?envType=study-plan-v2&envId=primers-list)

>3 的最大幂次在 int 范围内是 `3^19 = 1162261467`，它是 int 范围内最大的 3 的幂。

```java
class Solution {
    public boolean isPowerOfThree(int n) {
        return n > 0 && 1162261467 % n == 0;
    }
}
```

#### 统计好三元组

[1534. 统计好三元组 - 力扣（LeetCode）](https://leetcode.cn/problems/count-good-triplets/description/?envType=study-plan-v2&envId=primers-list)

```java

```

#### 丑数

[263. 丑数 - 力扣（LeetCode）](https://leetcode.cn/problems/ugly-number/description/?envType=study-plan-v2&envId=primers-list)

```java
class Solution {
    public boolean isUgly(int n) {
        if (n <= 0) return false;
        for (int factor : new int[]{2, 3, 5}) {
            while (n % factor == 0) {
                n /= factor;
            }
        }
        return n == 1;
    }
}
```





















