---
title: 6.JVM 内存模型与垃圾回收
---

# **目录：JVM内存模型与垃圾回收**

## **1：JVM内存模型与垃圾回收**

1. **JVM内存结构**
    • 堆内存（Heap）
    • 栈内存（Stack）
    • 程序计数器（Program Counter）
    • 方法区与元空间（Method Area & Metaspace）
    • 本地方法栈（Native Method Stack）
    • 内存溢出和StackOverflowError
2. **JVM内存管理**
    • 内存分配与回收机制
    • 内存泄漏与内存溢出
    • 内存调优和配置（JVM参数）
    • JVM内存溢出的常见原因及解决方法

------

## **2：垃圾回收（GC）概述**

1. **GC的目标与原理**
    • 什么是垃圾回收
    • GC的主要目标与原则
    • 垃圾回收的工作流程（标记、清除、整理）
2. **垃圾回收算法**
    • 标记-清除算法（Mark-Sweep）
    • 复制算法（Copying）
    • 标记-整理算法（Mark-Compact）
    • 分代收集算法（Generational Collection）
    • G1垃圾回收器（Garbage-First Collector）
    • ZGC与Shenandoah
3. **JVM垃圾回收器**
    • 串行垃圾回收器（Serial GC）
    • 并行垃圾回收器（Parallel GC）
    • 并发标记清除（CMS）垃圾回收器
    • G1垃圾回收器
    • ZGC与Shenandoah垃圾回收器的特点和应用场景
4. **垃圾回收的调优与配置**
    • 如何选择垃圾回收器
    • 垃圾回收器参数配置与优化
    • JVM调优工具（jvisualvm, jconsole等）
    • GC日志分析与优化
5. **垃圾回收与内存泄漏**
    • 如何识别与防止内存泄漏
    • 垃圾回收对性能的影响及优化
    • 对象生命周期与内存管理策略

------

## **3：JVM垃圾回收的性能优化**

1. **JVM内存模型与GC对性能的影响**
2. **提高垃圾回收效率的策略**
    • 减少GC频率和暂停时间
    • 堆内存大小与GC配置
    • 分代收集的优化策略
3. **内存池和堆外内存管理**
    • Direct Memory与Native Memory
    • JVM内存与操作系统之间的关系

------

## **4：JVM调优与监控**

1. **JVM性能监控工具**
    • JVM监控工具概述
    • GC日志分析工具（如GCViewer）
    • jvisualvm与jconsole的使用
2. **JVM调优案例分析**
    • JVM调优的常见问题与解决方案
    • 通过调优提高Java应用的响应速度和吞吐量
    • 高并发环境下的JVM调优技巧

------

# **第一部分：JVM内存模型与垃圾回收**

## 1. **JVM内存结构**

#### • 堆内存（Heap）

JVM堆内存是存储对象的地方，是垃圾回收的主要区域。根据对象的生命周期，堆内存分为多个区域，主要有年轻代、老年代和永久代/元空间。

- **年轻代（Young Generation）**：存放新创建的对象，使用复制算法进行垃圾回收。
- **老年代（Old Generation）**：存放生命周期较长的对象，采用标记-清除或标记-整理算法进行回收。
- **永久代（PermGen）与元空间（Metaspace）**：JDK 1.8之前为永久代，JDK 1.8及以后替换为元空间，存储类元数据和JVM加载的类。

示例代码：没有直接的代码示例，但可以通过JVM启动参数设置堆内存大小，例如：

```
java -Xms512m -Xmx1024m MyApplication
```

#### • 栈内存（Stack）

每个线程在创建时会有自己的栈内存，用于存储局部变量和方法调用栈帧。栈内存中的数据由操作系统自动管理，栈帧的生命周期与方法调用和返回绑定。

- **栈帧（Stack Frame）**：存储局部变量、操作数栈和返回地址。
- **线程栈的独立性**：每个线程有独立的栈内存，线程栈在方法调用时动态分配，在方法返回时自动清除。

示例代码：

```
public class StackMemoryExample {
    public static void main(String[] args) {
        methodA(); // 调用方法
    }
    
    public static void methodA() {
        int a = 10; // 局部变量
        methodB();
    }

    public static void methodB() {
        int b = 20; // 局部变量
    }
}
```

#### • 程序计数器（Program Counter）

程序计数器用于存储每个线程当前正在执行的字节码指令的地址。每个线程有独立的程序计数器，这个计数器在不同的线程之间是互不干扰的。

示例：程序计数器的实现通常由JVM自动管理，无法通过代码直接操作。

#### • 方法区与元空间（Method Area & Metaspace）

- **方法区**：存储类的结构、常量池、字段、方法等信息。JDK 1.7之前称为永久代，JDK 1.8及以后称为元空间，存储类元数据。
- **元空间**：JDK 1.8引入，替代了永久代。元空间存储JVM加载的类和其他元数据。

示例：通过JVM参数设置元空间大小：

```
-XX:MetaspaceSize=128m -XX:MaxMetaspaceSize=256m MyApplication
```

#### • 本地方法栈（Native Method Stack）

本地方法栈支持JVM调用本地方法（如C/C++），它与栈内存类似，每个线程有独立的本地方法栈。它主要用来支持JVM与操作系统之间的接口交互。

#### • 内存溢出和StackOverflowError

- **内存溢出（OutOfMemoryError）**：堆内存不足导致无法分配更多对象。
- **StackOverflowError**：线程的栈深度超出JVM限制时抛出。

示例：

```
public class StackOverflowExample {
    public static void recursiveMethod() {
        recursiveMethod(); // 递归调用，导致StackOverflowError
    }

    public static void main(String[] args) {
        recursiveMethod();
    }
}
```

## 2. **JVM内存管理**

#### • 内存分配与回收机制

JVM的内存分配与回收机制主要通过垃圾回收（GC）来管理堆内存。JVM将堆内存划分为年轻代和老年代，不同的区域使用不同的垃圾回收算法。

- **年轻代回收（Minor GC）**：主要回收年轻代中的对象，采用复制算法。
- **老年代回收（Major GC）**：回收老年代中的对象，使用标记-清除或标记-整理算法。

示例：

```
public class GCDemo {
    public static void main(String[] args) {
        // 创建对象触发垃圾回收
        String str = new String("GC Example");
    }
}
```

#### • 内存泄漏与内存溢出

- **内存泄漏**：由于对象没有被及时回收，导致内存无法释放。
- **内存溢出**：由于堆内存不足，无法分配新的对象。

常见的内存泄漏原因：

- 长生命周期的对象持有对短生命周期对象的引用。
- 被过度使用的缓存没有及时清理。

解决方法：

- 使用工具如`VisualVM`、`JProfiler`进行内存分析。

#### • 内存调优和配置（JVM参数）

通过调优JVM内存参数，可以提高应用的性能，避免内存溢出等问题。

- **`-Xms`**：初始堆大小
- **`-Xmx`**：最大堆大小
- **`-Xss`**：每个线程的栈大小
- **`-XX:NewRatio`**：年轻代与老年代的比例

示例：

```
-Xms512m -Xmx2048m -Xss1m MyApplication
```

#### • JVM内存溢出的常见原因及解决方法

- **常见原因**：
  - **堆内存不足**：应用程序创建了大量对象，堆内存不足。
  - **内存泄漏**：未及时释放不再使用的对象，导致内存持续增长。
  - **StackOverflowError**：线程栈溢出，通常由于递归调用过深。
- **解决方法**：
  - **增加堆内存大小**：通过`-Xms`和`-Xmx`调节。
  - **优化对象创建与销毁**：避免不必要的对象创建，使用对象池等技术复用对象。
  - **使用内存泄漏检测工具**：例如`VisualVM`，进行实时分析与优化。

------

# **第二部分：垃圾回收（GC）概述**

## 2.1 **GC的目标与原理**

#### • **什么是垃圾回收**

垃圾回收（Garbage Collection，GC）是指自动化地回收不再使用的对象占用的内存资源。在Java中，JVM负责管理堆内存，并自动执行垃圾回收。垃圾回收机制解放了开发者手动管理内存的压力，提高了开发效率。

#### • **GC的主要目标与原则**

- **回收无用对象**：GC的主要目标是回收不再使用的对象，即那些没有任何活动引用的对象。
- **内存管理**：GC保证JVM能够及时回收无用的对象，避免内存泄漏或溢出。
- **性能优化**：GC的设计旨在最小化对程序性能的影响，确保垃圾回收不会频繁地占用过多的资源。

#### • **垃圾回收的工作流程（标记、清除、整理）**

1. **标记**：垃圾回收首先通过标记算法识别所有活跃的对象。
2. **清除**：标记完成后，GC会清除没有被标记的对象，释放它们占用的内存。
3. **整理**：为了防止内存碎片，GC会对存活的对象进行整理，将它们集中在内存的一端，提高内存的利用效率。

------

## 2.2 **垃圾回收算法**

#### • **标记-清除算法（Mark-Sweep）**

- **标记阶段**：从根节点开始，递归标记所有可达的对象。
- **清除阶段**：清除所有未被标记的对象。

此算法容易产生内存碎片，因此一般与其他算法配合使用。

#### • **复制算法（Copying）**

- 将内存分为两部分，每次只使用其中一部分。回收时将活跃对象复制到另一部分，回收未使用的部分。
- 优点是没有碎片，缺点是内存使用效率较低。

#### • **标记-整理算法（Mark-Compact）**

- 标记阶段与标记-清除算法相同，区别在于清除阶段不是直接回收未标记的对象，而是将存活对象向一端移动，然后清理空余部分。
- 避免了内存碎片的问题。

#### • **分代收集算法（Generational Collection）**

- 基于对象的生命周期划分堆内存，将内存分为年轻代、老年代和永久代。年轻代采用复制算法，老年代采用标记-清除或标记-整理算法。
- 这种方法有效提高了垃圾回收的效率，因为大部分对象都很快变为垃圾。

#### • **G1垃圾回收器（Garbage-First Collector）**

- G1垃圾回收器是一种低延迟、高吞吐量的垃圾回收器，设计上优先考虑可预测的停顿时间。
- 适用于大内存、高并发的应用场景。

#### • **ZGC与Shenandoah**

- **ZGC**：ZGC是一个低延迟的垃圾回收器，具有可扩展性，支持大规模内存。
- **Shenandoah**：与ZGC类似，也是一个低延迟的垃圾回收器，特别优化了暂停时间。

------

## 2.3 **JVM垃圾回收器**

#### • **串行垃圾回收器（Serial GC）**

- 适用于单核处理器，所有垃圾回收都在单线程中完成，适用于资源有限的场景。
- 优点：实现简单，性能稳定。
- 缺点：对于多核处理器的性能发挥不足。

#### • **并行垃圾回收器（Parallel GC）**

- 通过多线程并行处理垃圾回收任务，提高性能，适合在多核处理器上运行的应用。
- 优点：高吞吐量。
- 缺点：可能导致较长的停顿时间。

#### • **并发标记清除（CMS）垃圾回收器**

- CMS是一个低延迟垃圾回收器，通过并发的方式标记和清除对象，减少停顿时间。
- 优点：适用于需要低延迟的应用。
- 缺点：较高的内存使用量，可能会导致Full GC。

#### • **G1垃圾回收器**

- G1垃圾回收器的目标是最大化应用的吞吐量并尽可能减少GC停顿时间。
- 优点：适合大内存应用，支持可预测的停顿时间。
- 缺点：实现复杂，调优难度较大。

#### • **ZGC与Shenandoah垃圾回收器的特点和应用场景**

- **ZGC**和**Shenandoah**垃圾回收器都是为了提供低延迟的垃圾回收而设计，特别适用于对停顿时间有严格要求的高性能应用场景。

------

## 2.4 **垃圾回收的调优与配置**

#### • **如何选择垃圾回收器**

选择垃圾回收器时，需要根据应用的内存需求、对延迟的敏感度、吞吐量等因素来决定。常见的选择方式：

- **低延迟应用**：可以使用CMS、G1、ZGC或Shenandoah。
- **高吞吐量应用**：可以选择并行垃圾回收器（Parallel GC）。

#### • **垃圾回收器参数配置与优化**

JVM垃圾回收器可以通过多种参数进行配置，以优化回收效率。常见的参数包括：

- `-XX:+UseG1GC`：启用G1垃圾回收器。
- `-Xms`：设置初始堆大小。
- `-Xmx`：设置最大堆大小。

#### • **JVM调优工具（jvisualvm, jconsole等）**

JVM提供了一些工具用于实时监控和调优：

- **jvisualvm**：用于分析JVM的性能、内存使用和垃圾回收。
- **jconsole**：用于监控JVM性能和内存使用。

#### • **GC日志分析与优化**

GC日志记录了垃圾回收的过程，分析这些日志可以帮助开发者找到性能瓶颈并进行优化。通过如下参数启用GC日志：

- `-XX:+PrintGCDetails`
- `-XX:+PrintGCDateStamps`

------

## 2.5 **垃圾回收与内存泄漏**

#### • **如何识别与防止内存泄漏**

内存泄漏是指程序无法及时释放不再使用的对象。常见的内存泄漏现象包括：

- **静态集合类**：长时间持有对不再使用对象的引用。
- **监听器未移除**：事件监听器未正确移除，导致对象无法被回收。

识别内存泄漏可以使用**VisualVM**、**JProfiler**等工具。

#### • **垃圾回收对性能的影响及优化**

GC停顿时间是影响应用性能的关键因素。通过合理选择垃圾回收器、调整内存参数和使用GC日志进行优化，可以最小化GC对应用性能的影响。

#### • **对象生命周期与内存管理策略**

合理管理对象的生命周期可以帮助减少垃圾回收的负担。例如，尽量使用对象池复用对象，避免创建过多短生命周期的对象，从而减少垃圾回收的频率。

# **第三部分：JVM垃圾回收的性能优化**

## 3.1 **JVM内存模型与GC对性能的影响**

- **内存分配策略与分代理念**
  - 内存区域划分：年轻代、老年代、元空间/永久代
  - 分代收集思想：大多数对象短命，年轻代回收较频繁；老年代对象较稳定
  - 对象在各区间的分配与晋升策略：如对象在Survivor区的交换、晋升阈值的设置
- **内存区域大小与调优**
  - 年轻代大小与Minor GC触发频率的关系
  - 老年代空间与Full GC停顿的权衡
  - 堆内存总量对GC频率与GC延时的影响（如-Xms、-Xmx的设置）
- **对象存活率及布局的影响**
  - 不同对象存活率对复制算法与标记整理算法的影响
  - 内存碎片问题：存活对象集中与分散对整理效率的关系
  - 引用关系（强引用、软引用、弱引用、虚引用）对对象回收的影响
- **GC停顿与应用性能**
  - GC过程中应用线程暂停的原因和持续时间
  - 停顿时间对响应时间和吞吐量的直接影响
  - 如何使用监控工具（如jvisualvm、jconsole）评估停顿情况
  - 案例分析：某应用因GC停顿过长导致用户体验下降，调优前后对比

------

## 3.2 **提高垃圾回收效率的策略**

### 3.2.1 **减少GC频率和暂停时间**

- **合理配置堆内存**
  - 动态调整堆内存大小（-Xms与-Xmx的平衡）
  - 针对应用生命周期不同阶段的内存需求作出适配
- **优化年轻代空间与Minor GC**
  - 通过调整-XX:NewRatio、-XX:SurvivorRatio优化年轻代比例
  - 降低Minor GC的触发频率，确保短命对象能快速复制并清除
  - 采用复制算法时避免过度复制与内存复制开销
- **减少无用对象的创建**
  - 对象重用策略（对象池）在高并发场景中降低GC压力
  - 避免频繁创建短生命周期临时对象，如字符串拼接、临时集合等
- **选择低停顿策略的垃圾收集器**
  - 根据应用特点选择CMS、G1、ZGC或Shenandoah等能减少暂停的GC
  - 案例对比：不同GC在低延迟应用下的表现差异

### 3.2.2 **堆内存大小与GC配置**

- **精细化堆内存调优**
  - 设置初始堆与最大堆大小（-Xms, -Xmx），保持内存稳定性
  - 通过参数调整年轻代、老年代和元空间大小，避免内存不足或浪费
- **区域比例和晋升阈值配置**
  - 调整-XX:NewRatio、-XX:SurvivorRatio决定年轻代与老年代的比例
  - 配置对象在新生代的存活阈值（-XX:MaxTenuringThreshold）
  - 利用这些参数平衡Minor GC和Full GC之间的负担
- **GC专用参数优化**
  - 设置目标GC停顿时间参数（-XX:MaxGCPauseMillis）
  - 针对特定收集器（如G1）的调参，如-XX:InitiatingHeapOccupancyPercent
  - 实时通过GC日志反馈调整配置

### 3.2.3 **分代收集的优化策略**

- **年轻代收集优化**
  - 利用复制算法提高Minor GC效率
  - 分析年轻代中对象存活率，以便针对性调整复制效率
  - 优化Survivor空间，提高对象从Eden转移到Survivor的存活概率
- **老年代收集优化**
  - 针对长生命周期对象，采用标记-整理算法减少碎片
  - 调整Full GC触发条件，确保老年代GC不频繁影响性能
  - 案例实践：优化Full GC时如何避免引入大量碎片
- **动态调优机制**
  - 基于GC日志与性能指标，实时进行参数调整
  - 利用JVM监控工具自动化识别内存瓶颈
  - 预案设计：在负载高峰期进行“预热”以降低GC响应

------

## 3.3 **内存池和堆外内存管理**

### 3.3.1 **Direct Memory与Native Memory**

- **Direct Memory（直接内存）**
  - 定义：通过NIO接口分配、绕过堆内存的内存区
  - 优势：减少复制开销，提高I/O性能
  - 配置：-XX:MaxDirectMemorySize参数设置直接内存上限
  - 注意事项：如何防止直接内存过度分配导致Native内存不足
- **Native Memory（堆外内存）**
  - 定义：由操作系统管理，与JVM堆分离的内存区域（包括元空间、直接内存等）
  - 管理策略：监控本地内存使用，防止由于JVM外部内存使用导致系统性能问题
  - 调优建议：结合系统监控工具，评估Native Memory占用与回收情况

### 3.3.2 **JVM内存与操作系统之间的关系**

- **操作系统内存管理与JVM调度**
  - 内存映射文件、交换空间（Swap）的影响
  - 系统调用成本对堆外内存分配的影响
  - 使用容器或虚拟化环境时内存资源隔离问题
- **内存瓶颈定位与协同优化**
  - 评估JVM与操作系统资源分配的协同策略，避免单方面内存争用
  - 利用操作系统级监控工具（如top、vmstat等）与JVM监控工具相结合
  - 案例讨论：实例分析系统内存瓶颈导致应用抖动，如何协同调优

# **第四部分：JVM调优与监控**

## 4.1 **JVM性能监控工具**

#### • **JVM监控工具概述**

- **作用与目标**
   在应用运行期间实时监控JVM内存、线程、垃圾回收等状态，快速定位性能瓶颈。
- **主要监控指标**
  - 堆内存使用情况与各代内存占比
  - GC频率与停顿时间
  - 线程状态、数量与CPU占用率
  - 类加载情况与系统资源利用

#### • **GC日志分析工具（如GCViewer）**

- **开启GC日志**
   使用如下JVM参数记录GC日志：

  ```
  shell
  
  
  复制编辑
  java -Xms1024m -Xmx2048m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log MyApplication
  ```

- **工具介绍**

  - **GCViewer**：将GC日志可视化，直观呈现各次GC的停顿时长、回收量与触发频率
  - **其它工具**：GCEasy、HPJMeter等辅助分析GC行为和性能瓶颈

#### • **jvisualvm与jconsole的使用**

- **jvisualvm**
  - 提供图形化界面，监控内存、CPU、线程、堆转储等信息；
  - 支持插件扩展，可进行更深入的性能分析。
- **jconsole**
  - 轻量级工具，通过JMX连接目标JVM，实时查看内存使用、线程状态和类加载情况；
  - 适合远程监控场景。
- **使用示例**
   启动工具后，选择目标进程，查看实时数据，依据监控结果调整JVM调优参数。

------

## 4.2 **JVM调优案例分析**

#### • **JVM调优的常见问题与解决方案**

- **常见问题**
  - **内存泄漏**：对象长时间未被释放，导致堆内存持续膨胀；
  - **GC停顿过长**：堆内存配置不合理或垃圾收集器选择不当；
  - **频繁Full GC**：由于老年代内存不足或碎片过多引起。
- **解决方案**
  - 利用jvisualvm、VisualGC等工具定位内存泄漏区域；
  - 调整堆内存大小、代际比例，减少Full GC的发生；
  - 优化代码，减少临时对象创建，并考虑使用合适的GC收集器。

#### • **通过调优提高Java应用的响应速度和吞吐量**

- **响应速度提升策略**
  - 减少GC停顿：设置-XX:MaxGCPauseMillis参数；
  - 优化内存分配，快速清除短生命周期对象。
- **提高吞吐量策略**
  - 合理配置Xms/Xmx参数确保充足内存；
  - 选用并行GC或混合GC方案发挥多核优势。
- **案例分析**
   对比调优前后，通过GC日志、响应时间数据展示调整效果，提高响应速度和整体吞吐量。

#### • **高并发环境下的JVM调优技巧**

- **线程与GC调度优化**
  - 配置合适的线程栈大小（-Xss）与GC并行线程数（-XX:ParallelGCThreads）；
- **内存分配与代际调优**
  - 调整-XX:NewRatio、-XX:MaxTenuringThreshold等参数平衡年轻代和老年代负担；
- **实例分享**
  - 结合实际场景展示高并发平台调优案例，总结工具使用、参数选择、调整流程，为同类环境提供借鉴。