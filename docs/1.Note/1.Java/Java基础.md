---
title : Java基础
---

## 包装类型

#### 包装类和基本数据类型的区别

包装类型是`java`为每种基本数据类型提供的对应的类对象类型，让基本类型具备对象的特性。

基本类型是`Java`最原始的数据类型，不是对象，操作效率高，内存占用小，如果是局部变量一般存储在栈内存，但是如果是成员变量就存储在堆`/方法区/元空间(static修饰的静态变量)`。

包装类型是基本类型的类，是对象，可以用于集合，支持泛型，引用可能在栈中，实际存储在堆中，对于一些比如说Integer范围内的常量，`JVM`会缓存，也就是包装类型的缓存机制，存储在常量池或栈。

#### 包装类型的缓存机制

`JVM`会将常见的重复使用的对象进行复用，避免每次都创建新的对象，提高性能，减少内存使用。

比如Integer，`JVM`会缓存`-128到127`的整数。调用`Integer.valueOf(int)`的时候，如果传入的整数在这个范围，`JVM`就返回一个已经创建好的共享对象，而不是在创建一个新的Integer对象。Boolean类型`JVM`只会缓存true和false两个值。

#### 自动装箱与拆箱

**自动装箱**是将基本数据类型转换为其对应的包装类的过程，**拆箱**则是将包装类转换为基本数据类型的过程。这两个过程是由编译器自动完成的。装箱的时候`JVM`调用包装类的构造方法或 `valueOf()` 方法，拆箱时会通过 `xxxValue()` 方法（如 `Integer.intValue()`）获取基本数据类型的值。另外包装类的缓存机制会避免重复创建对象，提升性能。

但是频繁的装箱可能会导致性能问题，因为如果你的基本数据类型的大小超过了缓存机制的界限，那么就会不断产生新的对象，增加垃圾回收的压力。

## 数据类型

#### 基本数据类型

| 类型      | 占用内存 | 默认值   | 范围/说明                               |
| --------- | -------- | -------- | --------------------------------------- |
| `byte`    | 1 字节   | 0        | -128 ~ 127                              |
| `short`   | 2 字节   | 0        | -32,768 ~ 32,767                        |
| `int`     | 4 字节   | 0        | -2³¹ ~ 2³¹-1                            |
| `long`    | 8 字节   | 0L       | -2⁶³ ~ 2⁶³-1                            |
| `float`   | 4 字节   | 0.0f     | 约 ±3.4e38，7 位精度                    |
| `double`  | 8 字节   | 0.0d     | 约 ±1.8e308，15 位精度                  |
| `char`    | 2 字节   | '\u0000' | 单个 Unicode 字符（0 ~ 65535）          |
| `boolean` | 1 位*    | false    | true / false（JVM 中通常按 1 字节处理） |

#### 浮点数精度丢失

浮点数运算进度丢失是因为计算机二进制存储数字，但是有些小数不能在有限位数里转化成二进制，所以就需要截断，导致精度丢失

如何解决？

使用`BigDecimal`: 用字符串的形式存储小数位，以十进制方式精确表示每一位，适合做高精度运算，比如金额计算。

#### 超过long整型的数据

`BigInteger` 内部使用 `int[]` 数组来存储任意大小的整形数据。

相对于常规整数类型的运算来说，`BigInteger` 运算的效率会相对较低。

#### String为什么不可变？

首先在`Java`中，`final`修饰的引用数据类型不能再指向其他对象，而`string`的字段value底层存储数据的形式就是字符数组，这个数组被final修饰，并且还是私有的，其次string这个类本身也是被final修饰的，那么它就不能被继承，你就不能通过子类来修改，其次，`stringbuilder`和`stringbuffer`继承了`abstractstringbuilder`类，有append等修改字符串的方法，而string没有继承，自然也没有这种方法，这个原因也体现了`OOP`的封装特性，所以综上所述，`string`是不可修改的。

因为不可变性，`String` 是线程安全的，并且它可以作为常量存储在字符串池中，从而节省内存。

## 关键字

#### static

在 Java 中，`static` 是一个非常基础的关键字，表示“静态的”，意思就是这个东西不依赖于对象，而是属于类本身。可以修饰静态变量，静态方法，静态代码块，静态内部类，接口的static方法（8+），接口中的变量默认都是static final的。

**在类中**，`static` 方法是属于类的，可以通过类名直接调用，不需要实例化对象，也**不能被重写**，因为它不属于实例，不参与多态。

**在接口中（Java 8+）**，允许定义 `static` 方法，**只能通过接口名调用，不能被实现类继承或重写**，这主要是为了给接口提供一些工具方法。

#### final

`final` 这个关键字在 Java 里主要是用来限制“修改”的，可以修饰变量、方法和类

如果修饰变量，基本数据类型就表示值不能再变了，引用数据类型表示这个引用不能再指向别的对象。

如果修饰方法，表示它不能被子类重写。

如果修饰类，表示不能被继承。

#### static final

组合在一起使用时表示这个变量是**全局常量**，在整个程序中只存在一份，值不能修改，是一种**线程安全、全局唯一的只读变量**。

## 区别

#### == vs equals

==是一个运算符，对于基本数据类型，表示对比值是否相等，对于引用数据类型，表示对比是否指向同一个对象，也就是在堆内存的内存地址是否相同

而equals是`Obejct`类的方法，默认实现就是`return this == obj`，也就是比较引用的地址，但是`Object`作为所有类的直接或间接的父类，有些标准类都是重写了`equals`方法的，比如`String`，`Integer`，用来比较对象的内容是否相等。

但是需要注意的一点是`Integer a = 127; Integer b = 127;` 比较时 `a == b` 为 `true`，因为 Java 会缓存 `-128` 到 `127` 之间的整数对象，也就是包装类的缓存机制。

#### 成员变量vs局部变量

成员变量属于类，随着对象的创建而存在，可以被访问修饰符和`static`修饰，存于堆，如果没有默认赋值就按照类型默认复制，但是如果是final修饰就必须显式赋值

局部变量属于代码块或方法，随着方法的调用生成和消亡，存于栈内存，不会自动赋值，必须显式赋值

二者都能被final修饰

#### 静态方法vs实例方法

**调用静态方法可以无需创建对象**：前者可以使用 `类名.方法名` 的方式，也可以使用 `对象.方法名` 的方式，后者只能用第二种

静态方法只允许访问静态成员，不允许访问实例成员，而实例方法没有这种限制。

#### 构造代码块vs构造方法

构造代码块是写在类中、没有方法名、没有修饰符的代码块。它在每次创建对象时都会执行，并且**优先于构造方法执行**。

构造方法用于创建对象时初始化，名字与类名相同，可以有多个重载版本。

#### 构造代码块vs静态代码块

构造代码块在每次创建对象前都会执行，提取多个构造方法的共同行为，减少代码重复

静态代码块是在 Java 类中用 `static {}` 包裹的一段代码。**它在类加载时执行，并且只执行一次**，不管你创建了多少个对象。

#### JMM vs JVM

**JVM** 是一个具体的虚拟机，它负责在特定的硬件和操作系统上运行 Java 程序。它包括内存管理、垃圾回收、执行字节码等多个方面。

**JMM** 是 Java 语言的内存模型规范，它并不具体描述实现，而是提供了多线程编程中如何访问共享变量的规范，主要目的是确保并发编程中的线程安全。MM 主要定义了 **内存可见性**、**原子性** 和 **有序性** 三个方面的规则。

#### 值传递vs引用传递

Java 是值传递

**方法调用时，传递的是变量中存储的值的副本**，而不是变量本身。

基本类型：传的是值的拷贝，方法里怎么改都不会影响原来的。

引用类型：传的是引用地址的拷贝，能通过这个地址修改对象的内容，但不能改原来的引用指向。

## 过程

#### 类加载过程

类加载是指 Java 程序在运行过程中，**把 .class 文件加载到 JVM 中，并转化为 Class 对象的过程**。

加载：JVM 通过类的全限定名查找 `.class` 文件，把它的字节码读取进内存，并创建一个 `Class` 对象。

验证：这一步是为了安全，检查这个字节码文件是否合法，比如语法结构、常量池是否合法、防止字节码被篡改等。

准备：这个阶段会为类的**静态变量**分配内存，并设置默认值，比如 `int` 是 0，`boolean` 是 false。

解析：把类中的符号引用（就是类似类名、字段名这种字符串）替换为真正的地址引用（也就是指向内存的引用）。

初始化：这一步才是真正执行代码，比如执行 `static` 代码块，或者静态变量的赋值操作，这些代码只会执行一次。

Java 类加载器采用的是**双亲委派模型**，意思是：**一个类加载器在加载某个类时，先把请求交给它的父加载器，父加载器找不到，才由自己来加载**。有两个好处，应该是避免重复加载，另一个是保证核心类的优先级。

#### 对象创建的过程

当new一个对象的时候，JVM首先判断类是否已经加载，如果没有就加载，如果已经加载了，那么就会在 **堆内存** 中为这个对象分配内存，分配好内存后，JVM 会先对这块内存做默认初始化，比如 int 是 0，引用是 null 等，接下来会准备好 this 指针，把它绑定到刚才分配的那块内存上，进程初始化，执行父类的非静态变量和代码块、父类构造器、子类的非静态变量和代码块、子类构造器。最后返回这个对象在堆的引用。

#### GC

垃圾回收是自动管理内存的一部分，它的目的是释放堆内存中不再使用的对象。Java中的垃圾回收机制由JVM自动处理，开发者通常不需要手动释放内存。

垃圾回收算法有

**引用计数法**：每个对象都有一个计数器，记录引用该对象的次数。

**可达性分析法**：JVM采用的方式。通过根对象（GC Root）来追踪所有可以访问的对象。如果对象从GC Root出发无法访问到，就认为它不可达，可以被回收。

**标记-清除算法**：首先标记所有可达的对象，然后清除所有未被标记的对象。

**复制算法**：将堆内存划分为两块，使用一块，回收时将活动对象复制到另一块。优点是没有内存碎片，缺点是内存的使用效率较低，因为必须有两块内存。

常见的垃圾回收器有G1等

## 静态方法为什么不能调用非静态成员?

静态方法属于类而不是实例，而非静态成员属于对象（实例）。

静态方法在类加载时就可以访问，不依赖于类的具体实例。非静态成员只有在类的实例化对象存在时，才能访问。

静态方法没有`this`引用，不能访问与实例关联的成员。

## 可变长参数

从 `Java5 `开始，Java 支持定义可变长参数，它允许在方法中传递可变数量的参数来简化方法参数。

遇到方法重载的情况会优先匹配固定参数，因为固定参数的方法匹配度更高。

