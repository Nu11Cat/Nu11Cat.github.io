---
title : Redis
order : 3
---

# 基础

Redis 是一个基于内存的高性能 **键值型 NoSQL 数据库**，通常用作**缓存、中间件、消息队列**等。

## redis为什么快

- **纯内存操作 (Memory-Based Storage)** ：这是最主要的原因。Redis 数据读写操作都发生在内存中，访问速度是纳秒级别，而传统数据库频繁读写磁盘的速度是毫秒级别，两者相差数个数量级。

- **高效的 I/O 模型 (I/O Multiplexing & Single-Threaded Event Loop)** ：Redis 使用单线程事件循环配合 I/O 多路复用技术，让单个线程可以同时处理多个网络连接上的 I/O 事件（如读写），避免了多线程模型中的上下文切换和锁竞争问题。虽然是单线程，但结合内存操作的高效性和 I/O 多路复用，使得 Redis 能轻松处理大量并发请求（Redis 线程模型会在后文中详细介绍到）。

- **优化的内部数据结构 (Optimized Data Structures)** ：Redis 提供多种数据类型（如 String, List, Hash, Set, Sorted Set 等），其内部实现采用高度优化的编码方式（如 ziplist, quicklist, skiplist, hashtable 等）。Redis 会根据数据大小和类型动态选择最合适的内部编码，以在性能和空间效率之间取得最佳平衡。

- **简洁高效的通信协议 (Simple Protocol - RESP)** ：Redis 使用的是自己设计的 RESP (REdis Serialization Protocol) 协议。这个协议实现简单、解析性能好，并且是二进制安全的。客户端和服务端之间通信的序列化/反序列化开销很小，有助于提升整体的交互速度。

------

## 为什么用redis

**1、访问速度更快**

传统数据库数据保存在磁盘，而 Redis 基于内存，内存的访问速度比磁盘快很多。引入 Redis 之后，我们可以把一些高频访问的数据放到 Redis 中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。

**2、高并发**

一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右（4 核 8g），但是使用 Redis 缓存之后很容易达到 5w+，甚至能达到 10w+（就单机 Redis 的情况，Redis 集群的话会更高）。

> QPS（Query Per Second）：服务器每秒可以执行的查询次数；

由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。

**3、功能全面**

Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！

---

## 为什么不用本地缓存

虽然本地缓存（如使用 Java 的 `Map` 或 `Guava` 缓存）访问速度更快，但在分布式系统中，本地缓存存在一些明显的局限，而 Redis 恰好可以解决这些问题。

首先，本地缓存是**进程内存级别**的，每个服务节点维护自己的缓存副本，数据无法共享，**一致性难以保证**。当一个节点更新了缓存，其他节点并不知情，容易出现脏读。而 Redis 作为一个独立的服务，**可以作为全局缓存中心统一管理数据**，避免这种一致性问题。

其次，本地缓存容量受限于单个服务实例的内存，**无法支撑大规模缓存需求**；而 Redis 是独立部署的，支持大内存、高并发，可以更灵活地扩展。

再者，Redis 支持**丰富的数据结构和高级特性**，如过期时间、LRU 淘汰策略、分布式锁、持久化、发布订阅等，这些功能是本地缓存很难实现的。

此外，在服务重启或扩缩容时，本地缓存会被清空，而 Redis 可以**长期保存热点数据**，避免缓存重新预热带来的性能抖动。

# 应用

## redis能做什么

redis用作**数据缓存**，这是最常见的用途，比如缓存用户信息、热点商品数据、页面渲染结果，减轻数据库压力，加快响应速度。

另外，Redis 可以用作**分布式锁**，利用其原子性操作保障多节点环境下对共享资源的互斥访问，常用于防止超卖、重复提交等问题。

其次，Redis 支持**消息队列**功能，可以通过 list、stream 或发布订阅机制实现简单的异步通信，用于系统解耦、异步处理等场景。

此外，Redis 常用于**计数器和限流器**，比如统计接口调用次数、用户行为次数，结合过期时间可以快速实现限流、频控等需求。

Redis 还常被用作**会话存储（Session 共享）**，在分布式系统中统一管理用户登录状态，避免单点服务丢失会话信息。

在业务层面，Redis 的有序集合结构适合实现**排行榜、点赞数、活跃用户统计等功能**，Geo 类型也可以支持**地理位置存储与距离计算**。

最后，Redis 还可用来实现**延迟队列、任务调度、热点数据预加载**等需求，充分发挥其高性能和多结构的特点。

## redis实现分布式锁

基于 Redis 实现分布式锁的核心思路，是**利用 Redis 提供的原子性命令 `SET key value NX EX`**。这个命令可以在 key 不存在时设置值，并指定过期时间，保证**只有一个客户端能成功加锁**，从而达到互斥的效果。

实现过程主要包括几个关键点：

1. **加锁（互斥）**：使用 `SET key value NX EX`，其中 NX 表示“仅当 key 不存在时设置”，EX 设置过期时间，避免死锁。
2. **锁唯一性**：value 通常设置为**唯一标识**（比如 UUID），用于标记是哪一个客户端加的锁，防止误解锁。
3. **防止死锁**：设置合理的过期时间，即使客户端异常宕机，锁也能自动释放。
4. **释放锁（安全解锁）**：解锁时需要**判断 value 是否一致**，只有加锁的客户端才能释放对应的锁，避免误删其他线程的锁。这通常需要使用 Lua 脚本来实现 check-and-delete 的原子操作。

除了单实例实现方式，Redis 官方也提供了分布式场景下更稳健的 **Redlock 算法**，它通过在多个 Redis 节点上同时加锁、获取多数派响应，以提高分布式环境下的容错能力和可用性。

## redis做消息队列

**Redis 可以用来实现消息队列**，并且在一些对可靠性要求不高的轻量场景中，它是一种非常实用的解决方案。

Redis 提供多种数据结构支持队列功能，比如：

- 使用 **list** 搭配 `LPUSH + BRPOP` 实现最基本的**先进先出队列**；
- 使用 **stream** 类型可以支持**多消费者组、消费确认、阻塞读取**，更接近完整的消息队列能力；
- 也可以用 **pub/sub** 实现**实时广播消息**，用于通知类场景。

Redis 实现的消息队列具有**响应快、部署简单、集成成本低**的优点，非常适合用于**异步处理、系统解耦、任务削峰**等轻量级场景，比如：异步发送短信、订单通知、注册后欢迎邮件等。

但需要注意的是，**Redis 并不是专业的消息中间件**，它在以下方面存在不足：

- **消息丢失风险**：比如消费者异常宕机、未及时处理消息，消息可能无法恢复；
- **缺乏完整的消费确认机制**（list 模型下尤其明显）；
- **不支持消息重试、死信队列等机制**；
- 在极端高并发、海量消息场景下**可扩展性和稳定性不如 Kafka、RocketMQ 等专业方案**。

因此，实际选择时要根据业务场景权衡：

- 如果只是简单地做异步任务或削峰处理，对可靠性要求不高，Redis 是一种高效、灵活的方案；
- 如果消息的顺序、可靠投递、消息持久化等是关键要求，建议使用 Kafka、RabbitMQ 等成熟的消息中间件。

## redis做搜索引擎

Redis 本身不是为搜索引擎设计的，但在一定程度上**可以支持一些简单的搜索功能**，特别是基于关键字的检索。通过手动构建倒排索引、结合集合操作（如 `SINTER`、`SUNION`）或使用 Redis Module（如 RedisSearch），可以实现关键词匹配、标签筛选等轻量级搜索能力。

例如，RedisSearch 模块提供了分词、全文索引、权重评分、排序等能力，支持类似搜索引擎的查询语法，适合构建中小型、对实时性要求高的搜索系统。

---

对于比较复杂或者数据规模较大的搜索场景，还是不太建议使用 RediSearch 来作为搜索引擎，主要是因为下面这些限制和问题：

- 数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。

- 分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。

- 聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。

- 生态较差：Elasticsearch 可以轻松和常见的一些系统/软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势。

---

RediSearch相对于Elasticsearch的优势：

- 性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。

- 较低内存占用实现快速索引：RediSearch 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。

## Redis 实现延时任务

基于 Redis 实现延时任务的功能无非就下面两种方案：

1. Redis 过期事件监听。
2. Redisson 内置的延时队列。

Redis 过期事件监听存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。

Redisson 内置的延时队列具备下面这些优势：

1. **减少了丢消息的可能**：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。
2. **消息不存在重复消费问题**：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。

# 数据类型

## 5种基本数据类型

Redis 5 种基本数据类型其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Dict（哈希表/字典）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。

实现如下表所示：

| String | List                         | Hash          | Set          | Zset              |
| :----- | :--------------------------- | :------------ | :----------- | :---------------- |
| SDS    | LinkedList/ZipList/QuickList | Dict、ZipList | Dict、Intset | ZipList、SkipList |

Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。从 Redis 7.0 开始， ZipList 被 ListPack 取代。

---

### String(字符串)

 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 **简单动态字符串**（Simple Dynamic String，**SDS**）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。

SDS 的结构中包含了几个重要部分：

1. **len**：记录当前已使用的字节数（不包含结尾的 \0），避免每次求长度都要遍历；
2. **alloc**：表示分配的总容量，便于后续扩容；
3. **flags**：标记 SDS 的类型；
4. **buf[]**：存放实际的字符串内容，以 `\0` 结尾，兼容 C 字符串。

---

SDS 相比于 C 语言中的字符串有如下提升：

1. **可以避免缓冲区溢出**：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。
2. **获取字符串长度的复杂度较低**：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。
3. **减少内存分配次数**：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。
4. **二进制安全**：C 语言中的字符串以空字符 `\0` 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。

---

应用场景：

- **需要存储常规数据的场景**：缓存 Session、Token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。

- **需要计数的场景**：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。

- **分布式锁**：利用 `SETNX key value` 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。

---



### List(列表)

Redis 中的 List 其实就是链表数据结构的实现。Redis 的 List 的实现为一个 **双向链表**，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。

---

应用场景：

- **信息流展示**：最新文章、最新动态。

- **消息队列**：`List` 可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。

---



### Hash(哈希)

Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象。

---

应用场景：

- **对象数据存储场景**：举例：用户信息、商品信息、文章信息、购物车信息。

---

### Set(集合)

Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一。

---

应用场景：

- **需要存放的数据不能重复的场景**：网站 UV 统计（数据量巨大的场景还是 `HyperLogLog`更适合一些）、文章点赞、动态点赞等场景。
- **需要获取多个数据源交集、并集和差集的场景**：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。
- **需要随机获取数据源中的元素的场景**：抽奖系统、随机点名等场景。

---

### Sorted Set(有序集合)

Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 `score`，使得集合中的元素能够按 `score` 进行有序排列，还可以通过 `score` 的范围来获取元素的列表。

[Redis 的有序集合底层为什么要用跳表，而不用平衡树、红黑树或者 B+ 树？](https://javaguide.cn/database/redis/redis-questions-01.html#redis-的有序集合底层为什么要用跳表-而不用平衡树、红黑树或者-b-树)

---

应用场景：

- **需要随机获取数据源中的元素根据某个权重进行排序的场景**：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。
- **需要存储的数据有优先级或者重要程度的场景** 比如优先级任务队列

---

### 其他

**存储对象数据用 String 还是 Hash 更好？**

如果对象是整体读写，且字段变化不频繁，可以直接将对象序列化为一个字符串，用 Redis 的 String 类型存储。它结构简单、访问效率高，适合存储结构固定、内容完整读取的场景，比如用户信息、配置快照等。

而使用 Hash 类型，则更适合对象字段粒度更细、需要频繁按字段读写的情况。Redis 会将 Hash 中的每个 field-value 对独立管理，支持单字段更新，节省流量，也更利于数据解耦。例如，修改用户昵称、头像时只需更新对应字段，无需整体序列化或反序列化。

此外，Hash 类型在字段较少时内部实现是压缩结构，占用内存更小，但字段过多时可能会影响性能。

- 如果是整体读写、结构固定，适合用 String；如果需要按字段读写、字段较多、变更频繁，Hash 更灵活高效。

---

**购物车信息用 String 还是 Hash 存储更好呢?**

存储购物车信息，更推荐使用 Hash 类型，因为它更适合按用户维度分组、按商品维度操作的场景。

具体来说，购物车的数据结构通常是：一个用户对应多个商品及其数量。使用 Hash 类型，我们可以将每个用户的购物车作为一个 key（如 `cart:userId`），其中 field 是商品 ID，value 是数量。

这样的设计带来几个优势：

1. 按需更新字段：可以只修改某个商品的数量，避免整体序列化和反序列化；
2. 结构清晰：每个用户一份 cart，Redis key 总量可控，便于管理；
3. 节省空间：Redis 对小规模 Hash 做了压缩编码处理，内存更高效；
4. 业务操作灵活：可以通过 `HGETALL` 快速获取整个购物车，或者用 `HINCRBY` 修改某一商品数量。

相比之下，如果使用 String 存储，每个用户的购物车都需要整体序列化成字符串（如 JSON），每次修改都涉及反序列化、修改、再写入，性能开销更大，代码也更复杂。

---

**使用Sorted Set实现排行榜**

Redis 实现排行榜最常用的数据结构是 有序集合（Sorted Set），它天生支持按分数排序，非常适合排行榜这种按成绩、积分、热度排名的场景。

在实现上，排行榜中的每个用户或对象作为有序集合的 member，得分作为 score。我们可以通过以下方式实现：

1. 添加或更新成员排名：使用 `ZADD` 命令将用户及其分数加入排行榜，已有则更新；
2. 获取某个范围的排名：使用 `ZREVRANGE` 实现从高到低获取前 N 名；
3. 获取某个用户的排名：使用 `ZREVRANK` 获取某个用户当前在排行榜中的名次；
4. 获取某个用户的得分：使用 `ZSCORE` 查看分数；
5. 按需设置过期时间或定期清理：可按天、周、月维护多个排行榜 key，例如 `rank:daily:20250716`，便于隔离不同周期的数据。

Redis 的有序集合底层使用跳表实现，支持按分数排序的高效插入与查询操作，同时保持集合中成员唯一，避免重复用户。

---

**使用 Set 实现抽奖系统**

Redis 的 Set 类型非常适合用来实现抽奖系统，原因是它具有元素唯一性和随机操作能力，可以高效地完成抽奖相关逻辑。

具体实现方式如下：

1. 初始化奖池：将所有参与抽奖的用户 ID 或奖品 ID 存入一个 Set，例如 `SADD lottery_users user1 user2 ...`；
2. 随机抽取中奖者：使用 `SRANDMEMBER` 从 Set 中随机抽取指定数量的元素，但不删除；
3. 抽中后移除：如果抽奖规则要求不能重复中奖，可以使用 `SPOP`，该命令会从 Set 中随机弹出元素，抽一次减一个；
4. 查看当前奖池人数：使用 `SCARD` 查看当前参与抽奖的总人数；
5. 防止重复参与：Set 的唯一性特性天然防止重复添加用户；
6. 记录中奖名单：可以将中奖者另存一个 Set 或 List，用于后续展示或发奖。

这种方式适用于用户数量中等、并发不高的抽奖系统，数据结构简单，效率高。

---

## 3种特殊数据类型

### Bitmap(位图)

Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。

---

应用场景：

- **需要保存状态信息（0/1 即可表示）的场景**：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。

---

### HyperLogLog (基数统计)

HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。

Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近`2^64`个不同元素。并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：

- **稀疏矩阵**：计数较少的时候，占用空间很小。
- **稠密矩阵**：计数达到某个阈值的时候，占用 12k 的空间。

---

基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 `0.81%` ）。

------

应用场景：

- **数量巨大（百万、千万级别以上）的计数场景**：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计。

---

### Geospatial index(地理位置)

Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。

通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。

---

[Redis 到底是怎么实现“附近的人”这个功能的呢？前言：针对“附近的人”这一位置服务领域的应用场景，常见的可使用PG、 - 掘金](https://juejin.cn/post/6844903966061363207)

---

应用场景：

- **需要管理使用地理空间数据的场景**：附近的人。

---

### 其他

**使用 Bitmap 统计活跃用户**

使用 Redis 的 Bitmap 可以非常高效地统计用户的活跃状态，尤其适合按天、按月等周期统计用户是否活跃、**活跃人数**等场景，核心思路是：用用户 ID 对应 Bitmap 的偏移位，值为 1 表示当天活跃，0 表示未活跃。

具体做法如下：

1. 设置活跃状态：当某个用户访问系统时，使用 `SETBIT key userId 1` 将对应偏移位置为 1。例如：`SETBIT active:20250716 12345 1`，表示用户 ID 为 12345 在 7 月 16 日活跃；
2. 统计活跃人数：使用 `BITCOUNT key` 统计 Bitmap 中值为 1 的位数，即当天活跃用户数；
3. 判断某用户是否活跃：用 `GETBIT key userId` 判断某天某用户是否活跃；
4. 多天活跃分析：可使用 `BITOP AND/OR` 对多个日期的 Bitmap 做并集或交集，分析连续活跃、总活跃人数等；
5. 空间高效：Bitmap 本质是二进制位图，支持千万级用户状态压缩在少量内存中，非常节省空间。

这种方式适合大规模用户活跃统计，尤其在日活、周活、留存分析等业务中非常常见。

---

**使用 HyperLogLog 统计页面 UV** 

HyperLogLog 是 Redis 提供的一种基于概率的数据结构，专门用于高性能地统计海量数据的基数（即不重复元素的个数），非常适合用来统计网站页面的 UV（Unique Visitor）。

实现方式如下：

1. 记录访客：每当用户访问页面时，使用 `PFADD key userId` 将用户 ID（如 IP、用户 ID、会话 ID）添加到 HyperLogLog 中。例如：`PFADD uv:20250716 12345`；
2. 获取 UV 数：使用 `PFCOUNT key` 获取 HyperLogLog 中去重后的用户数量，即当天页面 UV；
3. 跨日合并统计：若需统计某段时间内的 UV，比如一周，可用 `PFMERGE` 将多日数据合并到一个新 key，再用 `PFCOUNT` 查询；
4. 空间高效：HyperLogLog 不存储具体用户 ID，只维护概率桶，内存占用恒定在约 **12KB**，即使统计上亿用户，空间也不会增加。

需要注意的是，HyperLogLog 是一种近似统计结构，误差在 0.81% 左右，不适用于要求精确去重的场景。

---

# 持久化机制



# 线程模型



# 内存管理



# 事务



# 调优



# 穿透击穿雪崩













