---
title : Redis
order : 3
---

# Redis基础

Redis 是一个基于内存的高性能 **键值型 NoSQL 数据库**，通常用作**缓存、中间件、消息队列**等。

## redis为什么快

- **纯内存操作 (Memory-Based Storage)** ：这是最主要的原因。Redis 数据读写操作都发生在内存中，访问速度是纳秒级别，而传统数据库频繁读写磁盘的速度是毫秒级别，两者相差数个数量级。

- **高效的 I/O 模型 (I/O Multiplexing & Single-Threaded Event Loop)** ：Redis 使用单线程事件循环配合 I/O 多路复用技术，让单个线程可以同时处理多个网络连接上的 I/O 事件（如读写），避免了多线程模型中的上下文切换和锁竞争问题。虽然是单线程，但结合内存操作的高效性和 I/O 多路复用，使得 Redis 能轻松处理大量并发请求（Redis 线程模型会在后文中详细介绍到）。

- **优化的内部数据结构 (Optimized Data Structures)** ：Redis 提供多种数据类型（如 String, List, Hash, Set, Sorted Set 等），其内部实现采用高度优化的编码方式（如 ziplist, quicklist, skiplist, hashtable 等）。Redis 会根据数据大小和类型动态选择最合适的内部编码，以在性能和空间效率之间取得最佳平衡。

- **简洁高效的通信协议 (Simple Protocol - RESP)** ：Redis 使用的是自己设计的 RESP (REdis Serialization Protocol) 协议。这个协议实现简单、解析性能好，并且是二进制安全的。客户端和服务端之间通信的序列化/反序列化开销很小，有助于提升整体的交互速度。

------

## 为什么用redis

**1、访问速度更快**

传统数据库数据保存在磁盘，而 Redis 基于内存，内存的访问速度比磁盘快很多。引入 Redis 之后，我们可以把一些高频访问的数据放到 Redis 中，这样下次就可以直接从内存中读取，速度可以提升几十倍甚至上百倍。

**2、高并发**

一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右（4 核 8g），但是使用 Redis 缓存之后很容易达到 5w+，甚至能达到 10w+（就单机 Redis 的情况，Redis 集群的话会更高）。

> QPS（Query Per Second）：服务器每秒可以执行的查询次数；

由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。

**3、功能全面**

Redis 除了可以用作缓存之外，还可以用于分布式锁、限流、消息队列、延时队列等场景，功能强大！

---

## 为什么不用本地缓存

虽然本地缓存（如使用 Java 的 `Map` 或 `Guava` 缓存）访问速度更快，但在分布式系统中，本地缓存存在一些明显的局限，而 Redis 恰好可以解决这些问题。

首先，本地缓存是**进程内存级别**的，每个服务节点维护自己的缓存副本，数据无法共享，**一致性难以保证**。当一个节点更新了缓存，其他节点并不知情，容易出现脏读。而 Redis 作为一个独立的服务，**可以作为全局缓存中心统一管理数据**，避免这种一致性问题。

其次，本地缓存容量受限于单个服务实例的内存，**无法支撑大规模缓存需求**；而 Redis 是独立部署的，支持大内存、高并发，可以更灵活地扩展。

再者，Redis 支持**丰富的数据结构和高级特性**，如过期时间、LRU 淘汰策略、分布式锁、持久化、发布订阅等，这些功能是本地缓存很难实现的。

此外，在服务重启或扩缩容时，本地缓存会被清空，而 Redis 可以**长期保存热点数据**，避免缓存重新预热带来的性能抖动。

# 应用

## redis能做什么

redis用作**数据缓存**，这是最常见的用途，比如缓存用户信息、热点商品数据、页面渲染结果，减轻数据库压力，加快响应速度。

另外，Redis 可以用作**分布式锁**，利用其原子性操作保障多节点环境下对共享资源的互斥访问，常用于防止超卖、重复提交等问题。

其次，Redis 支持**消息队列**功能，可以通过 list、stream 或发布订阅机制实现简单的异步通信，用于系统解耦、异步处理等场景。

此外，Redis 常用于**计数器和限流器**，比如统计接口调用次数、用户行为次数，结合过期时间可以快速实现限流、频控等需求。

Redis 还常被用作**会话存储（Session 共享）**，在分布式系统中统一管理用户登录状态，避免单点服务丢失会话信息。

在业务层面，Redis 的有序集合结构适合实现**排行榜、点赞数、活跃用户统计等功能**，Geo 类型也可以支持**地理位置存储与距离计算**。

最后，Redis 还可用来实现**延迟队列、任务调度、热点数据预加载**等需求，充分发挥其高性能和多结构的特点。

## redis实现分布式锁

基于 Redis 实现分布式锁的核心思路，是**利用 Redis 提供的原子性命令 `SET key value NX EX`**。这个命令可以在 key 不存在时设置值，并指定过期时间，保证**只有一个客户端能成功加锁**，从而达到互斥的效果。

实现过程主要包括几个关键点：

1. **加锁（互斥）**：使用 `SET key value NX EX`，其中 NX 表示“仅当 key 不存在时设置”，EX 设置过期时间，避免死锁。
2. **锁唯一性**：value 通常设置为**唯一标识**（比如 UUID），用于标记是哪一个客户端加的锁，防止误解锁。
3. **防止死锁**：设置合理的过期时间，即使客户端异常宕机，锁也能自动释放。
4. **释放锁（安全解锁）**：解锁时需要**判断 value 是否一致**，只有加锁的客户端才能释放对应的锁，避免误删其他线程的锁。这通常需要使用 Lua 脚本来实现 check-and-delete 的原子操作。

除了单实例实现方式，Redis 官方也提供了分布式场景下更稳健的 **Redlock 算法**，它通过在多个 Redis 节点上同时加锁、获取多数派响应，以提高分布式环境下的容错能力和可用性。

## redis做消息队列

**Redis 可以用来实现消息队列**，并且在一些对可靠性要求不高的轻量场景中，它是一种非常实用的解决方案。

Redis 提供多种数据结构支持队列功能，比如：

- 使用 **list** 搭配 `LPUSH + BRPOP` 实现最基本的**先进先出队列**；
- 使用 **stream** 类型可以支持**多消费者组、消费确认、阻塞读取**，更接近完整的消息队列能力；
- 也可以用 **pub/sub** 实现**实时广播消息**，用于通知类场景。

Redis 实现的消息队列具有**响应快、部署简单、集成成本低**的优点，非常适合用于**异步处理、系统解耦、任务削峰**等轻量级场景，比如：异步发送短信、订单通知、注册后欢迎邮件等。

但需要注意的是，**Redis 并不是专业的消息中间件**，它在以下方面存在不足：

- **消息丢失风险**：比如消费者异常宕机、未及时处理消息，消息可能无法恢复；
- **缺乏完整的消费确认机制**（list 模型下尤其明显）；
- **不支持消息重试、死信队列等机制**；
- 在极端高并发、海量消息场景下**可扩展性和稳定性不如 Kafka、RocketMQ 等专业方案**。

因此，实际选择时要根据业务场景权衡：

- 如果只是简单地做异步任务或削峰处理，对可靠性要求不高，Redis 是一种高效、灵活的方案；
- 如果消息的顺序、可靠投递、消息持久化等是关键要求，建议使用 Kafka、RabbitMQ 等成熟的消息中间件。

## redis做搜索引擎

Redis 本身不是为搜索引擎设计的，但在一定程度上**可以支持一些简单的搜索功能**，特别是基于关键字的检索。通过手动构建倒排索引、结合集合操作（如 `SINTER`、`SUNION`）或使用 Redis Module（如 RedisSearch），可以实现关键词匹配、标签筛选等轻量级搜索能力。

例如，RedisSearch 模块提供了分词、全文索引、权重评分、排序等能力，支持类似搜索引擎的查询语法，适合构建中小型、对实时性要求高的搜索系统。

---

对于比较复杂或者数据规模较大的搜索场景，还是不太建议使用 RediSearch 来作为搜索引擎，主要是因为下面这些限制和问题：

- 数据量限制：Elasticsearch 可以支持 PB 级别的数据量，可以轻松扩展到多个节点，利用分片机制提高可用性和性能。RedisSearch 是基于 Redis 实现的，其能存储的数据量受限于 Redis 的内存容量，不太适合存储大规模的数据（内存昂贵，扩展能力较差）。

- 分布式能力较差：Elasticsearch 是为分布式环境设计的，可以轻松扩展到多个节点。虽然 RedisSearch 支持分布式部署，但在实际应用中可能会面临一些挑战，如数据分片、节点间通信、数据一致性等问题。

- 聚合功能较弱：Elasticsearch 提供了丰富的聚合功能，而 RediSearch 的聚合功能相对较弱，只支持简单的聚合操作。

- 生态较差：Elasticsearch 可以轻松和常见的一些系统/软件集成比如 Hadoop、Spark、Kibana，而 RedisSearch 则不具备该优势。

---

RediSearch相对于Elasticsearch的优势：

- 性能更优秀：依赖 Redis 自身的高性能，基于内存操作（Elasticsearch 基于磁盘）。

- 较低内存占用实现快速索引：RediSearch 内部使用压缩的倒排索引，所以可以用较低的内存占用来实现索引的快速构建。

## Redis 实现延时任务

待定

基于 Redis 实现延时任务的功能无非就下面两种方案：

1. Redis 过期事件监听。
2. Redisson 内置的延时队列。

Redis 过期事件监听存在时效性较差、丢消息、多服务实例下消息重复消费等问题，不被推荐使用。

Redisson 内置的延时队列具备下面这些优势：

1. **减少了丢消息的可能**：DelayedQueue 中的消息会被持久化，即使 Redis 宕机了，根据持久化机制，也只可能丢失一点消息，影响不大。当然了，你也可以使用扫描数据库的方法作为补偿机制。
2. **消息不存在重复消费问题**：每个客户端都是从同一个目标队列中获取任务的，不存在重复消费的问题。

# 数据类型















