---
title : MySQL
order : 2
---

InnoDB 存储引擎

# 基础

## 关系型数据库、SQL

**关系型数据库**（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。

大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。

常见的关系型数据库：MySQL、PostgreSQL、Oracle、SQL Server、SQLite。

SQL 是一种结构化查询语言。目的是提供一种从数据库中读写数据的简单有效的方法。

## MySQL

MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。

### 优点

1. 成熟稳定，功能完善。
2. 开源免费。
3. 文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。
4. 开箱即用，操作简单，维护成本低。
5. 兼容性好，支持常见的操作系统，支持多种开发语言。
6. 社区活跃，生态完善。
7. 事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。
8. 支持分库分表、读写分离、高可用。

# 字段类型

MySQL 字段类型可以简单分为三大类：

- **数值类型**：整型（TINYINT、SMALLINT、MEDIUMINT、INT 和 BIGINT）、浮点型（FLOAT 和 DOUBLE）、定点型（DECIMAL）
- **字符串类型**：CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB 等，最常用的是 CHAR 和 VARCHAR。
- **日期时间类型**：YEAR、TIME、DATE、DATETIME 和 TIMESTAMP 等。

MySQL 中**没有**专门的**布尔**类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。

| 分类       | 字段类型        | 大小        | 常见用途                   |
| ---------- | --------------- | ----------- | -------------------------- |
| **整数型** | `TINYINT`       | 1 字节      | 年龄、状态码、布尔值等     |
|            | `SMALLINT`      | 2 字节      | 人口、库存等小数值         |
|            | `MEDIUMINT`     | 3 字节      | 特定范围的计数值           |
|            | `INT / INTEGER` | 4 字节      | 订单号、用户ID等           |
|            | `BIGINT`        | 8 字节      | 高精度ID、日志记录等       |
| **小数型** | `FLOAT`         | 4 字节      | 温度、评分等近似数值       |
|            | `DOUBLE`        | 8 字节      | 更高精度的科学计算         |
|            | `DECIMAL(p,s)`  | 可变        | 金额、财务数据等高精度     |
| **字符串** | `CHAR(n)`       | 固定 n 字节 | 性别、固定长度编码等       |
|            | `VARCHAR(n)`    | n+1 字节    | 姓名、地址、邮箱等文本     |
|            | `TEXT`          | 最大 64KB   | 评论、文章正文等大文本     |
| **时间型** | `DATE`          | 3 字节      | 出生日期、创建日期等       |
|            | `DATETIME`      | 8 字节      | 精确时间记录               |
|            | `TIMESTAMP`     | 4 字节      | 自动记录操作时间           |
|            | `TIME`          | 3 字节      | 表示某个时间点（时分秒）   |
|            | `YEAR`          | 1 字节      | 出生年份、注册年份等       |
| **其他**   | `ENUM(...)`     | 1~2 字节    | 性别、状态、分类等固定选项 |
|            | `SET(...)`      | 1~8 字节    | 标签、权限集合等           |

## 整数类型的 UNSIGNED 属性

MySQL 中的整数类型可以使用可选的 UNSIGNED 属性来表示不允许负值的无符号整数。使用 UNSIGNED 属性可以将正整数的上限提高一倍，因为它不需要存储负数值。

## 不推荐TEXT和BLOB

TEXT是长文本数据，例如博客内容。BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。

在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。

数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：

- 不能有默认值。
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。
- 检索效率较低。
- 不能直接创建索引，需要指定前缀长度。
- 可能会消耗大量的网络和 IO 带宽。
- 可能导致表上的 DML 操作变慢。

## 有时不建议使用 `NULL`

原因主要包括以下几点：

1. **影响索引效率**
    对含有 `NULL` 的列建索引时，`NULL` 不参与某些类型的索引优化。例如，在复合索引中，如果某一列是 `NULL`，可能导致索引失效，查询变慢。
2. **查询逻辑复杂**
    `NULL` 表示“未知”，不是普通的值，不能用 `=`、`!=` 比较，只能用 `IS NULL`、`IS NOT NULL`，这会导致 SQL 语句更加复杂、容易出错。
3. **聚合函数和统计结果受影响**
    像 `COUNT(col)` 不会统计 `NULL` 值，而 `COUNT(*)` 会，开发中容易误解；类似的 `AVG(col)`、`SUM(col)` 等函数遇到 `NULL` 时也需要额外处理。
4. **额外的存储和处理开销**
    每个包含 `NULL` 的列，MySQL 在内部需要额外的**标志位**记录其是否为 `NULL`，在数据量大时会影响存储效率和性能。
5. **违反业务语义**
    有些字段本可以通过默认值表达“未设置”或“未知”状态，不一定非要用 `NULL`，使用明确的默认值（如 `0`、空字符串）更易于理解和处理。

## 手机号存储用VARCHAR

存储手机号，**强烈推荐使用 VARCHAR 类型**，而不是 INT 或 BIGINT。

主要原因如下：

1. 格式兼容性与完整性：
   - 手机号可能包含前导零（如某些地区的固话区号）、国家代码前缀（'+'），甚至可能带有分隔符（'-' 或空格）。INT 或 BIGINT 这种数字类型会自动丢失这些重要的格式信息（比如前导零会被去掉，'+' 和 '-' 无法存储）。
   - VARCHAR 可以原样存储各种格式的号码，无论是国内的 11 位手机号，还是带有国家代码的国际号码，都能完美兼容。
2. **非算术性：**手机号虽然看起来是数字，但我们从不对它进行数学运算（比如求和、平均值）。它本质上是一个标识符，更像是一个字符串。用 VARCHAR 更符合其数据性质。
3. 查询灵活性：
   - 业务中常常需要根据号段（前缀）进行查询，例如查找所有 "138" 开头的用户。使用 VARCHAR 类型配合 `LIKE '138%'` 这样的 SQL 查询既直观又高效。
   - 如果使用数字类型，进行类似的前缀匹配通常需要复杂的函数转换（如 CAST 或 SUBSTRING），或者使用范围查询（如 `WHERE phone >= 13800000000 AND phone < 13900000000`），这不仅写法繁琐，而且可能无法有效利用索引，导致性能下降。
4. 加密存储的要求（非常关键）：
   - 出于数据安全和隐私合规的要求，手机号这类敏感个人信息通常必须加密存储在数据库中。
   - 加密后的数据（密文）是一长串字符串（通常由字母、数字、符号组成，或经过 Base64/Hex 编码），INT 或 BIGINT 类型根本无法存储这种密文。只有 VARCHAR、TEXT 或 BLOB 等类型可以。

**关于 VARCHAR 长度的选择：**

- **如果不加密存储（强烈不推荐！）：** 考虑到国际号码和可能的格式符，VARCHAR(20) 到 VARCHAR(32) 通常是一个比较安全的范围，足以覆盖全球绝大多数手机号格式。VARCHAR(15) 可能对某些带国家码和格式符的号码来说不够用。
- **如果进行加密存储（推荐的标准做法）：** 长度必须根据所选加密算法产生的密文最大长度，以及可能的编码方式（如 Base64 会使长度增加约 1/3）来精确计算和设定。通常会需要更长的 VARCHAR 长度，例如 VARCHAR(128), VARCHAR(256) 甚至更长。

## CHAR vs VARCHAR

CHAR 和 VARCHAR 是最常用到的字符串类型，两者的主要区别在于：**CHAR 是定长字符串，VARCHAR 是变长字符串。**

CHAR 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；VARCHAR 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。

CHAR 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。VARCHAR 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。

CHAR(M) 和 VARCHAR(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。

## VARCHAR(100) vs VARCHAR(10)

VARCHAR(100)和 VARCHAR(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。VARCHAR (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 VARCHAR(10)存储超过 10 个字符时，就需要修改表结构才可以。

但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的；但是VARCHAR(100) 会消耗更多的内存。这是因为 VARCHAR 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，VARCHAR(100)是按照 100 这个长度来进行的，也就会消耗更多内存。

## DECIMAL vs FLOAT

**DECIMAL 是定点数，FLOAT/DOUBLE 是浮点数。DECIMAL 可以存储精确的小数值，FLOAT/DOUBLE 只能存储近似的小数值。**

DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。

## DATETIME vs TIMESTAMP

DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。

TIMESTAMP 只需要使用 4 个字节的存储空间，但是 DATETIME 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。

MySQL 不建议使用 `NULL` 作为列默认值

## NULL vs ''空字符串

`NULL` 代表缺失或未知的数据，而 `''` 表示一个已知存在的空字符串。

- `NULL` 的存储空间占用取决于数据库的实现，通常需要一些空间来标记该值为空。
- `''` 的存储空间占用通常较小，因为它只存储一个空字符串的标志，不需要存储实际的字符。

- 任何值与 `NULL` 进行比较（例如 `=`, `!=`, `>`, `<` 等）的结果都是 `NULL`，表示结果不确定。要判断一个值是否为 `NULL`，必须使用 `IS NULL` 或 `IS NOT NULL`。''可以像其他字符串一样进行比较运算。例如，'' = ''的结果是 true

大多数聚合函数（例如 `SUM`, `AVG`, `MIN`, `MAX`）会忽略 `NULL` 值。`COUNT(*)` 会统计所有行数，包括包含 `NULL` 值的行。`COUNT(列名)` 会统计指定列中非 `NULL` 值的行数。

空字符串 `''` 会被聚合函数计算在内。例如，`SUM` 会将其视为 0，`MIN` 和 `MAX` 会将其视为一个空字符串。



































































