---
title : Java多线程
order: 4
---

# 多线程

## 线程

### 进程与线程

**进程（Process）** 是操作系统资源分配的最小单位，每个进程拥有独立的内存空间、代码、数据和系统资源。进程之间相互独立，数据不共享，通信成本较高。

**线程（Thread）** 是程序执行的最小单位，是进程内部的一个执行流。一个进程可以包含多个线程，它们共享同一块内存（代码、堆等），但每个线程有自己的栈空间和程序计数器。由于共享资源，线程之间通信开销小，切换快，但也更容易出现并发问题。

进程是容器，线程是容器中的执行单元。线程必须依附于进程存在，离开进程线程无法单独存在。

### 线程安全

线程安全和不安全是在多线程环境下对于同一份数据的访问是否能够保证其正确性和一致性的描述。

- 线程安全指的是在多线程环境下，对于同一份数据，不管有多少个线程同时访问，都能保证这份数据的正确性和一致性。
- 线程不安全则表示在多线程环境下，对于同一份数据，多个线程同时访问时可能会导致数据混乱、错误或者丢失。

### 创建线程的方式

第一种是**继承 Thread 类**，重写它的 `run()` 方法，然后创建实例调用 `start()` 方法启动线程。这种方式简单直观，但因为 Java 不支持多继承，所以灵活性较差。

第二种是**实现 Runnable 接口**，把线程逻辑写在 `run()` 方法中，再把这个实现类传给 Thread 构造器。这种方式更灵活，适合资源共享，也更符合面向接口编程的思想。

第三种是**实现 Callable 接口并结合 FutureTask 使用**。这个方式的优势是可以有返回值，且可以抛出异常，更适合需要拿到线程执行结果的场景。

如果使用线程池，比如通过 `ExecutorService` 来提交任务，那底层其实也是通过 Callable 或 Runnable 实现的，只是线程的创建和管理交给了线程池，效率更高、控制力更强。

### 生命周期和状态

Java线程大致有 **六种状态**，定义在 `Thread.State` 枚举中，整个生命周期如下：

**1. 新建（New）**
 线程对象刚创建，还没调用 `start()` 方法。

**2. 就绪（Runnable）**
 调用 `start()` 后，线程进入就绪队列，等待 CPU 调度。此时并没有运行。

**3. 运行中（Running）**
 线程真正获得 CPU 时间片，开始执行 `run()` 方法的代码。

**4. 阻塞（Blocked）**
 线程尝试获取某个被别的线程持有的锁（比如 synchronized），获取不到就进入阻塞状态，直到拿到锁。

**5. 等待（Waiting）**
 线程主动等待别的线程的通知，例如调用了 `wait()`、`join()`，没有设置超时。必须通过 `notify()` 或 `join()` 结束才会被唤醒。

**6. 计时等待（Timed Waiting）**
 和等待类似，但设置了超时时间，比如 `sleep(1000)`、`wait(1000)`、`join(1000)`。

**7. 终止（Terminated）**
 线程运行完了，或者抛异常终止了，生命周期结束。

### 线程上下文切换

线程在执行过程中会有自己的运行条件和状态（也称上下文），比如上文所说到过的程序计数器，栈信息等。当出现如下情况的时候，线程会从占用 CPU 状态中退出。

- 主动让出 CPU，比如调用了 `sleep()`, `wait()` 等。
- 时间片用完，因为操作系统要防止一个线程或者进程长时间占用 CPU 导致其他线程或者进程饿死。
- 调用了阻塞类型的系统中断，比如请求 IO，线程被阻塞。
- 被终止或结束运行

这其中前三种都会发生线程切换，线程切换意味着需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的 **上下文切换**。

### Thread 类的 run 方法

**可以直接调用 Thread 类的 run 方法吗？**

可以，但是一般不会直接调用 `run()`，而是使用 `start()` 来正确启动线程。

直接调用 `run()` 并不会启动一个新线程，它只是一个普通的方法调用，会在当前线程中执行，不具备多线程的效果。

正常启动线程，应该调用 `start()` 方法。`start()` 会由 JVM 创建新的线程，然后自动调用该线程的 `run()` 方法，真正实现多线程并发。

### sleep() 方法和 wait() 方法

在Java中，`sleep()` 和 `wait()` 都是控制线程执行流程的方法，两者都可以暂停线程的执行，但它们的用途和行为有显著不同。

**`sleep()`** 是 `Thread` 类的方法，用于让当前线程暂停执行指定的时间。线程在暂停期间不会释放持有的锁。它通常用于线程执行的延时，比如定时任务或控制任务的执行频率。当线程调用 `sleep()` 后，它会进入 **“Timed Waiting”** 状态，直到指定时间过去后自动唤醒。需要注意的是，`sleep()` 会抛出 `InterruptedException`，如果线程在睡眠过程中被中断。

**`wait()`** 是 `Object` 类的方法，必须在同步块或同步方法中调用，因为它需要持有对象的锁。当线程调用 `wait()` 后，它会进入 **“Waiting”** 状态，直到其他线程通过调用 `notify()` 或 `notifyAll()` 来唤醒它。与 `sleep()` 不同，`wait()` 会释放持有的锁，允许其他线程访问共享资源。这种机制通常用于线程间的通信，例如生产者-消费者问题。

简单来说，`sleep()` 用于让线程休眠一段时间，而 `wait()` 用于线程间的协调和同步，通常结合 `notify()` 或 `notifyAll()` 一起使用。

>**`wait()`属于`Object` 类**：`wait()` 是让获得对象锁的线程实现等待，会自动释放当前线程占有的对象锁。每个对象（`Object`）都拥有对象锁，既然要释放当前线程占有的对象锁并让其进入 WAITING 状态，自然是要操作对应的对象（`Object`）而非当前的线程（`Thread`）。
>
>**`sleep()` 属于 `Thread`** ：因为 `sleep()` 是让当前线程暂停执行，不涉及到对象类，也不需要获得对象锁。

## 多线程

### 并发与并行

**并发（Concurrency）** 指的是多个任务在同一时间段内交替执行，可能只用一个 CPU 核心，通过任务切换实现“同时进行”的效果。本质是**逻辑上的同时**，底层依靠时间片轮转。

**并行（Parallelism）** 是指多个任务在**同一时刻真正同时运行**，必须依赖多核 CPU。每个任务在不同的核心上同时执行，实现**物理上的同时**。

举个例子，如果一个厨房只有一个人做饭，但能快速切换做饭、洗菜、炒菜的动作，那是并发；如果厨房有三个人分别同时做这三件事，那是并行。

并发更关注**任务切换效率**，并行更关注**处理能力最大化**。

### 同步与异步

同步和异步是描述任务执行时的等待与通知机制。

**同步（Synchronous）** 是指调用方发起请求后，**必须等待任务执行完毕才能继续**执行后续操作。调用过程是阻塞的。

**异步（Asynchronous）** 是指调用方发起请求后，**不等待任务完成，立即返回**，任务在后台执行，完成后通过回调、通知或轮询的方式获取结果。调用过程是非阻塞的。

举个例子，打电话让别人帮你查快递并等他查完再挂电话，这是同步；而发个微信让他查，等查完再告诉你，是异步。

在 Java 中，普通方法调用是同步的；使用 `CompletableFuture`、`Future`、线程池提交任务时，就是异步执行，主线程可以继续做其他事。

**同步编程**简单直观，但可能导致资源浪费和线程阻塞；**异步编程**提高了程序响应性和资源利用率，常用于 I/O 密集型或高并发场景。

### 为什么要使用多线程?

使用多线程的核心目的是**提升程序的效率和响应能力**

第一，**提高资源利用率**。现代 CPU 都是多核的，多线程可以让多个核心同时工作，实现真正的并行，提高处理能力。如果单线程运行，只能用到一个核心，浪费硬件资源。

第二，**提升程序响应性**。比如在图形界面或 Web 应用中，一个线程处理用户输入，另一个线程处理后台逻辑，可以避免界面卡顿，提升用户体验。

第三，**简化模型结构**。像生产者-消费者、事件驱动、定时任务等，如果用多线程实现，会比纯粹的轮询或状态机更自然、清晰。

第四，**加快任务处理速度**。比如同时处理多个客户端请求，或者将一个大任务拆分为多个线程并发处理，能够显著缩短整体耗时。

### 单核CPU

单核 CPU 是支持 Java 多线程的。操作系统通过时间片轮转的方式，将 CPU 的时间分配给不同的线程。（并发）

**单核 CPU 上运行多个线程效率一定会高吗？**

不一定。在单核 CPU 上运行多个线程时，线程是通过时间片轮转来切换执行的，并不是真正的同时运行，而是快速切换看起来“像是”并发。

这种切换会带来上下文切换开销，包括保存和恢复线程状态、缓存失效、内存切换等。如果线程数量过多或者频繁切换，反而会导致效率下降，甚至不如单线程执行。

另外，多线程引入了线程同步、锁竞争、死锁等问题，在单核环境下，这些问题的代价会更明显，降低程序整体性能。

所以在单核 CPU 上，是否使用多线程，取决于具体场景：

- 适合多线程的情况：比如大量 I/O 操作（读写文件、网络请求等），CPU 在等待时可以切到其他线程，提升资源利用率。

- 不适合多线程的情况：如果是 CPU 密集型运算，多线程反而因为频繁切换和锁竞争导致更低的效率。

# 锁

## 死锁

**死锁（Deadlock）** 是指两个或多个线程在执行过程中，因争夺资源而导致**相互等待对方释放资源**，从而使得所有线程都无法继续执行的情况。

Java 线程的 `jstack` 工具**检测死锁**：如果有死锁，`jstack` 的输出中通常会有 `Found one Java-level deadlock:`的字样，后面会跟着死锁相关的线程信息。

**死锁的四个必要条件**：

1. **互斥**：至少有一个资源是处于**独占模式**的，即某一时刻只能有一个线程使用该资源。
2. **持有并等待**：一个线程已经持有了至少一个资源，但又在等待其他线程持有的资源。
3. **非抢占**：资源不能被强制抢占，只有线程自己释放资源。
4. **循环等待**：一组线程之间存在一种“环形等待”关系，即线程A等待线程B持有的资源，线程B又在等待线程A持有的资源。

**防止和避免死锁的方法**：

1. **避免循环等待**：通过一定的策略（比如按顺序加锁）来避免出现循环等待。
2. **使用 `tryLock`**：例如 `ReentrantLock` 提供的 `tryLock()` 方法，能够尝试获得锁，如果无法获得就放弃，避免死锁。
3. **锁超时机制**：通过设置锁的最大等待时间，避免无限等待。
4. **减少锁的粒度**：尽量减少持有锁的时间，并且尽可能避免嵌套锁。

## 乐观锁和悲观锁

乐观锁和悲观锁本质上是两种并发控制策略，它们的核心区别在于对**数据冲突的预期不同**。

**悲观锁**认为并发冲突是很常见的，因此每次访问共享资源时都会**先加锁**，比如使用 `synchronized` 或 `ReentrantLock` 来保证同一时刻只有一个线程访问资源。这种方式安全性高，适用于并发写多、冲突频繁的场景，比如转账、订单扣库存等。

而**乐观锁**则认为并发冲突是少数，它**不加锁**，而是每次读取数据时带上一个版本号或时间戳，修改时再比对当前版本是否一致。如果一致就更新成功，否则就重试。像 Java 中的 `AtomicInteger`、`AtomicReference`，底层就是基于 CAS 实现的乐观锁。数据库中也常用乐观锁，比如用 `version` 字段控制更新。

简单来说，**悲观锁重在预防，乐观锁重在事后校验**。

悲观锁通常多用于写比较多的情况（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如`LongAdder`），也是可以考虑使用乐观锁的，要视实际情况而定。

乐观锁通常多用于写比较少的情况（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量。

**版本号机制**

版本号机制是实现乐观锁的常见方式之一，主要用于解决并发修改共享数据的问题。

它的核心思路是：每条数据都加一个版本号字段（如 version），每次读取数据时一并读取当前版本号，更新时也携带这个版本号。

当进行更新操作时，系统会检查当前数据库中的版本号是否与之前读取的一致：

- 如果一致，说明这段时间内没人改动过这条数据，就允许更新，并把版本号 +1；
- 如果不一致，说明其他线程已经修改过了，当前更新失败，可以选择重试或提示用户。

这个机制避免了加锁，也能有效防止脏写（Lost Update）问题。

**CAS算法**

CAS，全称是 Compare-And-Swap（比较并交换），是一种常见的无锁并发原子操作，底层由硬件指令支持。

它的核心思想是：在更新某个共享变量时，先比较它的当前值是否是预期值，如果是，则更新为新值；如果不是，说明已经被其他线程修改过，更新失败，通常会进行重试。

在 Java 中，`java.util.concurrent.atomic` 包下的原子类，比如 `AtomicInteger`、`AtomicReference`，就是基于 CAS 实现的乐观锁。

**ABA 问题**是 CAS 算法中一个典型的并发陷阱。

CAS 只比较当前值和预期值是否相等，但**并不知道这个值在期间是否发生过变化又被改回来了**，也就是说，它只能比较“值”，但不知道“过程”。为了避免 ABA 问题，Java 提供了带版本号的原子引用类：`AtomicStampedReference`：每次更新时不仅比较值，还比较一个“版本号”或“时间戳”，确保值和版本都没变，从而检测到中间的变化。

## ReentrantLock

`ReentrantLock` 是 Java 5 引入的显式锁，是 **可重入锁**，即同一线程可以多次获得锁而不会被阻塞。

# JMM

# 线程池



# 关键字

## volatile

`volatile` 是 Java 中一种轻量级的内存同步机制，用于修饰变量，确保变量的**可见性**和**禁止指令重排序**。然而，它并不保证操作的**原子性**。

在 Java 中，每个线程都有自己的工作内存，当线程操作一个变量时，首先会从主内存拷贝该变量的副本到工作内存，线程只会操作工作内存中的副本，最后在合适的时候将结果刷新回主内存。如果没有适当的同步机制，可能导致多个线程读取到的变量值不同，从而出现可见性问题。`volatile` 通过确保线程写入变量时，会立刻将其更新到主内存，并且线程每次读取时，都会从主内存中获取最新的值，从而解决了**可见性**问题。

为了提高性能，计算机可能对程序指令进行重排序，而 `volatile` 可以禁止对带有 `volatile` 变量的写操作和后续读操作的**重排序**，确保这些操作按顺序执行。当一个变量被声明为 `volatile` 时，Java 编译器和 CPU 会在它的读写操作前后插入特定的内存屏障。

然而，`volatile` 并不保证**原子性操作**。比如对 `volatile` 变量的递增操作（`++`）可能仍然会出现竞态条件，因为它涉及多个步骤：读取、修改和写入。因此，仍然需要 `synchronized` 或其他机制来保证原子性。

`volatile` 的底层实现依赖于 Java 内存模型（JMM），通过内存屏障来确保变量的可见性和禁止指令重排序。

## synchronized

`synchronized` 是 Java 中的一个关键字，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。

# 其他
