---
title : 双指针
---

#### 颜色分类

[75. 颜色分类 - 力扣（LeetCode）](https://leetcode.cn/problems/sort-colors/description/?envType=study-plan-v2&envId=top-100-liked)

分别两个指针指向0和1，跟i做交换

需要注意的是，当0交换前，一般p0指向1，所以把0换过来还得跟p1再换

也就是 

>​	  a          b       i
>
>0    1   1   2   2   0       这里a和i换完，i还得和b再换。但是如果没有1，也就是a和b指向同一个，那就不需要了

```java
class Solution {
    public void sortColors(int[] nums) {
        int p0 = 0, p1 = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] == 0){
                change(nums,i,p0);
                if(p0 < p1){
                    change(nums,i,p1);
                }
                p0++;
                p1++;
            }else if(nums[i] == 1){
                change(nums,i,p1);
                p1++;
            }
            
        }
    }
    void change(int[] nums, int a, int b){
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }
}
```

#### 下一个排列

[31. 下一个排列 - 力扣（LeetCode）](https://leetcode.cn/problems/next-permutation/description/?envType=study-plan-v2&envId=top-100-liked)

就是找最后一个递增&最后面的比nums[p0]大的元素，互换，然后把p0+1到n-1倒转

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int n = nums.length;
        int p0 = -1;

        // 1. 从后往前找第一个 nums[i] > nums[i - 1] 的位置
        for (int i = n - 1; i > 0; i--) {
            if (nums[i] > nums[i - 1]) {
                p0 = i - 1;
                break;
            }
        }

        // 2. 如果找不到，整个数组降序，翻转即可
        if (p0 == -1) {
            reverse(nums, 0, n - 1);
            return;
        }

        // 3. 从后往前找第一个比 nums[p0] 大的元素
        int p1 = n - 1;
        while (nums[p1] <= nums[p0]) {
            p1--;
        }

        // 4. 交换 p0 和 p1
        swap(nums, p0, p1);

        // 5. 反转 p0 + 1 到末尾
        reverse(nums, p0 + 1, n - 1);
    }

    void swap(int[] nums, int a, int b) {
        int temp = nums[a];
        nums[a] = nums[b];
        nums[b] = temp;
    }

    void reverse(int[] nums, int left, int right) {
        while (left < right) {
            swap(nums, left++, right--);
        }
    }
}
```

#### 寻找重复数

[287. 寻找重复数 - 力扣（LeetCode）](https://leetcode.cn/problems/find-the-duplicate-number/description/?envType=study-plan-v2&envId=top-100-liked)

把数组看作一个“链表”，i是下标，nums[i]是下一个节点的“地址”

也就是：

```tex
0 → nums[0] → nums[nums[0]] → nums[nums[nums[0]]] → ...
```

由于有重复数字，所以会存在相同的nums[i]，指针指向就会重叠，形成环，所以可以套用判圈算法

注：题目条件有：数组长度是 `n + 1`    &   数组中的数范围是 `[1, n]`

```java
class Solution {
    public int findDuplicate(int[] nums) {
        int fast = 0, slow = 0;
        do{
            fast=nums[nums[fast]];
            slow = nums[slow];
        }while(fast!=slow);
        slow = 0;
        while(fast!=slow){
            fast=nums[fast];
            slow = nums[slow];
        }
        return fast;
    }
}
```

#### 移动零

指针j表示零与非0的分界

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int j = 0;
        for(int i = 0;i < nums.length; i++){
            if(nums[i] != 0){
                int tmp = nums[i];
				nums[i] = nums[j];
				nums[j++] = tmp;
            }
        }
    }
}
```

合并两个有序数组

[88. 合并两个有序数组 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

>最赖皮的：sort
>
>常规双指针：归并，但是需要额外空间，因为题目是void，在num1上添加
>
>逆向双指针：空间复杂度是1     ⭐

```java
//常规归并双指针
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] arr = new int[m+n];
        int index1 = 0, index2 = 0, index = 0;
        while(index1 < m && index2 < n) {
            if(nums1[index1] < nums2[index2]) {
                arr[index++] = nums1[index1++];
            }else {
                arr[index++] = nums2[index2++];
            }
        }   
        while(index1 < m) {  arr[index++] = nums1[index1++]; }
        while(index2 < n) {  arr[index++] = nums2[index2++]; }
        for(int i = 0; i < m+n ; i++) {
            nums1[i]  = arr[i];
        }
    }
}
```

```java
//逆向双指针
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int index1 = m-1, index2 = n-1, index = m + n -1;
        while(index1 >= 0 && index2 >= 0) {
            if(nums1[index1] > nums2[index2]) {
                nums1[index--] = nums1[index1--];
            }else {
                nums1[index--] = nums2[index2--];
            }
        }   
        while(index1 >= 0) {  nums1[index--] = nums1[index1--]; }
        while(index2 >= 0) {  nums1[index--] = nums2[index2--]; }
    }
}
```

#### 移除元素

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/?envType=study-plan-v2&envId=top-interview-150)

>可以快慢指针，也可以对撞指针，但是感觉没什么太大区别

```jav
class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;
        int left = 0;
        for(int i = 0; i < n; i++) {
            if(nums[i] != val) {
                nums[left] = nums[i];
                left++;
            }
        }
        return left;
    }
}
```

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int left = 0, right = nums.length-1;
        while(left <= right) {
            if(nums[left] == val) {
                nums[left] = nums[right];
                right--;
            }else {
                left++;
            }
        }
        return left;
    }
}
```

#### 删除有序数组中的重复项

[26. 删除有序数组中的重复项 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)

>简简单单快慢指针（我甚至第一次用LinkedHashSet写的....）

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0, slow = 0;
        while(fast < nums.length) {
            if(nums[fast] != nums[slow]) {
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }
        return slow+1;
    }
}
//或者
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int fast = 1, slow = 1;
        while (fast < n) {
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
```

#### 删除有序数组中的重复项II

[80. 删除有序数组中的重复项 II - 力扣（LeetCode）](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/?envType=study-plan-v2&envId=top-interview-150)

>类似I，但是

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 2, slow = 2;
        while(fast < nums.length) {
            if(nums[fast] != nums[slow - 2]) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```

