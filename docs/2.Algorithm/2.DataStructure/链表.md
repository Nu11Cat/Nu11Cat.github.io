---
title : 链表
---

#### 合并两个有序链表

[21. 合并两个有序链表 - 力扣（LeetCode）](https://leetcode.cn/problems/merge-two-sorted-lists/description/?envType=study-plan-v2&envId=programming-skills)

>递归解法，无需多言，优雅！

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        else if(list2 == null) return list1;
        else if(list1.val < list2.val){
            list1.next = mergeTwoLists(list1.next,list2);
            return list1;
        }else {
            list2.next = mergeTwoLists(list2.next,list1);
            return list2;
        }
    }
}
```

>迭代解法，很像归并排序，本质是双指针有序合并

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode mynode = new ListNode(-1);
        ListNode res = mynode;
        ListNode l1 = list1, l2 = list2;
        while(l1 != null && l2 != null) {
            if(l1.val < l2.val) {
                mynode.next = l1;
                l1 = l1.next;
            }else {
                mynode.next = l2;
                l2 = l2.next;
            }
            mynode = mynode.next;
        }
        mynode.next = l1 == null ? l2 : l1;
        return res.next;
    }
}
```

#### 反转链表

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/?envType=study-plan-v2&envId=programming-skills)

>依旧递归，优雅

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        ListNode newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
}
```

>常规写法，画一下就好理解了

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode next = head;
        ListNode result = null;
        while(next != null){
            ListNode temp=next.next;
            next.next=result;
            result = next;
            next=temp;
        }
        return result;
    }
}
```

#### 两数相加

[2. 两数相加 - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers/description/?envType=study-plan-v2&envId=programming-skills)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode(0);
        int carry = 0;
        ListNode ne = dummy;
        while(l1 != null || l2 != null){
            int l1val = l1==null ? 0 : l1.val;
            int l2val = l2==null ? 0 : l2.val;
            int sum = l1val + l2val + carry;

            ne.next = new ListNode(sum%10);
            ne=ne.next;
            carry = sum/10;

            if(l1 != null) l1=l1.next; 
            if(l2 != null) l2=l2.next; 
        }
        if(carry!=0) ne.next = new ListNode(carry);
        return dummy.next;
    }
}
```

#### 两数相加II

[445. 两数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/add-two-numbers-ii/description/?envType=study-plan-v2&envId=programming-skills)

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1 = rever(l1);
        l2 = rever(l2);
        ListNode dummy = new ListNode(0);
        int carry = 0;
        ListNode ne = dummy;
        while(l1 != null || l2 != null){
            int l1val = l1==null ? 0 : l1.val;
            int l2val = l2==null ? 0 : l2.val;
            int sum = l1val + l2val + carry;

            ne.next = new ListNode(sum%10);
            ne=ne.next;
            carry = sum/10;

            if(l1 != null) l1=l1.next; 
            if(l2 != null) l2=l2.next; 
        }
        if(carry!=0) ne.next = new ListNode(carry);
        return rever(dummy.next);
    }
    public ListNode rever(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode revered = rever(head.next);
        head.next.next = head;
        head.next = null;
        return revered;
    }
}
```















