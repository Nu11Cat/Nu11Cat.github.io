---
title : 2.高并发设计题
---

------

**问：设计一个支持高并发秒杀活动的系统，核心挑战有哪些？**

答：设计高并发秒杀系统的核心挑战包括：

- **流量突发**：秒杀活动短时间内涌入大量用户请求，可能导致系统宕机。
- **库存超卖**：并发下多个用户同时抢购，可能导致数据库中库存为负。
- **请求重复**：同一个用户多次请求、刷脚本，可能破坏公平性。
- **数据一致性**：高并发情况下保证订单、库存等数据的一致性。
- **性能瓶颈**：数据库、缓存、消息队列等组件容易成为瓶颈。

常见解决策略：

- 接入层限流（如令牌桶、漏桶、Nginx 限流模块）+ CDN 静态缓存。
- 使用 Redis 预减库存，避免数据库写压力。
- 加入消息队列削峰（如 Kafka、RabbitMQ）。
- 异步订单写库，前端快速响应秒杀成功/失败。
- 数据层加事务、乐观锁或分布式锁保证一致性。

------

**问：如何设计一个高并发的订单系统？**

答：高并发订单系统设计应关注以下方面：

- **系统拆分**：采用微服务架构，订单、库存、支付、用户等服务独立部署。
- **异步架构**：下单请求入队，通过消息队列异步处理订单写库。
- **缓存预热**：热点商品信息提前加载到 Redis，减轻数据库查询压力。
- **数据库优化**：订单表使用分库分表策略；通过雪花算法等生成全局唯一订单号。
- **幂等性控制**：使用幂等键防止重复下单或重复支付。
- **事务控制**：本地事务结合最终一致性方案（如本地消息表 + MQ）或使用 TCC/Saga 模式处理分布式事务。

------

**问：如何判断系统是否能够承受某一并发量？**

答：判断系统的并发能力需借助性能测试工具（如 JMeter、Locust、wrk）进行压测，重点关注以下指标：

- **QPS（每秒查询数）**：系统单位时间内可处理请求的能力。
- **TPS（每秒事务数）**：单位时间内成功处理的事务数量。
- **响应时间（RT）**：请求从发送到接收响应的时间。
- **系统资源利用率**：包括 CPU、内存、磁盘 I/O、网络等。
- **错误率**：请求失败的比例，反映系统在高并发下的稳定性。

测试结果与目标并发数对比，结合瓶颈分析，决定系统是否具备目标承载能力。

------

**问：如何应对高并发下的缓存击穿、缓存雪崩、缓存穿透？**

答：

- **缓存击穿**：热点 Key 失效，导致大量请求打到数据库。
  - 解决：热点 Key 设置永不过期 + 加互斥锁 + 使用多级缓存。
- **缓存雪崩**：大量 Key 同时过期，缓存层失效，数据库压力暴涨。
  - 解决：给不同 Key 设置随机过期时间；增加缓存预热、请求排队。
- **缓存穿透**：请求访问不存在的数据，缓存和数据库均未命中。
  - 解决：对空值设置短期缓存；加入布隆过滤器提前拦截非法请求。

------

**问：如何通过架构手段提升系统并发处理能力？**

答：

- **异步化**：使用消息队列解耦系统组件，削峰填谷。
- **读写分离**：将数据库读请求转发至从库，减轻主库压力。
- **缓存优化**：用 Redis/Memcached 缓存热点数据，提升响应速度。
- **数据库分库分表**：水平扩展数据库以支撑大数据量、高并发。
- **服务拆分与部署隔离**：微服务部署在独立机器，防止故障蔓延。
- **限流降级熔断**：保障系统核心服务可用性，避免全盘雪崩。

------

**问：高并发系统中如何保证数据一致性？**

答：高并发下保证数据一致性的常用手段包括：

- **乐观锁**：版本号或时间戳控制，避免冲突写入。
- **悲观锁**：确保资源被一个线程独占使用，但性能较低。
- **分布式锁**：如 Redis + Lua 或 Zookeeper 锁，协调跨服务并发访问。
- **最终一致性**：如使用消息队列 + 补偿机制处理跨服务的数据一致。
- **幂等性设计**：避免重复请求导致脏数据。

------

**问：如何实现服务的水平扩展？**

答：

- **无状态设计**：服务无状态可复制，使得任何实例都能处理请求。
- **配置中心**：实现服务间配置统一管理与动态刷新（如 Nacos、Apollo）。
- **服务注册与发现**：借助 Eureka、Consul、Zookeeper 动态感知服务实例变化。
- **负载均衡器**：如 Nginx、Ribbon、Gateway，根据策略分发请求。

------

**问：如何保证高并发系统的高可用性？**

答：

- **故障隔离**：单点故障不能影响全局，使用熔断器（如 Sentinel、Hystrix）。
- **自动恢复**：服务崩溃后自动重启，结合 K8s/容器编排保证自愈能力。
- **灰度发布**：系统更新时逐步替换实例，确保无中断。
- **服务降级**：部分功能在异常时返回兜底数据或提示，维持服务核心可用。

------

**问：高并发下如何优化数据库？**

答：

- 减少数据库访问：利用缓存/预计算。
- 合理设计索引：避免全表扫描。
- 拆表分库：以业务 ID、用户 ID 作为分片键。
- 使用异步写入 + 批量处理：提高吞吐量。
- 数据冷热分离：将冷数据归档到历史表，提升活跃数据访问效率。

------

