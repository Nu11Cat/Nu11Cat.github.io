import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as o,o as s}from"./app-BSH8uNnm.js";const r={};function n(p,a){return s(),e("div",null,a[0]||(a[0]=[o('<h2 id="jvm-字节码文件" tabindex="-1"><a class="header-anchor" href="#jvm-字节码文件"><span>JVM-----字节码文件</span></a></h2><p>JVM解释执行字节码的时候，首先通过类加载器classloader把.class文件加载到内存，生成对应的class对象，然后JVM将方法中的字节码逐条读取解析，经过JVM内部的解释器逐条解释字节码指令，每条字节码通过查表得到对应的本地机器指令，然后执行操作。在这个过程中JVM通过计数器判断是否为热点代码，被JIT编译成本地代码，加快后续执行。</p><p>需要强调的是:<strong>JVM 具备跨平台能力，但其实现是平台相关的</strong>。字节码的跨平台性源于规范统一，而将其解释/编译成哪种机器码，取决于你所安装的 JDK/JVM 的平台版本（如 Windows/Linux/ARM 等）。</p><blockquote><p>JVM 是跨平台的，靠的是统一的字节码规范；JVM的实现不是跨平台的，解释和编译成什么机器码取决于所用的 JDK 平台版本。</p></blockquote><h2 id="jvm-计数器" tabindex="-1"><a class="header-anchor" href="#jvm-计数器"><span>JVM-计数器</span></a></h2><h4 id="gc" tabindex="-1"><a class="header-anchor" href="#gc"><span>GC</span></a></h4><p>垃圾回收是自动管理内存的一部分，它的目的是释放堆内存中不再使用的对象。Java中的垃圾回收机制由JVM自动处理，开发者通常不需要手动释放内存。</p><p>垃圾回收算法有</p><p><strong>引用计数法</strong>：每个对象都有一个计数器，记录引用该对象的次数。</p><p><strong>可达性分析法</strong>：JVM采用的方式。通过根对象（GC Root）来追踪所有可以访问的对象。如果对象从GC Root出发无法访问到，就认为它不可达，可以被回收。</p><p><strong>标记-清除算法</strong>：首先标记所有可达的对象，然后清除所有未被标记的对象。</p><p><strong>复制算法</strong>：将堆内存划分为两块，使用一块，回收时将活动对象复制到另一块。优点是没有内存碎片，缺点是内存的使用效率较低，因为必须有两块内存。</p><p>常见的垃圾回收器有G1等</p>',13)]))}const m=t(r,[["render",n]]),J=JSON.parse('{"path":"/1.Note/1.Java%20_%20CS/JVM.html","title":"JVM","lang":"en-US","frontmatter":{"title":"JVM","order":5},"git":{"createdTime":1751031820000,"updatedTime":1751031820000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":1.74,"words":521},"filePathRelative":"1.Note/1.Java & CS/JVM.md"}');export{m as comp,J as data};
