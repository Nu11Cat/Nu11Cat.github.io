import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as n,o as t}from"./app-gkVmqSKC.js";const o={};function r(p,a){return t(),s("div",null,a[0]||(a[0]=[n('<h2 id="包装类型" tabindex="-1"><a class="header-anchor" href="#包装类型"><span>包装类型</span></a></h2><h4 id="包装类和基本数据类型的区别" tabindex="-1"><a class="header-anchor" href="#包装类和基本数据类型的区别"><span>包装类和基本数据类型的区别</span></a></h4><p>包装类型是java为每种基本数据类型提供的对应的类对象类型，让基本类型具备对象的特性。</p><p>基本类型是Java最原始的数据类型，不是对象，操作效率高，内存占用小，如果是局部变量一般存储在栈内存，但是如果是成员变量就存储在堆<code>/方法区/元空间(static修饰的静态变量)</code>。</p><p>包装类型是基本类型的类，是对象，可以用于集合，支持泛型，引用可能在栈中，实际存储在堆中，对于一些比如说Integer范围内的常量，JVM会缓存，也就是包装类型的缓存机制，存储在常量池或栈。</p><p>包装类型的缓存机制</p><p>JVM会将常见的重复使用的对象进行复用，避免每次都创建新的对象，提高性能，减少内存使用。</p><p>比如Integer，JVM会缓存<code>-128到127</code>的整数。调用<code>Integer.valueOf(int)</code>的时候，如果传入的整数在这个范围，JVM就返回一个已经创建好的共享对象，而不是在创建一个新的Integer对象。Boolean类型JVM只会缓存true和false两个值。</p><h4 id="自动装箱与拆箱" tabindex="-1"><a class="header-anchor" href="#自动装箱与拆箱"><span>自动装箱与拆箱</span></a></h4><p><strong>自动装箱</strong>是将基本数据类型转换为其对应的包装类的过程，<strong>拆箱</strong>则是将包装类转换为基本数据类型的过程。这两个过程是由编译器自动完成的。装箱的时候JVM调用包装类的构造方法或 <code>valueOf()</code> 方法，拆箱时会通过 <code>xxxValue()</code> 方法（如 <code>Integer.intValue()</code>）获取基本数据类型的值。另外包装类的缓存机制会避免重复创建对象，提升性能。</p><p>但是频繁的装箱可能会导致性能问题，因为如果你的基本数据类型的大小超过了缓存机制的界限，那么就会不断产生新的对象，增加垃圾回收的压力。</p><h2 id="浮点数精度丢失" tabindex="-1"><a class="header-anchor" href="#浮点数精度丢失"><span>浮点数精度丢失</span></a></h2><p>浮点数运算进度丢失是因为计算机二进制存储数字，但是有些小数不能在有限位数里转化成二进制，所以就需要截断，导致精度丢失</p><p>如何解决？</p><p>使用<code>BigDecimal</code>: 用字符串的形式存储小数位，以十进制方式精确表示每一位，适合做高精度运算，比如金额计算。</p><h2 id="string为什么不可变" tabindex="-1"><a class="header-anchor" href="#string为什么不可变"><span>String为什么不可变？</span></a></h2><p>首先在Java中，final修饰的引用数据类型不能再指向其他对象，而string的字段value底层存储数据的形式就是字符数组，这个数组被final修饰，并且还是私有的，其次string这个类本身也是被final修饰的，那么它就不能被继承，你就不能通过子类来修改，其次，<code>stringbuilder</code>和<code>stringbuffer</code>继承了<code>abstractstringbuilder</code>类，有append等修改字符串的方法，而string没有继承，自然也没有这种方法，这个原因也体现了<code>OOP</code>的封装特性，所以综上所述，string是不可修改的。</p><p>因为不可变性，<code>String</code> 是线程安全的，并且它可以作为常量存储在字符串池中，从而节省内存。</p><h2 id="和equals的区别" tabindex="-1"><a class="header-anchor" href="#和equals的区别"><span>==和equals的区别</span></a></h2><p>==是一个运算符，对于基本数据类型，表示对比值是否相等，对于引用数据类型，表示对比是否指向同一个对象，也就是在堆内存的内存地址是否相同</p><p>而equals是<code>Obejct</code>类的方法，默认实现就是<code>return this == obj</code>，也就是比较引用的地址，但是<code>Object</code>作为所有类的直接或间接的父类，有些标准类都是重写了<code>equals</code>方法的，比如<code>String</code>，<code>Integer</code>，用来比较对象的内容是否相等。</p><p>但是需要注意的一点是<code>Integer a = 127; Integer b = 127;</code> 比较时 <code>a == b</code> 为 <code>true</code>，因为 Java 会缓存 <code>-128</code> 到 <code>127</code> 之间的整数对象，也就是包装类的缓存机制。</p><h2 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字"><span>关键字</span></a></h2><h4 id="static" tabindex="-1"><a class="header-anchor" href="#static"><span>static</span></a></h4><p>在 Java 中，<code>static</code> 是一个非常基础的关键字，表示“静态的”，意思就是这个东西不依赖于对象，而是属于类本身。可以修饰静态变量，静态方法，静态代码块，静态内部类，接口的static方法（8+），接口中的变量默认都是static final的。</p><p><strong>在类中</strong>，<code>static</code> 方法是属于类的，可以通过类名直接调用，不需要实例化对象，也<strong>不能被重写</strong>，因为它不属于实例，不参与多态。</p><p><strong>在接口中（Java 8+）</strong>，允许定义 <code>static</code> 方法，<strong>只能通过接口名调用，不能被实现类继承或重写</strong>，这主要是为了给接口提供一些工具方法。</p><h4 id="final" tabindex="-1"><a class="header-anchor" href="#final"><span>final</span></a></h4><p><code>final</code> 这个关键字在 Java 里主要是用来限制“修改”的，可以修饰变量、方法和类</p><p>如果修饰变量，基本数据类型就表示值不能再变了，引用数据类型表示这个引用不能再指向别的对象。</p><p>如果修饰方法，表示它不能被子类重写。</p><p>如果修饰类，表示不能被继承。</p><h4 id="static-final" tabindex="-1"><a class="header-anchor" href="#static-final"><span>static final</span></a></h4><p>组合在一起使用时表示这个变量是<strong>全局常量</strong>，在整个程序中只存在一份，值不能修改，是一种<strong>线程安全、全局唯一的只读变量</strong>。</p><h2 id="构造代码块vs构造方法" tabindex="-1"><a class="header-anchor" href="#构造代码块vs构造方法"><span>构造代码块vs构造方法</span></a></h2><p>构造代码块是写在类中、没有方法名、没有修饰符的代码块。它在每次创建对象时都会执行，并且<strong>优先于构造方法执行</strong>。</p><p>构造方法用于创建对象时初始化，名字与类名相同，可以有多个重载版本。</p><h2 id="构造代码块vs静态代码块" tabindex="-1"><a class="header-anchor" href="#构造代码块vs静态代码块"><span>构造代码块vs静态代码块</span></a></h2><p>构造代码块在每次创建对象前都会执行，提取多个构造方法的共同行为，减少代码重复</p><p>静态代码块是在 Java 类中用 <code>static {}</code> 包裹的一段代码。<strong>它在类加载时执行，并且只执行一次</strong>，不管你创建了多少个对象。</p><h2 id="jmm-vs-jvm" tabindex="-1"><a class="header-anchor" href="#jmm-vs-jvm"><span>JMM vs JVM</span></a></h2><p><strong>JVM</strong> 是一个具体的虚拟机，它负责在特定的硬件和操作系统上运行 Java 程序。它包括内存管理、垃圾回收、执行字节码等多个方面。</p><p><strong>JMM</strong> 是 Java 语言的内存模型规范，它并不具体描述实现，而是提供了多线程编程中如何访问共享变量的规范，主要目的是确保并发编程中的线程安全。MM 主要定义了 <strong>内存可见性</strong>、<strong>原子性</strong> 和 <strong>有序性</strong> 三个方面的规则。</p><h4 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h4><p>类加载是指 Java 程序在运行过程中，<strong>把 .class 文件加载到 JVM 中，并转化为 Class 对象的过程</strong>。</p><p>加载：JVM 通过类的全限定名查找 <code>.class</code> 文件，把它的字节码读取进内存，并创建一个 <code>Class</code> 对象。</p><p>验证：这一步是为了安全，检查这个字节码文件是否合法，比如语法结构、常量池是否合法、防止字节码被篡改等。</p><p>准备：这个阶段会为类的<strong>静态变量</strong>分配内存，并设置默认值，比如 <code>int</code> 是 0，<code>boolean</code> 是 false。</p><p>解析：把类中的符号引用（就是类似类名、字段名这种字符串）替换为真正的地址引用（也就是指向内存的引用）。</p><p>初始化：这一步才是真正执行代码，比如执行 <code>static</code> 代码块，或者静态变量的赋值操作，这些代码只会执行一次。</p><p>Java 类加载器采用的是<strong>双亲委派模型</strong>，意思是：<strong>一个类加载器在加载某个类时，先把请求交给它的父加载器，父加载器找不到，才由自己来加载</strong>。有两个好处，应该是避免重复加载，另一个是保证核心类的优先级。</p><h4 id="对象创建的过程" tabindex="-1"><a class="header-anchor" href="#对象创建的过程"><span>对象创建的过程</span></a></h4><p>当new一个对象的时候，JVM首先判断类是否已经加载，如果没有就加载，如果已经加载了，那么就会在 <strong>堆内存</strong> 中为这个对象分配内存，分配好内存后，JVM 会先对这块内存做默认初始化，比如 int 是 0，引用是 null 等，接下来会准备好 this 指针，把它绑定到刚才分配的那块内存上，进程初始化，执行父类的非静态变量和代码块、父类构造器、子类的非静态变量和代码块、子类构造器。最后返回这个对象在堆的引用。</p><h4 id="gc" tabindex="-1"><a class="header-anchor" href="#gc"><span>GC</span></a></h4><p>垃圾回收是自动管理内存的一部分，它的目的是释放堆内存中不再使用的对象。Java中的垃圾回收机制由JVM自动处理，开发者通常不需要手动释放内存。</p><p>垃圾回收算法有</p><p><strong>引用计数法</strong>：每个对象都有一个计数器，记录引用该对象的次数。</p><p><strong>可达性分析法</strong>：JVM采用的方式。通过根对象（GC Root）来追踪所有可以访问的对象。如果对象从GC Root出发无法访问到，就认为它不可达，可以被回收。</p><p><strong>标记-清除算法</strong>：首先标记所有可达的对象，然后清除所有未被标记的对象。</p><p><strong>复制算法</strong>：将堆内存划分为两块，使用一块，回收时将活动对象复制到另一块。优点是没有内存碎片，缺点是内存的使用效率较低，因为必须有两块内存。</p><p>常见的垃圾回收器有G1等</p><h2 id="值传递vs引用传递" tabindex="-1"><a class="header-anchor" href="#值传递vs引用传递"><span>值传递vs引用传递</span></a></h2><p>Java 是值传递</p><p><strong>方法调用时，传递的是变量中存储的值的副本</strong>，而不是变量本身。</p><p>基本类型：传的是值的拷贝，方法里怎么改都不会影响原来的。</p><p>引用类型：传的是引用地址的拷贝，能通过这个地址修改对象的内容，但不能改原来的引用指向。</p>',66)]))}const i=e(o,[["render",r]]),h=JSON.parse('{"path":"/2.%E9%9D%A2%E8%AF%95%E7%AF%87/2.%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/Java%E5%9F%BA%E7%A1%80.html","title":"Java基础","lang":"en-US","frontmatter":{"title":"Java基础"},"git":{"createdTime":1749044926000,"updatedTime":1749044926000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":8.42,"words":2527},"filePathRelative":"2.面试篇/2.八股笔记/Java基础.md"}');export{i as comp,h as data};
