import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as e,o as r}from"./app-YGZAb0r2.js";const o={};function t(i,a){return r(),n("div",null,a[0]||(a[0]=[e(`<p>HotSpot 虚拟机：</p><h1 id="运行时内存" tabindex="-1"><a class="header-anchor" href="#运行时内存"><span>运行时内存</span></a></h1><p>在 Java 程序运行过程中，JVM 会将内存划分为若干个区域，用于管理类的加载、对象的创建与销毁、线程执行等行为，这些区域统称为 <strong>运行时内存区域</strong>，或者叫 <strong>JVM 内存模型</strong>。</p><h2 id="程序计数器" tabindex="-1"><a class="header-anchor" href="#程序计数器"><span>程序计数器</span></a></h2><p>表示当前线程正在执行的字节码行号指示器。它记录了线程执行位置，是线程切换后能恢复到正确执行位置的关键。</p><p>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，是线程私有的。</p><p>程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h2 id="虚拟机栈" tabindex="-1"><a class="header-anchor" href="#虚拟机栈"><span>虚拟机栈</span></a></h2><p>用于存储每个线程执行方法时所需的局部变量、操作数栈、动态链接信息等。</p><p>Java 虚拟机栈（后文简称栈）也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>除了一些 Native 方法调用是通过本地方法栈实现的，其他所有的 Java 方法调用都是通过栈来实现的（也需要和其他运行时数据区域比如程序计数器配合）。</p><p><strong>栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</strong></p><p>每个方法在执行时会创建一个栈帧（Stack Frame）；栈帧中包括局部变量表、操作数栈、方法返回地址等；如果线程请求栈的深度超过限制（如陷入无限循环），会抛出 <code>StackOverflowError</code>；当虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</p><blockquote><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）</p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。另外，计算过程中产生的临时变量也会放在操作数栈中。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。Class 文件的常量池里保存有大量的符号引用比如方法引用的符号引用。当一个方法要调用其他方法，需要将常量池中指向方法的符号引用转化为其在内存地址中的直接引用。动态链接的作用就是为了将符号引用转换为调用方法的直接引用，这个过程也被称为 <strong>动态连接</strong> 。</p></blockquote><h2 id="本地方法栈" tabindex="-1"><a class="header-anchor" href="#本地方法栈"><span>本地方法栈</span></a></h2><p>与虚拟机栈类似，只不过它是为本地方法（如 C/C++ 编写的 native 方法）服务的。</p><p>在 HotSpot 虚拟机中本地方法栈和 Java 虚拟机栈是合二为一的。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</p><h2 id="堆" tabindex="-1"><a class="header-anchor" href="#堆"><span>堆</span></a></h2><p>是所有线程共享的一块内存区域，用于存放对象实例，是垃圾回收器管理的重点区域。生命周期和 JVM 一致。</p><p>从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden、Survivor、Old 等空间。进一步划分的目的是更好地回收内存，或者更快地分配内存。</p><p>如果方法区空间不足，会抛出 <code>OutOfMemoryError</code>。</p><p><strong>在 JDK 7 版本及 JDK 7 版本之前</strong></p><p>堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p><strong>JDK 8 版本之后</strong></p><p>PermGen(永久代) 已被 Metaspace(元空间) 取代，元空间使用的是本地内存。</p><p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 S0 或者 S1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><p><strong>为什么年龄只能是 0-15?</strong></p><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p><h2 id="方法区" tabindex="-1"><a class="header-anchor" href="#方法区"><span>方法区</span></a></h2><p>也是线程共享的，主要存放已被虚拟机加载的类信息、常量、静态变量、JIT 编译后的代码等。</p><p><strong>方法区和永久代以及元空间是什么关系呢？为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><p>在 HotSpot 虚拟机中，早期是通过“永久代”（PermGen）来实现方法区的。也就是说，在 Java 8 之前，方法区的实现依赖于 JVM 内部的一块固定大小的内存区域，即永久代。类的元数据、运行时常量池、静态变量等信息都会存放在永久代中。但由于永久代的容量固定，且难以调优，容易出现内存溢出（比如类加载过多时抛出 OutOfMemoryError: PermGen space），所以这种实现方式在实践中存在一些问题。</p><p>从 Java 8 开始，HotSpot 虚拟机移除了永久代，引入了新的实现方式叫做“元空间”（Metaspace）。元空间与永久代最大的不同是，它并不再使用 JVM 的内存，而是使用本地内存（也就是堆外内存）。这种设计提升了灵活性，也降低了内存溢出的风险。元空间的大小可以通过参数进行配置，比如 <code>-XX:MetaspaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code>。此外，元空间对类元数据的回收更友好，有助于避免类加载器造成的内存泄漏问题。</p><p><strong>方法区常用参数有哪些？</strong></p><p>JDK 1.8 之前</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">PermSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">N </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//方法区 (永久代) 初始大小</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">MaxPermSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">N </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>JDK 1.8 的时候</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">MetaspaceSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">N </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//设置 Metaspace 的初始（和最小大小）</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">-</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">XX</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">:</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">MaxMetaspaceSize</span><span style="--shiki-light:#383A42;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">N </span><span style="--shiki-light:#A0A1A7;--shiki-light-font-style:italic;--shiki-dark:#7F848E;--shiki-dark-font-style:italic;">//设置 Metaspace 的最大大小</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="运行时常量池" tabindex="-1"><a class="header-anchor" href="#运行时常量池"><span>运行时常量池</span></a></h2><p>用于存放编译期生成的各种字面量和符号引用，在类加载后被存入此区域。</p><p>字面量是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量。常见的符号引用包括类符号引用、字段符号引用、方法符号引用、接口方法符号。</p><p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 <code>OutOfMemoryError</code> 错误。</p><h2 id="字符串常量池" tabindex="-1"><a class="header-anchor" href="#字符串常量池"><span>字符串常量池</span></a></h2><p>字符串常量池是 JVM 为了优化内存而设计的一块特殊区域，用于存放字符串字面量。当我们使用双引号创建字符串时，JVM 会先在常量池中查找，若存在相同内容，则复用已有对象，避免重复创建，提升性能。</p><p>这个机制依赖于字符串的不可变性，确保共享是安全的。如果通过 <code>new</code> 关键字创建字符串，不会自动进入常量池，除非显式调用 <code>intern()</code> 方法。</p><p>在实现上，JDK 1.6 及之前，字符串常量池位于方法区的永久代中；从 JDK 1.7 起移至堆中；JDK 1.8 起随着元空间引入，完全脱离永久代，由堆中的 <code>StringTable</code> 管理。<code>StringTable</code> 本质上是一个固定大小的哈希表，保存字符串内容与其对象引用的映射关系。</p><p>这个机制常用于提高字符串重复使用场景下的内存利用率，但也要注意池容量有限，避免滥用 <code>intern()</code> 导致性能问题或内存泄漏。</p><h1 id="对象和类" tabindex="-1"><a class="header-anchor" href="#对象和类"><span>对象和类</span></a></h1><h2 id="对象" tabindex="-1"><a class="header-anchor" href="#对象"><span>对象</span></a></h2><h3 id="对象的创建过程" tabindex="-1"><a class="header-anchor" href="#对象的创建过程"><span>对象的创建过程</span></a></h3><h4 id="类加载检查" tabindex="-1"><a class="header-anchor" href="#类加载检查"><span>类加载检查</span></a></h4><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><h4 id="分配内存" tabindex="-1"><a class="header-anchor" href="#分配内存"><span>分配内存</span></a></h4><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式</strong> （补充内容，需要掌握）：</p><ul><li>指针碰撞： <ul><li>适用场合：堆内存规整（即没有内存碎片）的情况下。</li><li>原理：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表： <ul><li>适用场合：堆内存不规整的情况下。</li><li>原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是&quot;标记-清除&quot;，还是&quot;标记-整理&quot;（也称作&quot;标记-压缩&quot;），值得注意的是，复制算法内存也是规整的。</p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li></ul><h4 id="初始化零值" tabindex="-1"><a class="header-anchor" href="#初始化零值"><span>初始化零值</span></a></h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="设置对象头" tabindex="-1"><a class="header-anchor" href="#设置对象头"><span>设置对象头</span></a></h4><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h4 id="执行-init-方法" tabindex="-1"><a class="header-anchor" href="#执行-init-方法"><span>执行 init 方法</span></a></h4><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象在内存中的布局" tabindex="-1"><a class="header-anchor" href="#对象在内存中的布局"><span>对象在内存中的布局</span></a></h3><p>对象在内存中的布局可以分为 3 块区域：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）**和**对齐填充（Padding）</strong>。</p><p>对象头包括两部分信息：</p><ol><li>标记字段（Mark Word）：用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。</li><li>类型指针（Klass pointer）：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</li></ol><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位" tabindex="-1"><a class="header-anchor" href="#对象的访问定位"><span>对象的访问定位</span></a></h3><p>对象的访问方式由虚拟机实现而定，目前主流的访问方式有：<strong>使用句柄</strong>、<strong>直接指针</strong>。</p><p>首先是<strong>句柄访问方式</strong>。在这种方式下，JVM 会为每个对象分配一个<strong>句柄池区域</strong>，每个对象的引用指向句柄，而句柄中保存着对象实例数据和对象类型元数据的地址。这样，对象的访问是“引用 → 句柄 → 对象”。它的好处是，当对象在内存中移动时，只需要更新句柄中的地址，不需要修改所有引用，适合频繁移动对象的 GC 策略。</p><p>另一种是<strong>直接指针访问方式</strong>。在这种方式下，引用中直接保存的是对象在堆内的地址，对象头中则保存了类元数据的指针。这种方式访问速度更快，因为省略了中间的句柄查找，但缺点是对象一旦移动，需要更新所有指向它的引用。</p><hr><p>HotSpot 虚拟机默认采用的是<strong>直接指针方式</strong>，因为它在现代 CPU 上性能更优。而句柄方式在某些 JVM 或自定义场景中仍有使用，尤其是在对象频繁移动的系统中。</p><h2 id="类" tabindex="-1"><a class="header-anchor" href="#类"><span>类</span></a></h2><h1 id="垃圾回收" tabindex="-1"><a class="header-anchor" href="#垃圾回收"><span>垃圾回收</span></a></h1><h2 id="内存分配" tabindex="-1"><a class="header-anchor" href="#内存分配"><span>内存分配</span></a></h2><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>新创建的大多数普通对象，默认会<strong>首先分配在新生代的 Eden 区</strong>。这是 HotSpot 虚拟机基于“绝大多数对象生命周期短暂”的假设做出的设计，配合 Minor GC 可以快速清理。</p><p>所谓“大对象”通常是指需要占用<strong>大量连续内存空间</strong>的对象，比如大数组或大字符串。为了避免在新生代频繁复制、移动带来的性能开销，<strong>虚拟机会将大对象直接分配到老年代</strong>。</p><p>在新生代经过多次 Minor GC 后，如果某个对象仍然存活，并且其“年龄”达到一定阈值（默认是 15，可以通过 <code>-XX:MaxTenuringThreshold</code> 设置），那么 JVM 会认为它是长期存活对象，<strong>将其晋升到老年代</strong>。此外，如果 Survivor 区空间不足，JVM 也可能提前将部分对象晋升。</p><blockquote><p><strong>为什么年龄只能是 0-15?</strong></p><p>因为记录年龄的区域在对象头中，这个区域的大小通常是 4 位。这 4 位可以表示的最大二进制数字是 1111，即十进制的 15。因此，对象的年龄被限制为 0 到 15。</p></blockquote><h2 id="分类" tabindex="-1"><a class="header-anchor" href="#分类"><span>分类</span></a></h2><p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p><p>部分收集 (Partial GC)：</p><ul><li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li><li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h2 id="空间分配担保" tabindex="-1"><a class="header-anchor" href="#空间分配担保"><span>空间分配担保</span></a></h2><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>在 Java 的分代垃圾回收中，当新生代（尤其是 Eden 区）满了之后，会触发 Minor GC。此时，新生代中仍存活的对象会被转移到 Survivor 区或老年代。但如果 Survivor 区空间不足，或者对象年龄较高、直接晋升老年代的对象较多，就需要确保老年代有足够的空间接收这些对象。</p><p><strong>空间分配担保的核心作用</strong>就是：<strong>在 Minor GC 前，JVM 会检查老年代是否有足够的空间容纳所有新生代中可能晋升的对象</strong>。如果空间不足，JVM 会提前触发一次 Full GC 来尝试回收老年代空间，避免后续 Minor GC 时出现“无法晋升”的风险。</p><hr><p>这个机制是为了<strong>担保 Minor GC 的安全性</strong>，确保存活对象总有地方可去，从而避免 <code>OutOfMemoryError</code> 或 GC 崩溃。</p><h2 id="判断对象死亡" tabindex="-1"><a class="header-anchor" href="#判断对象死亡"><span>判断对象死亡</span></a></h2><h3 id="引用计数法" tabindex="-1"><a class="header-anchor" href="#引用计数法"><span>引用计数法</span></a></h3><p>引用计数法是一种简单的垃圾回收判定策略，它的核心思想是：<strong>给每个对象维护一个引用计数器，每当有一个地方引用它时，计数加一；引用失效时，计数减一；当计数为零时，说明对象已经不再被使用，可以被回收。</strong></p><p>这种方法实现简单，效率较高，但存在一个致命缺陷：<strong>无法处理循环引用</strong>。例如两个对象相互引用，即使它们都无法被外部访问，计数器也不会为零，导致内存泄漏。</p><p>正因为这个问题，<strong>Java 的 HotSpot 虚拟机并没有采用引用计数法</strong>来判断对象是否可回收，而是使用<strong>可达性分析算法（GC Root Tracing）</strong>，通过一系列“GC 根对象”作为起点，从根出发可达的对象视为“存活”，不可达的对象才会被判定为死亡。</p><h3 id="可达性分析算法" tabindex="-1"><a class="header-anchor" href="#可达性分析算法"><span>可达性分析算法</span></a></h3><p>核心思想是<strong>从一组被称为 GC Roots 的对象出发，沿着对象引用链进行搜索</strong>，凡是能从 GC Roots 直接或间接到达的对象，都是“可达”的，表示还在使用中，不可回收；而无法被访问到的对象，则被判定为“不可达”，可以被回收。</p><p><strong>哪些对象可以作为 GC Roots 呢？</strong></p><ul><li>虚拟机栈(栈帧中的局部变量表)中引用的对象</li><li>本地方法栈(Native 方法)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>所有被同步锁持有的对象</li><li>JNI（Java Native Interface）引用的对象</li></ul><p><strong>被认定为不可达的对象，并不一定立刻死亡</strong></p><p>在 Java 中，即使一个对象通过可达性分析被判断为“不可达”，它也<strong>不一定立即被回收</strong>，因为 JVM 会给予它一次“<strong>自我拯救的机会</strong>”。</p><p>如果一个对象覆盖了它的 <code>finalize()</code> 方法，那么在第一次标记为不可达之后，JVM 会将其放入一个“F-Queue”中，并在稍后单独执行它的 <code>finalize()</code> 方法。这个方法中如果让该对象重新与 GC Roots 建立关联（例如将自己赋值给某个静态变量），那么它会<strong>被“复活”</strong>，不会被回收。</p><p>这种机制称为**“对象的第二次标记确认”**。如果执行 <code>finalize()</code> 后对象仍不可达，或者根本没有重写该方法，那么在第二次标记中它就会被真正判定为死亡，从而进入回收流程。</p><p>不过需要注意的是，<code>finalize()</code> 方法的执行具有不确定性、可能导致性能问题或资源泄漏，因此从 Java 9 开始它已被标记为过时，不推荐使用。</p><h2 id="判断常量废弃" tabindex="-1"><a class="header-anchor" href="#判断常量废弃"><span>判断常量废弃</span></a></h2><p>在 Java 的运行时常量池中，所谓的<strong>废弃常量</strong>是指：<strong>不再被任何对象引用的常量项</strong></p><p>判断一个常量是否是废弃常量，主要依据是可达性分析。如果一个运行时常量池中的常量（如字符串常量）不再被任何对象引用，也就是从 GC Roots 无法访问到它，那么它就会被视为不可达，属于“废弃常量”。</p><h2 id="判断类无用" tabindex="-1"><a class="header-anchor" href="#判断类无用"><span>判断类无用</span></a></h2><p>VM 在判断一个类是否无用、可以卸载时，主要满足以下三个条件：</p><p><strong>第一，类的所有实例都已经被回收。</strong> 也就是说，堆中已经不存在任何这个类的对象实例。如果还有对象在使用这个类，类就必须保留。</p><p><strong>第二，类对应的 <code>Class</code> 对象本身也不可达。</strong> 也就是这个 <code>java.lang.Class</code> 对象没有被任何地方引用，包括反射等场景中不能有强引用指向它。</p><p><strong>第三，加载这个类的类加载器也已经被回收。</strong> 只有当类加载器本身不可达时，它加载的所有类才可能被卸载。因为 JVM 是以“类加载器为单位”来回收类的。</p><p>只有当这三个条件<strong>同时满足</strong>时，JVM 才会认定该类是无用类，并在合适的时机将其卸载，释放方法区中的元数据和相关资源。</p><h2 id="垃圾收集算法" tabindex="-1"><a class="header-anchor" href="#垃圾收集算法"><span>垃圾收集算法</span></a></h2><h3 id="标记-清除算法" tabindex="-1"><a class="header-anchor" href="#标记-清除算法"><span>标记-清除算法</span></a></h3><p>标记-清除（Mark-Sweep）算法是最早期、也是最基础的垃圾收集算法之一，后续的算法都是对其不足进行改进得到。它的核心思想是将垃圾回收分为两个阶段：<strong>标记</strong> 和 <strong>清除</strong>。</p><p>首先，在<strong>标记阶段</strong>，GC 从 GC Roots（如栈帧中的局部变量、静态引用等）出发，沿着对象引用链进行遍历，<strong>把所有能访问到的对象标记为“存活”</strong>。这个过程通常通过可达性分析实现。</p><p>接下来是<strong>清除阶段</strong>，JVM 扫描整个堆，把<strong>那些没有被标记的对象（即不可达对象）进行回收</strong>，释放它们占用的内存空间。</p><p>这个算法的优点是实现简单，适合对象存活率较高的场景，而且不需要移动对象，回收过程直观。但它的缺点也很明显：</p><p>第一，<strong>容易产生大量的内存碎片</strong>。因为清除阶段只是单纯地将“死对象”移除，而不会整理堆中存活对象的位置，导致空闲内存是非连续的，后续如果需要分配大对象时，可能会因为没有足够的连续空间而触发 Full GC。</p><p>第二，<strong>回收效率不高</strong>。标记和清除都需要遍历整个堆，时间开销较大，且不能并发，容易造成应用停顿（Stop The World）。</p><p>第三，它也<strong>不适合新生代回收</strong>，因为新生代中对象大多生命周期短暂，频繁创建销毁，复制算法更高效。标记-清除更适用于老年代，但在现代 JVM 中也被更先进的标记-整理或增量式、并发式 GC 所取代。</p><h3 id="复制算法" tabindex="-1"><a class="header-anchor" href="#复制算法"><span>复制算法</span></a></h3><p>复制（Copying）算法是一种经典的垃圾回收策略，主要用于<strong>新生代垃圾回收</strong>。它的核心思想是：<strong>将内存划分为两个大小相等的区域，每次只使用其中一块，当这块用满时，将存活对象复制到另一块空间，然后一次性清理整块内存。</strong></p><p>具体来说，在 Java 的新生代中，通常将 Eden 区和两个 Survivor 区组成复制结构。大部分对象先在 Eden 区分配，当发生 Minor GC 时，<strong>JVM 会将 Eden 和其中一个 Survivor 区中仍然存活的对象复制到另一个 Survivor 区中</strong>，清空 Eden 和原来的 Survivor 区。对象经过多次复制后，如果仍然存活，并达到一定“年龄”，会晋升到老年代。</p><p>复制算法相比于标记-清除的主要优点有两个：</p><ol><li><strong>回收效率高</strong>：每次只处理少量存活对象，且只遍历活的对象，适合“朝生夕死”的新生代特性。</li><li><strong>不会产生内存碎片</strong>：因为是整体复制到连续空间，分配新对象时只需指针递增（Bump-the-pointer），速度非常快。</li></ol><p>但它的缺点也很明显：<strong>浪费内存</strong>。因为总是只用一半空间，另一半是空闲的，等着接收复制过来的对象，导致内存利用率低。</p><h3 id="标记-整理算法" tabindex="-1"><a class="header-anchor" href="#标记-整理算法"><span>标记-整理算法</span></a></h3><p>标记-整理（Mark-Compact）算法是在标记-清除算法的基础上优化而来的，它的目标是<strong>解决内存碎片问题</strong>。</p><p>这个算法同样分为两个主要阶段：<strong>标记</strong>和<strong>整理</strong>。</p><p>首先是标记阶段，JVM 从 GC Roots 出发，遍历对象引用链，<strong>标记所有存活的对象</strong>。这个过程与标记-清除算法相同。</p><p>但在整理阶段，不再是简单地清除死亡对象，而是<strong>将所有存活的对象向内存的一端压缩移动</strong>，然后直接清理边界以外的内存空间。这样可以让堆内的可用空间保持<strong>连续</strong>，从而避免了内存碎片，提高后续对象分配的效率。</p><p>标记-整理算法的优点在于：</p><ol><li><strong>不会产生碎片</strong>，对象整理后连续存放；</li><li><strong>适合老年代</strong>，因为老年代中对象存活率较高，用复制算法会浪费大量复制成本；</li><li><strong>可支持大对象分配</strong>，因为不会出现“有足够空间但不连续”的问题。</li></ol><p>它的缺点是：整理时需要移动对象，还要更新所有引用位置，<strong>开销较大，且需要 Stop The World</strong>，所以在延迟敏感的场景中可能会引发性能抖动。</p><h3 id="分代收集算法" tabindex="-1"><a class="header-anchor" href="#分代收集算法"><span>分代收集算法</span></a></h3><p>当前虚拟机的垃圾收集都采用分代收集算法</p><p>分代收集算法（Generational Collection）是 Java 垃圾回收机制的核心思想之一，它基于一个重要观察：<strong>绝大多数对象“朝生夕死”，少数对象生命周期较长</strong>。因此，JVM 将堆内存划分为不同的“代”，针对每一代对象的特点，采用不同的垃圾回收策略，从而<strong>提升回收效率，降低系统停顿时间</strong>。</p><p>通常，堆被划分为以下三部分：</p><ol><li><strong>新生代（Young Generation）</strong>：用于存放新创建的对象。这里对象存活率低，适合采用<strong>复制算法</strong>进行高效回收，通常在 Minor GC 时触发。</li><li><strong>老年代（Old Generation）</strong>：用于存放经过多次 GC 仍然存活的“长期对象”。这里对象存活率高，适合使用<strong>标记-清除或标记-整理算法</strong>，回收效率相对低，通常在 Full GC 或 Major GC 时触发。</li><li><strong>元空间（Metaspace）或方法区</strong>：用于存放类的元信息，不属于堆内存（从 JDK 8 起移至本地内存）。</li></ol><p>回收过程按代进行：</p><ul><li>新生代频繁回收，速度快，停顿短；</li><li>老年代不频繁回收，但每次回收耗时更长；</li><li>对象在新生代中经过多次 GC 后晋升到老年代。</li></ul><blockquote><p><strong>HotSpot 为什么要分为新生代和老年代</strong></p><p>HotSpot 虚拟机将堆划分为新生代和老年代，核心原因是不同生命周期的对象具有不同的存活特性，统一使用一种回收算法效率低下。分代后，JVM 可以针对不同区域采用最合适的回收策略，从而提升整体 GC 性能，减少停顿时间。</p></blockquote><h2 id="垃圾收集器" tabindex="-1"><a class="header-anchor" href="#垃圾收集器"><span>垃圾收集器</span></a></h2><p>.</p><h1 id="jvm参数" tabindex="-1"><a class="header-anchor" href="#jvm参数"><span>JVM参数</span></a></h1><h1 id="jvm调优" tabindex="-1"><a class="header-anchor" href="#jvm调优"><span>JVM调优</span></a></h1><h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h1><h2 id="直接内存" tabindex="-1"><a class="header-anchor" href="#直接内存"><span>直接内存</span></a></h2><p>直接内存是 JVM 之外的一块内存区域，由操作系统分配，<strong>不属于 Java 堆或方法区</strong>，但可以被 Java 程序访问。它常用于高性能 I/O 操作，是 NIO（New I/O）中的一个重要概念。</p><p>通过 <code>ByteBuffer.allocateDirect()</code> 创建的直接缓冲区，其底层内存不是在堆上分配，而是使用本地内存，由 JVM 通过 <code>Unsafe</code> 或 JNI 调用系统函数分配。这种方式减少了 Java 堆与内核 I/O 缓冲区之间的数据拷贝，提高了性能，尤其适用于频繁读写的大数据量场景。</p><p>直接内存的大小不受堆空间限制，但默认总量受 <code>-XX:MaxDirectMemorySize</code> 控制。如果未显式设置，该值通常与最大堆大小相等。由于这部分内存不受 GC 管控，如果使用不当，容易导致 <code>OutOfMemoryError: Direct buffer memory</code>。</p><h2 id="引用类型" tabindex="-1"><a class="header-anchor" href="#引用类型"><span>引用类型</span></a></h2><p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱），强引用就是 Java 中普通的对象，而软引用、弱引用、虚引用在 JDK 中定义的类分别是 <code>SoftReference</code>、<code>WeakReference</code>、<code>PhantomReference</code>。</p><p>首先是<strong>强引用</strong>，它是最常见的引用类型，比如 <code>Object obj = new Object()</code>。只要强引用还存在，GC 永远不会回收对应的对象，哪怕内存紧张也不会。</p><p>其次是<strong>软引用（SoftReference）</strong>。当一个对象只有软引用指向它时，在内存充足时不会被回收；但当 JVM 判断内存不足时，会尽可能回收这些对象，用于缓存等场景比较合适。</p><p>第三是<strong>弱引用（WeakReference）</strong>。它比软引用更弱，一旦发生 GC，不管内存是否充足，只要对象只被弱引用关联，就会被立即回收，常用于 ThreadLocal 的 key、ThreadSafe caches 等。</p><p>最后是<strong>虚引用（PhantomReference）</strong>。它本身无法通过 <code>get()</code> 方法获取对象引用，唯一作用是配合 <code>ReferenceQueue</code> 追踪对象被 GC 回收的时机，用于底层资源释放或监控。对象一旦只被虚引用关联，下一次 GC 就会被回收。</p><hr><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</p><h2 id="jvm-字节码文件" tabindex="-1"><a class="header-anchor" href="#jvm-字节码文件"><span>JVM-----字节码文件</span></a></h2><p>JVM解释执行字节码的时候，首先通过类加载器classloader把.class文件加载到内存，生成对应的class对象，然后JVM将方法中的字节码逐条读取解析，经过JVM内部的解释器逐条解释字节码指令，每条字节码通过查表得到对应的本地机器指令，然后执行操作。在这个过程中JVM通过计数器判断是否为热点代码，被JIT编译成本地代码，加快后续执行。</p><p>需要强调的是:<strong>JVM 具备跨平台能力，但其实现是平台相关的</strong>。字节码的跨平台性源于规范统一，而将其解释/编译成哪种机器码，取决于你所安装的 JDK/JVM 的平台版本（如 Windows/Linux/ARM 等）。</p><blockquote><p>JVM 是跨平台的，靠的是统一的字节码规范；JVM的实现不是跨平台的，解释和编译成什么机器码取决于所用的 JDK 平台版本。</p></blockquote><h2 id="jvm-计数器" tabindex="-1"><a class="header-anchor" href="#jvm-计数器"><span>JVM-计数器</span></a></h2><h4 id="gc" tabindex="-1"><a class="header-anchor" href="#gc"><span>GC</span></a></h4><p>垃圾回收是自动管理内存的一部分，它的目的是释放堆内存中不再使用的对象。Java中的垃圾回收机制由JVM自动处理，开发者通常不需要手动释放内存。</p><p>垃圾回收算法有</p><p><strong>引用计数法</strong>：每个对象都有一个计数器，记录引用该对象的次数。</p><p><strong>可达性分析法</strong>：JVM采用的方式。通过根对象（GC Root）来追踪所有可以访问的对象。如果对象从GC Root出发无法访问到，就认为它不可达，可以被回收。</p><p><strong>标记-清除算法</strong>：首先标记所有可达的对象，然后清除所有未被标记的对象。</p><p><strong>复制算法</strong>：将堆内存划分为两块，使用一块，回收时将活动对象复制到另一块。优点是没有内存碎片，缺点是内存的使用效率较低，因为必须有两块内存。</p><p>常见的垃圾回收器有G1等</p>`,187)]))}const l=s(o,[["render",t]]),d=JSON.parse('{"path":"/1.Note/1.Java%20_%20CS/JVM.html","title":"JVM","lang":"en-US","frontmatter":{"title":"JVM","order":5},"git":{"createdTime":1752411078000,"updatedTime":1752411078000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":29.44,"words":8831},"filePathRelative":"1.Note/1.Java & CS/JVM.md"}');export{l as comp,d as data};
