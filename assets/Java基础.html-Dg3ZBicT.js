import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as n,o as r}from"./app-BIDAReXf.js";const i={};function s(p,a){return r(),t("div",null,a[0]||(a[0]=[n('<h2 id="包装类型" tabindex="-1"><a class="header-anchor" href="#包装类型"><span>包装类型</span></a></h2><p>包装类型是java为每种基本数据类型提供的对应的类对象类型，让基本类型具备对象的特性。</p><p>基本类型是Java最原始的数据类型，不是对象，操作效率高，内存占用小，如果是局部变量一般存储在栈内存，但是如果是成员变量就存储在堆<code>/方法区/元空间(static修饰的静态变量)</code>。</p><p>包装类型是基本类型的类，是对象，可以用于集合，支持泛型，主要存储在堆中，如果是局部变量，在栈上，如果是成员变量存储在堆，对于一些比如说Integer范围内的常量，JVM会缓存，也就是包装类型的缓存机制，存储在常量池或栈。</p><p>包装类型的缓存机制</p><p>JVM会将常见的重复使用的对象进行复用，避免每次都创建新的对象，提高性能，减少内存使用。</p><p>比如Integer，JVM会缓存<code>-128到127</code>的整数。调用<code>Integer.valueOf(int)</code>的时候，如果传入的整数在这个范围，JVM就返回一个已经创建好的共享对象，而不是在创建一个新的Integer对象。Boolean类型JVM只会缓存true和false两个值。</p><h2 id="浮点数精度丢失" tabindex="-1"><a class="header-anchor" href="#浮点数精度丢失"><span>浮点数精度丢失</span></a></h2><p>浮点数运算进度丢失是因为计算机二进制存储数字，但是有些小数不能在有限位数里转化成二进制，所以就需要截断，导致精度丢失</p><p>如何解决？</p><p>使用Big</p><h2 id="string为什么不可变" tabindex="-1"><a class="header-anchor" href="#string为什么不可变"><span>String为什么不可变？</span></a></h2><p>首先在java中，final修饰的引用数据类型不能再指向其他对象，而string的字段value底层存储数据的形式就是字符数组，这个数组被final修饰，并且还是私有的，其次string这个类本身也是被final修饰的，那么它就不能被继承，你就不能通过子类来修改，其次，stringbuilder和stringbuffer继承了abstractstringbuilder类，有append等修改字符串的方法，而string没有继承，自然也没有这种方法，这个原因也体现了OOP的封装特性，所以综上所述，string是不可修改的。</p>',13)]))}const d=e(i,[["render",s]]),l=JSON.parse('{"path":"/2.%E9%9D%A2%E8%AF%95%E7%AF%87/2.%E5%85%AB%E8%82%A1%E7%AC%94%E8%AE%B0/Java%E5%9F%BA%E7%A1%80.html","title":"Java基础","lang":"en-US","frontmatter":{"title":"Java基础"},"git":{"createdTime":1748335679000,"updatedTime":1748335679000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":1.88,"words":565},"filePathRelative":"2.面试篇/2.八股笔记/Java基础.md"}');export{d as comp,l as data};
