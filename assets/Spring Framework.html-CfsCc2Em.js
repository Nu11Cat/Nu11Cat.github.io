import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as r,o as a}from"./app-DZGf4oz2.js";const t={};function s(i,e){return a(),n("div",null,e[0]||(e[0]=[r('<h1 id="spring框架" tabindex="-1"><a class="header-anchor" href="#spring框架"><span>Spring框架</span></a></h1><p>Spring 是一个开源的、轻量级的<strong>Java 企业级开发框架</strong>，主要用于简化 Java 应用的开发过程，尤其是在企业级项目中对**对象创建、依赖管理、事务控制、AOP（面向切面编程）**等方面提供了强大支持。</p><p>Spring 的核心是 <strong>IoC（控制反转）</strong> 和 <strong>AOP（面向切面编程）</strong> 两大思想。IoC 通过依赖注入（DI）管理对象生命周期，解耦业务组件，提高代码的可维护性；AOP 则用于横切关注点的处理，比如日志、权限、事务控制等，避免重复代码。</p><p>除了核心功能，Spring 还提供了大量子模块，支持 Web 开发（Spring MVC）、数据访问（Spring JDBC、Spring Data）、事务管理、安全控制（Spring Security）等。配合 Spring Boot，开发效率和部署体验进一步提升。</p><hr><h2 id="核心模块" tabindex="-1"><a class="header-anchor" href="#核心模块"><span>核心模块</span></a></h2><p>Spring 框架本身是一个模块化体系，按照功能主要包含以下几个核心模块：</p><ol><li><strong>Core Container（核心容器）</strong>：包括 <ul><li><strong>Core</strong> 和 <strong>Beans</strong>：提供 IoC 和依赖注入的基础功能。</li><li><strong>Context</strong>：构建在 Core 和 Beans 之上，提供类似于应用上下文的功能。</li><li><strong>Expression Language（SpEL）</strong>：支持在配置中使用表达式语法。</li></ul></li><li><strong>AOP（面向切面编程）模块</strong>：支持 AOP 的实现，用于解耦横切逻辑，如日志、权限控制、事务等。</li><li><strong>Data Access / Integration（数据访问与集成）模块</strong>： <ul><li><strong>JDBC</strong>：简化 JDBC 编程。</li><li><strong>ORM</strong>：整合 Hibernate、JPA、MyBatis 等 ORM 框架。</li><li><strong>JMS</strong>：支持消息中间件的集成。</li><li><strong>Transactions</strong>：统一的声明式事务管理。</li></ul></li><li><strong>Web 模块</strong>： <ul><li><strong>Web</strong>：提供基础的 Web 开发功能。</li><li><strong>Web MVC</strong>：实现了 MVC 架构的 Spring Web 框架，是开发 Web 应用的核心模块。</li></ul></li><li><strong>Test 模块</strong>：提供对 JUnit、TestNG 的集成，支持对 Spring 组件进行单元测试和集成测试。</li></ol><hr><h2 id="spring-vs-spring-mvc-vs-spring-boot" tabindex="-1"><a class="header-anchor" href="#spring-vs-spring-mvc-vs-spring-boot"><span>Spring vs Spring MVC vs Spring Boot</span></a></h2><p><strong>Spring Framework</strong> 是基础，提供了 IoC（控制反转）和 AOP（面向切面编程）等核心功能，用于管理对象的生命周期和解耦业务逻辑，是整个 Spring 生态的根基。</p><p><strong>Spring MVC</strong> 是 Spring 的一个子模块，用于构建基于 Servlet 的 Web 应用。它实现了 MVC 架构模式，提供了请求分发、参数绑定、视图解析等功能，专注于 Web 层开发。</p><p><strong>Spring Boot</strong> 是对 Spring 全家桶的进一步封装，目的是简化 Spring 应用的配置和部署。它提供了自动配置、内嵌服务器、开箱即用的依赖管理，让开发者能够更快地搭建和运行 Spring 应用，无需编写大量 XML 或繁杂配置。</p><h1 id="ioc" tabindex="-1"><a class="header-anchor" href="#ioc"><span>IOC</span></a></h1><p><strong>控制</strong>指的是对象创建（实例化、管理）的权力。<strong>反转</strong>是指控制权交给外部环境（Spring 框架、IoC 容器）。</p><p>IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p><h2 id="ioc容器" tabindex="-1"><a class="header-anchor" href="#ioc容器"><span>IOC容器</span></a></h2><p>IoC 容器是 Spring 框架的核心组件，它负责<strong>创建、管理和装配 Bean（即对象）</strong>，并处理它们之间的依赖关系。所谓 IoC（控制反转），就是将原本由程序员控制的对象创建和依赖注入工作，交给容器来完成。</p><p>Spring 提供了两种主要的 IoC 容器实现：</p><ol><li><strong>BeanFactory</strong>：是最基础的容器接口，延迟加载（懒加载）Bean，适用于资源受限场景，但功能相对简单。</li><li><strong>ApplicationContext</strong>：是 BeanFactory 的子接口，功能更强大，支持国际化、事件发布、自动装配、AOP 等，是实际开发中使用最广泛的容器。</li></ol><p>IoC 容器的工作过程大致如下：</p><ul><li>启动时读取配置（XML 或注解）；</li><li>扫描并实例化 Bean；</li><li>根据依赖关系自动装配；</li><li>管理 Bean 的生命周期。</li></ul><p>通过 IoC 容器，Spring 实现了应用组件的松耦合，并为后续的 AOP、事务、声明式配置等提供了基础支持。</p><hr><h2 id="bean类" tabindex="-1"><a class="header-anchor" href="#bean类"><span>Bean类</span></a></h2><p>Spring Bean 是指由 <strong>Spring IoC 容器管理的对象</strong>。在 Spring 中，所有被注册到容器中、由容器进行创建、初始化、装配和销毁的组件，统称为 Bean。Spring Bean 通常是 Java 类实例，但也可以是接口的代理对象、工厂方法生成的对象等，只要是由容器管理的对象，都属于 Spring Bean。</p><hr><h3 id="声明bean的注解" tabindex="-1"><a class="header-anchor" href="#声明bean的注解"><span>声明Bean的注解</span></a></h3><ul><li><code>@Component</code>：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li><code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li><code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li><code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><hr><h3 id="注入bean的注解" tabindex="-1"><a class="header-anchor" href="#注入bean的注解"><span>注入Bean的注解</span></a></h3><p>在 Spring 中，注入 Bean（即依赖注入）常用的注解主要有以下几种：</p><ol><li><strong>@Autowired</strong>：最常用的注解，按类型自动注入，默认是按类型匹配，也可以配合 <code>@Qualifier</code> 指定 Bean 名称。当容器中存在多个匹配时，可能导致注入冲突。</li><li><strong>@Qualifier</strong>：与 <code>@Autowired</code> 一起使用，用于按名称精确注入，解决多个同类型 Bean 的冲突。</li><li><strong>@Resource（JDK 提供，Spring 支持）</strong>：按名称注入，找不到再按类型匹配。可选参数 <code>name</code> 明确指定要注入的 Bean 名称。</li><li><strong>@Inject（JSR-330）</strong>：类似于 <code>@Autowired</code>，但属于 Java 标准，不支持 <code>@Qualifier</code> 的 value 属性，只能搭配 <code>@Named</code> 使用，Spring 同样支持。</li><li><strong>@Value</strong>：用于注入基本类型、字符串、表达式或配置文件中的值，如 <code>@Value(&quot;${server.port}&quot;)</code>。</li></ol><hr><h3 id="注入bean的方法" tabindex="-1"><a class="header-anchor" href="#注入bean的方法"><span>注入Bean的方法</span></a></h3><p>依赖注入 (Dependency Injection, DI) 的常见方式：</p><ol><li>构造函数注入：通过类的构造函数来注入依赖项。</li><li>Setter 注入：通过类的 Setter 方法来注入依赖项。</li><li>Field（字段） 注入：直接在类的字段上使用注解（如 <code>@Autowired</code> 或 <code>@Resource</code>）来注入依赖项。</li></ol><hr><p><strong>Spring 官方推荐构造函数注入</strong>，这种注入方式的优势如下：</p><ol><li>依赖完整性：确保所有必需依赖在对象创建时就被注入，避免了空指针异常的风险。</li><li>不可变性：有助于创建不可变对象，提高了线程安全性。</li><li>初始化保证：组件在使用前已完全初始化，减少了潜在的错误。</li><li>测试便利性：在单元测试中，可以直接通过构造函数传入模拟的依赖项，而不必依赖 Spring 容器进行注入。</li></ol><hr><h3 id="bean的作用域" tabindex="-1"><a class="header-anchor" href="#bean的作用域"><span>Bean的作用域</span></a></h3><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application/global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><hr><h3 id="bean是否线程安全" tabindex="-1"><a class="header-anchor" href="#bean是否线程安全"><span>Bean是否线程安全</span></a></h3><p>Spring 本身<strong>并不保证 Bean 是线程安全的</strong>。默认情况下，Spring Bean 是 <strong>单例（singleton）</strong> 的，也就是说整个容器中只有一个实例会被多个线程共享使用。如果这个 Bean 中存在可变的状态（如成员变量）且没有做好并发控制，就可能出现线程安全问题。</p><p>线程安全与否取决于<strong>Bean 的具体实现</strong>。如果 Bean 是无状态的，比如只包含方法逻辑或只依赖局部变量，通常是线程安全的；但如果 Bean 维护了可变的全局状态，就需要开发者自行通过加锁、使用并发工具类等方式来保证线程安全。</p><hr><p>对于有状态单例 Bean 的线程安全问题，常见的三种解决办法是：</p><ol><li><strong>避免可变成员变量</strong>: 尽量设计 Bean 为无状态。</li><li><strong>使用<code>ThreadLocal</code></strong>: 将可变成员变量保存在 <code>ThreadLocal</code> 中，确保线程独立。</li><li><strong>使用同步机制</strong>: 利用 <code>synchronized</code> 或 <code>ReentrantLock</code> 来进行同步控制，确保线程安全。</li></ol><hr><h3 id="bean生命周期" tabindex="-1"><a class="header-anchor" href="#bean生命周期"><span>Bean生命周期</span></a></h3><ol><li><strong>创建 Bean 的实例</strong>：Bean 容器首先会找到配置文件中的 Bean 定义，然后使用 Java 反射 API 来创建 Bean 的实例。</li><li><strong>Bean 属性赋值/填充</strong>：为 Bean 设置相关属性和依赖，例如<code>@Autowired</code> 等注解注入的对象、<code>@Value</code> 注入的值、<code>setter</code>方法或构造函数注入依赖和值、<code>@Resource</code>注入的各种资源。</li><li><strong>Bean 初始化</strong>： <ul><li>如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>init-method</code> 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法。</li></ul></li><li><strong>销毁 Bean</strong>：销毁并不是说要立马把 Bean 给销毁掉，而是把 Bean 的销毁方法先记录下来，将来需要销毁 Bean 或者销毁容器的时候，就调用这些方法去释放 Bean 所持有的资源。 <ul><li>如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>如果 Bean 在配置文件中的定义包含 <code>destroy-method</code> 属性，执行指定的 Bean 销毁方法。或者，也可以直接通过<code>@PreDestroy</code> 注解标记 Bean 销毁之前执行的方法。</li></ul></li></ol><hr><h1 id="aop" tabindex="-1"><a class="header-anchor" href="#aop"><span>AOP</span></a></h1><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理。</p><h2 id="spring-aop-vs-aspectj-aop" tabindex="-1"><a class="header-anchor" href="#spring-aop-vs-aspectj-aop"><span>Spring AOP vs AspectJ AOP</span></a></h2><table><thead><tr><th>特性</th><th>Spring AOP</th><th>AspectJ</th></tr></thead><tbody><tr><td><strong>增强方式</strong></td><td>运行时增强（基于动态代理）</td><td>编译时增强、类加载时增强（直接操作字节码）</td></tr><tr><td><strong>切入点支持</strong></td><td>方法级（Spring Bean 范围内，不支持 final 和 staic 方法）</td><td>方法级、字段、构造器、静态方法等</td></tr><tr><td><strong>性能</strong></td><td>运行时依赖代理，有一定开销，切面多时性能较低</td><td>运行时无代理开销，性能更高</td></tr><tr><td><strong>复杂性</strong></td><td>简单，易用，适合大多数场景</td><td>功能强大，但相对复杂</td></tr><tr><td><strong>使用场景</strong></td><td>Spring 应用下比较简单的 AOP 需求</td><td>高性能、高复杂度的 AOP 需求</td></tr></tbody></table><hr><h2 id="aop常见的通知类型" tabindex="-1"><a class="header-anchor" href="#aop常见的通知类型"><span>AOP常见的通知类型</span></a></h2><ul><li><p><strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</p></li><li><p><strong>After</strong> （后置通知）：目标对象的方法调用之后触发</p></li><li><p><strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</p></li><li><p><strong>AfterThrowing</strong>（异常通知）：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</p></li><li><p><strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</p></li></ul><hr><h2 id="切面执行顺序" tabindex="-1"><a class="header-anchor" href="#切面执行顺序"><span>切面执行顺序</span></a></h2><p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p><p>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</p><hr><h1 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc"><span>Spring MVC</span></a></h1><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><h2 id="核心组件" tabindex="-1"><a class="header-anchor" href="#核心组件"><span>核心组件</span></a></h2><ul><li><strong><code>DispatcherServlet</code></strong>：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code></strong>：<strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code></strong>：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code></strong>：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code></strong>：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><hr><h2 id="工作流程" tabindex="-1"><a class="header-anchor" href="#工作流程"><span>工作流程</span></a></h2><p>Spring MVC 是基于 MVC（Model-View-Controller）架构设计的 Web 框架，其工作流程可以概括为一个请求从前端到后端再返回响应的完整闭环。核心流程如下：</p><ol><li><strong>用户发起请求</strong>：浏览器发送 HTTP 请求，首先被 Spring 的前端控制器 <code>DispatcherServlet</code> 接收。</li><li><strong>请求分发</strong>：<code>DispatcherServlet</code> 通过 <code>HandlerMapping</code> 查找与请求路径对应的处理器（Controller 方法）及其执行链。</li><li><strong>调用处理器方法</strong>：<code>DispatcherServlet</code> 将请求委托给对应的 <code>HandlerAdapter</code>，适配并调用目标 Controller 方法。</li><li><strong>业务逻辑处理</strong>：Controller 处理业务逻辑后，返回一个 <code>ModelAndView</code> 对象（或数据对象），包含视图名和模型数据。</li><li><strong>视图解析</strong>：<code>DispatcherServlet</code> 调用 <code>ViewResolver</code>，根据视图名解析出具体的视图资源（如 JSP、HTML）。</li><li><strong>渲染视图</strong>：视图渲染引擎将模型数据填充到页面模板，生成最终的 HTML 页面。</li><li><strong>响应返回客户端</strong>：最终 HTML 被返回到浏览器，完成一次完整的请求处理过程。</li></ol><p>前后端分离时，后端通常不再返回具体的视图，而是返回<strong>纯数据</strong>（通常是 JSON 格式），由前端负责渲染和展示。</p><p>怎么做到呢？</p><ul><li>使用 <code>@RestController</code> 注解代替传统的 <code>@Controller</code> 注解，这样所有方法默认会返回 JSON 格式的数据，而不是试图解析视图。</li><li>如果你使用的是 <code>@Controller</code>，可以结合 <code>@ResponseBody</code> 注解来返回 JSON。</li></ul><hr><h2 id="统一异常处理" tabindex="-1"><a class="header-anchor" href="#统一异常处理"><span>统一异常处理</span></a></h2><p><strong>Spring 中如何做统一异常处理</strong></p><p>在 Spring 或 Spring Boot 应用中，统一异常处理常通过 <code>@ControllerAdvice</code> 配合 <code>@ExceptionHandler</code> 注解实现。这样可以集中管理异常逻辑，避免在每个 Controller 中重复写 try-catch，提高代码整洁性和可维护性。</p><p><code>@ControllerAdvice</code> 是一个全局控制器增强注解，标识的类会对所有 Controller 生效。它内部的方法用 <code>@ExceptionHandler</code> 注解标明要处理的异常类型。Spring 会在出现指定异常时自动调用对应的方法进行处理，并返回统一的响应格式。</p><p>此外，还可以结合 <code>@ResponseBody</code> 或让处理方法返回 <code>ResponseEntity</code>，从而将异常信息转为标准的 JSON 格式返回给前端，便于前后端通信。</p><hr><h1 id="spring-循环依赖" tabindex="-1"><a class="header-anchor" href="#spring-循环依赖"><span>Spring 循环依赖</span></a></h1><p>循环依赖是指 Bean 对象循环引用，是两个或多个 Bean 之间相互持有对方的引用。</p><h2 id="三级缓存" tabindex="-1"><a class="header-anchor" href="#三级缓存"><span>三级缓存</span></a></h2><p>Spring 框架通过使用三级缓存来解决这个问题：</p><p>Spring 的三级缓存包括：</p><ol><li><strong>一级缓存（singletonObjects）</strong>：存放最终形态的 Bean（已经实例化、属性填充、初始化），单例池，为“Spring 的单例属性”⽽⽣。一般情况我们获取 Bean 都是从这里获取的，但是并不是所有的 Bean 都在单例池里面，例如原型 Bean 就不在里面。</li><li><strong>二级缓存（earlySingletonObjects）</strong>：存放过渡 Bean（半成品，尚未属性填充），也就是三级缓存中<code>ObjectFactory</code>产生的对象，与三级缓存配合使用的，可以防止 AOP 的情况下，每次调用<code>ObjectFactory#getObject()</code>都是会产生新的代理对象的。</li><li><strong>三级缓存（singletonFactories）</strong>：存放<code>ObjectFactory</code>，<code>ObjectFactory</code>的<code>getObject()</code>方法（最终调用的是<code>getEarlyBeanReference()</code>方法）可以生成原始 Bean 对象或者代理对象（如果 Bean 被 AOP 切面代理）。三级缓存只会对单例 Bean 生效。</li></ol><hr><p>整个解决循环依赖的<strong>流程</strong>如下：</p><ul><li>当 Spring 创建 A 之后，发现 A 依赖了 B ，又去创建 B，B 依赖了 A ，又去创建 A；</li><li>在 B 创建 A 的时候，那么此时 A 就发生了循环依赖，由于 A 此时还没有初始化完成，因此在 <strong>一二级缓存</strong> 中肯定没有 A；</li><li>那么此时就去三级缓存中调用 <code>getObject()</code> 方法去获取 A 的 <strong>前期暴露的对象</strong> ，也就是调用上边加入的 <code>getEarlyBeanReference()</code> 方法，生成一个 A 的 <strong>前期暴露对象</strong>；</li><li>然后就将这个 <code>ObjectFactory</code> 从三级缓存中移除，并且将前期暴露对象放入到二级缓存中，那么 B 就将这个前期暴露对象注入到依赖，来支持循环依赖。</li></ul><p><strong>只用两级缓存够吗？</strong> 在没有 AOP 的情况下，确实可以只使用一级和二级缓存来解决循环依赖问题。但是，当涉及到 AOP 时，三级缓存就显得非常重要了，因为它确保了即使在 Bean 的创建过程中有多次对早期引用的请求，也始终只返回同一个代理对象，从而避免了同一个 Bean 有多个代理对象的问题。</p><hr><p>不过，这种机制也有一些<strong>缺点</strong>，比如增加了内存开销（需要维护三级缓存，也就是三个 Map），降低了性能（需要进行多次检查和转换）。并且，还有少部分情况是不支持循环依赖的，比如非单例的 bean 和<code>@Async</code>注解的 bean 无法支持循环依赖。</p><hr><h2 id="lazy能不能解决循环依赖问题" tabindex="-1"><a class="header-anchor" href="#lazy能不能解决循环依赖问题"><span>@Lazy能不能解决循环依赖问题</span></a></h2><p><code>@Lazy</code> 注解的作用是<strong>延迟初始化</strong>，即当第一次使用 Bean 时才进行实例化，而不是在容器启动时立即创建。<code>@Lazy</code> 可以用于解决某些场景下的循环依赖，但并不是完全解决所有的循环依赖问题。</p><p><strong>在循环依赖场景下，<code>@Lazy</code> 如何工作：</strong></p><p>假设有两个单例 Bean A 和 B，其中 A 依赖 B，B 依赖 A。如果在其中一个 Bean 上加上 <code>@Lazy</code> 注解，那么 Spring 容器会延迟该 Bean 的初始化，直到它真正被需要时才去创建。</p><ol><li><strong>A 依赖 B，B 依赖 A</strong>：当 Spring 初始化 A 时，A 会看到 B 被标记为 <code>@Lazy</code>，因此不会立即尝试创建 B，而是将 B 延迟到后续需要时再创建。</li><li><strong>B 的初始化被延迟</strong>：当 B 被第一次访问时，Spring 会实例化 B，随后通过 A 注入 B。此时，B 依赖 A，但由于 A 已经是一个 &quot;半初始化&quot; 的对象，Spring 可以通过二级缓存来解决这一问题。</li></ol><p>关键点：</p><ul><li><code>@Lazy</code> 可以让 Spring 延迟某个 Bean 的初始化，从而避免在构造函数注入时出现循环依赖。</li><li>然而，<code>@Lazy</code> 只对<strong>延迟加载</strong>有效，它的作用是推迟 Bean 的初始化时机，而不是根本解决循环依赖。实际的循环依赖问题仍然需要通过 Spring 容器的缓存机制（三级缓存）来解决。</li></ul><hr><h1 id="spring-事务" tabindex="-1"><a class="header-anchor" href="#spring-事务"><span>Spring 事务</span></a></h1><h2 id="事务管理方式" tabindex="-1"><a class="header-anchor" href="#事务管理方式"><span>事务管理方式</span></a></h2><p><strong>编程式事务</strong>：在代码中硬编码(在分布式系统中推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，事务范围过大会出现事务未提交导致超时，因此事务要比锁的粒度更小。</p><p><strong>声明式事务</strong>：在 XML 配置文件中配置或者直接基于注解（单体应用或者简单业务系统推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</p><hr><h2 id="事务传播行为" tabindex="-1"><a class="header-anchor" href="#事务传播行为"><span>事务传播行为</span></a></h2><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>正确的事务传播行为可能的值如下:</p><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p>这个使用的很少。</p><hr><h2 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别"><span>事务的隔离级别</span></a></h2><p><strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</p><p><strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></p><p><strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></p><p><strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></p><p><strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</p><hr><h2 id="transactional" tabindex="-1"><a class="header-anchor" href="#transactional"><span>@Transactional</span></a></h2><p><code>@Transactional</code> 的作用范围</p><ol><li><strong>方法</strong>：推荐将注解使用于方法上，不过需要注意的是：<strong>该注解只能应用到 public 方法上，否则不生效。</strong></li><li><strong>类</strong>：如果这个注解使用在类上的话，表明该注解对该类中所有的 public 方法都生效。</li><li><strong>接口</strong>：不推荐在接口上使用。</li></ol><hr><p><strong>原理</strong></p><p><code>@Transactional</code> 的工作机制是基于 AOP 实现的，AOP 又是使用动态代理实现的。如果目标对象实现了接口，默认情况下会采用 JDK 的动态代理，如果目标对象没有实现了接口,会使用 CGLIB 动态代理。</p><hr><h1 id="设计模式" tabindex="-1"><a class="header-anchor" href="#设计模式"><span>设计模式</span></a></h1><p><a href="https://javaguide.cn/system-design/framework/spring/spring-design-patterns-summary.html" target="_blank" rel="noopener noreferrer">Spring 中的设计模式详解 | JavaGuide</a></p><hr><h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h1><h3 id="component-vs-bean" tabindex="-1"><a class="header-anchor" href="#component-vs-bean"><span>@Component vs @Bean</span></a></h3><p><code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p><p><code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p><p><code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p><hr><h3 id="autowired-vs-resource" tabindex="-1"><a class="header-anchor" href="#autowired-vs-resource"><span>@Autowired vs @Resource</span></a></h3><p><code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</p><p><code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p><p>当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</p><p><code>@Autowired</code> 支持在构造函数、方法、字段和参数上使用。<code>@Resource</code> 主要用于字段和方法上的注入，不支持在构造函数或参数上使用。</p><hr><p>IoC/AOP、Spring MVC、事务管理</p><p>spring 框架有四大核心特性：</p><blockquote><p>Ioc，就是控制反转，是为了解决对象创建和依赖的高耦合的问题，是一种创建和获取对象的技术思想，是通过DI，也就是依赖注入实现的,传统开发我们需要new出新对象，而通过IOC我们通过ioc容器来实例化对象，大大降低对象之间的耦合。</p><p>通过反射，依赖注入，设计模式（工厂模式），容器实现的，其中，反射就是java反射机制，允许Ioc容器在运行时加载类和创建对象实例以及调用对象方法；依赖注入是ioc的核心概念；容器作为工厂来实例化bean并管理他们的生命周期；IOC容器通常使用BeanFactory或者ApplicationContext来管理Bean，依赖关系的硬编码问题</p></blockquote><blockquote><p>AOP，就是面向切面编程,允许开发者定义横切关注点，比如说事务管理，日志管理和权限控制。把那些与对象无关的，但是被业务代码共同调用的逻辑封装起来，减少重复代码，降低了模块间的耦合，有利于未来的扩展和维护。AOP是依赖于<strong>动态代理技术</strong>，动态代理是在运行时动态生成代理对象，而不是在编译时。它允许开发者在允许时指定要代理的接口和行为，从而实现在不修改源码的情况下增强或者拦截方法。</p></blockquote><blockquote><p>事务处理，</p></blockquote><blockquote><p>MVC，是指模型，视图，控制器，是一种软件设计典范，是一种把业务逻辑、数据、界面显示分离的方法组织代码。流程步骤就是用户通过view页面向服务端提出请求，controller控制器接收到解析，找到相应的model来处理，处理结果由controller返回给用户的view界面，界面渲染之后呈现。</p></blockquote><blockquote><p>DI，依赖注入，为了解决依赖关系的硬编码问题和类依赖问题导致的高耦合，容器负责管理应用程序组件之间的依赖问题，是一种具体的编码技巧。不再通过new来在类的内部创建依赖类的对象，而是将对象的创建和依赖关系交给容器，类只需要声明自己依赖的对象，容器就会在运行的时候把依赖注入到类种，从而降低类与类的耦合度，实现方式有构造器注入、Setter方法注入，还有字段注入。</p></blockquote><blockquote><p>自动装配：</p></blockquote>',163)]))}const p=o(t,[["render",s]]),l=JSON.parse('{"path":"/1.Note/2.Spring_Framework/Spring%20Framework.html","title":"Spring Framework","lang":"en-US","frontmatter":{"title":"Spring Framework","order":1},"git":{"createdTime":1754471222000,"updatedTime":1754471222000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":23.28,"words":6983},"filePathRelative":"1.Note/2.Spring&Framework/Spring Framework.md"}');export{p as comp,l as data};
