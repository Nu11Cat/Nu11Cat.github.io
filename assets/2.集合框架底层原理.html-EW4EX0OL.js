import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as r,a as o,o as s}from"./app-2wafLgZ6.js";const n={};function a(l,t){return s(),r("div",null,t[0]||(t[0]=[o("<p><strong>问：Java 集合框架的主要接口有哪些？</strong></p><p>答：Java 集合框架主要包括两个根接口：<code>Collection</code> 和 <code>Map</code>。</p><ul><li><strong>Collection 接口</strong>：用于存储单个元素，主要包括三个子接口： <ul><li><strong>List</strong>：有序、可重复的集合。</li><li><strong>Set</strong>：无序、不可重复的集合。</li><li><strong>Queue</strong>：用于实现队列结构，支持先进先出（FIFO）等特性。</li></ul></li><li><strong>Map 接口</strong>：用于存储键值对（key-value）映射关系。</li></ul><hr><p><strong>问：ArrayList 的底层实现原理是什么？</strong></p><p>答：ArrayList 是基于动态数组实现的集合，底层使用 <code>Object[]</code> 数组存储元素。默认初始容量为 10，当容量不足时，会扩容为原容量的 1.5 倍。它支持快速随机访问，时间复杂度为 O(1)，但在中间插入或删除元素时，需要移动后续元素，时间复杂度为 O(n)。ArrayList 是非线程安全的。</p><hr><p><strong>问：LinkedList 的底层实现原理是什么？</strong></p><p>答：LinkedList 是基于双向链表实现的集合，每个节点包含前驱和后继指针。它适合频繁的插入和删除操作，时间复杂度为 O(1)，但随机访问效率较低，时间复杂度为 O(n)。LinkedList 实现了 <code>Deque</code> 接口，可作为双端队列使用，也是非线程安全的。</p><hr><p><strong>问：HashMap 的底层实现原理是什么？</strong></p><p>答：HashMap 是基于哈希表实现的，底层使用数组加链表或红黑树的结构存储键值对。默认初始容量为 16，负载因子为 0.75。当链表长度超过 8 且数组长度大于 64 时，链表会转换为红黑树，以提高查找效率。HashMap 允许一个 <code>null</code> 键和多个 <code>null</code> 值，元素无序，非线程安全。</p><hr><p><strong>问：HashSet 的底层实现原理是什么？</strong></p><p>答：HashSet 是基于 HashMap 实现的集合，底层使用 HashMap 存储元素。每个添加到 HashSet 的元素都会作为 HashMap 的键存储，值为一个固定的对象。HashSet 不允许存储重复元素，最多允许一个 <code>null</code> 元素，元素的顺序不保证，非线程安全。</p><hr><p><strong>问：TreeSet 的底层实现原理是什么？</strong></p><p>答：TreeSet 是基于 TreeMap 实现的集合，底层使用红黑树（Red-Black Tree）存储元素。它可以自动对元素进行排序，默认按自然顺序排序，也可以通过构造函数传入比较器进行定制排序。TreeSet 不允许存储 <code>null</code> 元素，插入、删除、查找操作的时间复杂度为 O(log n)，非线程安全。</p><hr><p><strong>问：ConcurrentHashMap 的底层实现原理是什么？</strong></p><p>答：ConcurrentHashMap 是线程安全的哈希表实现。在 JDK 1.7 中，采用分段锁（Segment）机制，将整个表分为多个段，每个段独立加锁，提高并发性能。在 JDK 1.8 中，取消了分段锁，采用了 CAS（Compare-And-Swap）和 synchronized 关键字相结合的方式，使用数组加链表或红黑树的结构存储键值对，进一步提高了并发性能。ConcurrentHashMap 不允许 <code>null</code> 键或值。</p><hr><p><strong>问：ArrayList 和 LinkedList 有哪些区别？</strong></p><p>答：</p><ul><li><strong>底层数据结构</strong>：ArrayList 基于动态数组实现，LinkedList 基于双向链表实现。</li><li><strong>访问效率</strong>：ArrayList 支持快速随机访问，时间复杂度为 O(1)；LinkedList 需要从头或尾遍历，时间复杂度为 O(n)。</li><li><strong>插入和删除效率</strong>：ArrayList 在中间插入或删除元素时，需要移动后续元素，时间复杂度为 O(n)；LinkedList 插入和删除操作效率较高，时间复杂度为 O(1)。</li><li><strong>线程安全性</strong>：两者都不是线程安全的。</li></ul><hr><p><strong>问：HashMap 和 Hashtable 有哪些区别？</strong></p><p>答：</p><ul><li><strong>线程安全性</strong>：HashMap 是非线程安全的，Hashtable 是线程安全的，所有方法都被 synchronized 修饰。</li><li><strong>性能</strong>：由于 Hashtable 的同步机制，性能较低；HashMap 性能较高。</li><li><strong>null 键和值</strong>：HashMap 允许一个 <code>null</code> 键和多个 <code>null</code> 值；Hashtable 不允许 <code>null</code> 键或值。</li><li><strong>继承关系</strong>：HashMap 继承自 AbstractMap；Hashtable 继承自 Dictionary（已过时）。</li></ul>",29)]))}const c=e(n,[["render",a]]),g=JSON.parse('{"path":"/2.%E9%9D%A2%E8%AF%95%E7%AF%87/1.Java%E5%9F%BA%E7%A1%80%E9%AB%98%E9%A2%91%E5%BF%85%E8%80%83/2.%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86.html","title":"2.集合框架底层原理","lang":"en-US","frontmatter":{"title":"2.集合框架底层原理"},"git":{"createdTime":1747451581000,"updatedTime":1747451581000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":3.36,"words":1009},"filePathRelative":"2.面试篇/1.Java基础高频必考/2.集合框架底层原理.md"}');export{c as comp,g as data};
