import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as c,o as d}from"./app-rKgfsawK.js";const r={};function s(n,e){return d(),a("div",null,e[0]||(e[0]=[c(`<h1 id="概述" tabindex="-1"><a class="header-anchor" href="#概述"><span>概述</span></a></h1><p>Java集合分为 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。</p><p><code>Collection</code> 接口又有三个主要的子接口：<code>List</code>、<code>Set</code> 、 <code>Queue</code>。</p><h1 id="list" tabindex="-1"><a class="header-anchor" href="#list"><span>List</span></a></h1><h2 id="集合" tabindex="-1"><a class="header-anchor" href="#集合"><span>集合</span></a></h2><h3 id="集合遍历的方法有哪些" tabindex="-1"><a class="header-anchor" href="#集合遍历的方法有哪些"><span>集合遍历的方法有哪些？</span></a></h3><p><strong>1，普通 for 循环</strong></p><p><strong>2，增强 for 循环（for-each循环）：</strong> 用于循环访问数组或集合中的元素</p><p><strong>3，Iterator 迭代器：</strong> 可以使用迭代器来遍历集合，特别适用于需要删除元素的情况。</p><p>**4，ListIterator 列表迭代器 ：**ListIterator是迭代器的子类，可以双向访问列表并在迭代过程中修改元素。</p><p>**5，使用 forEach 方法：**Java 8引入了 forEach 方法，可以对集合进行快速遍历。</p><p>**6，Stream API：**Java 8的Stream API提供了丰富的功能，可以对集合进行函数式操作，如过滤、映射等。</p><hr><h3 id="list-vs-数组" tabindex="-1"><a class="header-anchor" href="#list-vs-数组"><span>List vs 数组</span></a></h3><p>数组是固定长度的数据结构，一旦创建长度就无法改变，而集合是动态长度的数据结构，可以根据需要动态增加或减少元素。</p><p>数组可以包含基本数据类型和对象，而集合只能包含对象。</p><p>数组可以直接访问元素，而集合需要通过迭代器或其他方法访问元素。</p><hr><h3 id="list可以一边遍历一边修改元素吗" tabindex="-1"><a class="header-anchor" href="#list可以一边遍历一边修改元素吗"><span>list可以一边遍历一边修改元素吗？</span></a></h3><p><strong>决于遍历方式和具体的<code>List</code>实现类</strong></p><p>1，<strong>使用普通for循环遍历</strong>。<strong>可以</strong>在遍历过程中修改元素，只要修改的索引不超出<code>List</code>的范围即可。</p><p>2，<strong>使用foreach循环遍历</strong>。<strong>不可以</strong>，因为这可能会导致意外的结果或<code>ConcurrentModificationException</code>异常。因为<code>foreach</code>循环底层是基于迭代器实现的，在<code>foreach</code>循环中修改元素可能会破坏迭代器的内部状态。</p><p>3，<strong>使用迭代器遍历</strong>。<strong>可以</strong>使用迭代器的<code>remove</code>方法来删除元素，通过迭代器的<code>set</code>方法修改元素。不能通过<code>List</code>的<code>set</code>方法，否则也可能发生<code>ConcurrentModificationException</code>异常。</p><p>4，对于<strong>线程安全的<code>List</code></strong>，如<code>CopyOnWriteArrayList</code>由于其采用了写时复制的机制，在遍历的同时可以进行修改操作，不会抛出<code>ConcurrentModificationException</code>异常,但是可能会读取到旧的数据，因为修改操作是在新的副本上进行的。</p><hr><h3 id="collections-synchronizedlist" tabindex="-1"><a class="header-anchor" href="#collections-synchronizedlist"><span>Collections.synchronizedList()</span></a></h3><p><code>Collections.synchronizedList()</code> 是 Java 中的一个工具方法，用于将一个普通的 <code>List</code> 包装成一个线程安全的 <code>List</code>。它是通过对所有的 <code>List</code> 操作加锁来保证线程安全的。</p><hr><h2 id="arraylist" tabindex="-1"><a class="header-anchor" href="#arraylist"><span>ArrayList</span></a></h2><h3 id="arraylist和数组的区别" tabindex="-1"><a class="header-anchor" href="#arraylist和数组的区别"><span>ArrayList和数组的区别</span></a></h3><p>数组是 Java 最基本的数据结构，特点是长度固定、访问效率高。它适合用在对性能要求比较高、元素数量明确的场景，比如底层算法、缓存之类的。</p><p>ArrayList 是 Java 集合框架中的一个类，它的底层其实就是数组，但它在上层做了封装，支持动态扩容。还提供了很多方便的 API，比如 add、remove、contains 等。</p><p>数组可以存基本类型，比如 int[]，但是 ArrayList 只能存引用类型，这是因为泛型不支持基本类型，要通过自动装箱来处理。</p><hr><h3 id="机制" tabindex="-1"><a class="header-anchor" href="#机制"><span>机制</span></a></h3><p><code>ArrayList</code>是基于数组实现的可变长度的列表。它实现了<code>RadomAccess</code>标记接口，支持索引快速访问。底层就是一个Object[]数组。线程不安全。</p><p><strong>懒加载</strong>：如果你没有指定大小那它是懒加载的，创建了一个<code>ArrayList</code>的时候并不会立刻分配数组，而是把内部的<code>elementDate</code>指向一个共享的空数组<code>EMPTY_ELEMENTDATA</code>，真正的初始化发生在第一次添加元素的时候，这样的目的是为了节省内存。只有在第一次添加元素时，才会初始化为默认容量 <strong>10</strong> 的数组。</p><p><strong>扩容</strong>：当你调用add()会进行元素个数和容量的判断，判断是否达到数组容量，如果是就会触发扩容，这里的扩容是一个懒触发的过程，只有在满了的那一刻才扩容，会触发grow()方法，把原数组的容量扩大到1.5倍，实际上是创建了一个新数组然后<code>Arrays.copyOf()</code>方法复制的。</p><p>至于为什么是1.5倍，从源码上看是因为<code>oldCapacity + (oldCapacity &gt;&gt; 1);</code>，&gt;&gt;右移一位就是除以2^1，从设计上讲，这是一个性能和空间的权衡折中方案，因为频繁的扩容会导致性能浪费，而扩太多就会导致空间浪费。并且1.5可以通过位运算减少浮点数或者运算时间和运算次数。</p><p>但是删除元素不会自动缩容，逻辑大小会减少，但是底层容量仍然保留原扩容后的大小。这种设计的初衷是为了提高性能，减少频繁的内存复制操作，适用于大多数场景。然而，这也带来了内存浪费的问题。为了避免浪费，如果元素减少得较多，可以手动调用 <code>trimToSize()</code> 来缩容。</p><p><strong>复杂度</strong>：至于插入删除的复杂度，如果是头部和指定位置都是O(n)，如果是尾部插入，又分为需要扩容和不需要扩容的情况，如果需要扩容，那么会新建数组然后<code>copyOf()</code>，复杂度是O(n)，如果不需要扩容就是O(1)。</p><hr><h3 id="为什么arraylist线程不安全" tabindex="-1"><a class="header-anchor" href="#为什么arraylist线程不安全"><span>为什么ArrayList线程不安全</span></a></h3><p><code>ArrayList</code> 是基于 <strong>动态数组</strong> 实现的集合类，在设计上是<strong>为单线程场景优化的</strong>，内部操作都没有做任何同步控制，因此在多线程环境下是不安全的。</p><p>具体来说，它的线程不安全体现在以下几个方面：</p><ol><li><strong>添加元素时可能发生数据覆盖或数组越界</strong>： 如果多个线程同时调用 <code>add()</code> 方法，而此时底层数组正好需要扩容，那么可能会多个线程同时进入扩容逻辑，导致扩容结果不一致、数据被覆盖，甚至抛出 <code>ArrayIndexOutOfBoundsException</code>。</li><li><strong>删除或修改元素时可能引发结构错乱</strong>： 多个线程同时调用 <code>remove()</code> 或 <code>set()</code>，可能会导致元素错位或数据异常，破坏 <code>ArrayList</code> 的内部结构。</li><li><strong>迭代过程中可能抛出 <code>ConcurrentModificationException</code></strong>： <code>ArrayList</code> 的迭代器是<strong>快速失败（fail-fast）机制</strong>，在遍历过程中如果有其他线程修改了集合结构，会抛出 <code>ConcurrentModificationException</code> 异常。</li></ol><p>这些问题的根本原因在于：<code>ArrayList</code> 的核心操作（如 <code>add</code>、<code>remove</code>、<code>ensureCapacity</code>、<code>modCount</code> 相关）<strong>没有使用锁或其他并发控制机制</strong>，在多线程环境下会发生<strong>竞态条件</strong>，最终导致不可预测的问题。</p><hr><h3 id="把arraylist变成线程安全" tabindex="-1"><a class="header-anchor" href="#把arraylist变成线程安全"><span>把ArrayList变成线程安全</span></a></h3><p>ArrayList不是线程安全的</p><p>1，使用Collections类的synchronizedList方法将ArrayList包装成线程安全的List</p><p>2，使用CopyOnWriteArrayList类代替ArrayList，它是一个线程安全的List实现</p><p>3，使用Vector类代替ArrayList，Vector是线程安全的List实现</p><hr><h2 id="linkedlist" tabindex="-1"><a class="header-anchor" href="#linkedlist"><span>LinkedList</span></a></h2><p><code>LinkedList</code>是基于双向链表实现的（JDK1.6 之前为循环链表，JDK1.7 改为普通双向链表），底层是由多个节点（<code>Node</code>）连接成的链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问。包括前后节点的引用和存储的元素。线程不安全。</p><p><strong>复杂度</strong>：元素的添加都是O(1)，删除头尾也都是O(1)，但是删除中间节点的时候需要定位到节点，所以是O(n)。</p><p>并且它实现了 <code>List</code>、<code>Deque</code> 和 <code>Queue</code> 接口，所以既能当列表用，也能当队列、双端队列、栈来用，功能还是很丰富的。</p><hr><h2 id="copyonwritearraylist" tabindex="-1"><a class="header-anchor" href="#copyonwritearraylist"><span>CopyOnWriteArrayList</span></a></h2><p><code>CopyOnWriteArrayList</code> 是 Java 并发包 (<code>java.util.concurrent</code>) 提供的线程安全 <code>List</code> 实现。它采用 <strong>&quot;写时复制&quot;</strong> 机制，适用于 <strong>读多写少</strong> 的高并发场景。</p><p><strong>底层结构</strong>是内部维护了一个 <code>volatile</code> 数组（<code>Object[] array</code>），保证多线程可见性。</p><p>它的<strong>核心实现原理</strong>是读写分离。所有读操作直接访问当前数组的快照，完全不需要加锁，因此读性能极高。而写操作会通过互斥锁ReentrantLock 加锁保护，在修改数据时先复制一份新的底层数组，在新数组上完成修改后，再原子性地替换旧数组。这种设计保证了读操作永远不会阻塞，也避免了读写冲突。</p><p>这种实现方式带来了几个<strong>关键特性</strong>：首先，由于读操作不加锁且访问的是不可变数组快照，因此可以支持高并发的读取。其次，写操作虽然需要复制数组，但由于加锁保证了同一时刻只有一个写操作在进行，避免了数据竞争。最后，迭代器基于创建时的数组快照工作，不会反映后续修改，这种弱一致性特性避免了 ConcurrentModificationException。</p><p><strong>应用场景</strong>：<code>CopyOnWriteArrayList</code> 最适合监听器列表、配置信息等读多写少的场景。它的主要优势在于极高的读并发性能和无锁读取，但代价是写操作的成本较高，因为每次修改都需要复制整个数组。同时，由于迭代器的弱一致性，它不适合需要实时看到最新数据的场景。</p><hr><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比"><span>对比</span></a></h2><h3 id="arraylist-vs-linkedlist" tabindex="-1"><a class="header-anchor" href="#arraylist-vs-linkedlist"><span>ArrayList vs LinkedList</span></a></h3><p><strong>相同点</strong>：</p><ul><li>都实现了 Java 的 List 接口：它们都支持相同的基本操作，例如添加元素、删除元素、查找元素、获取元素等</li><li>都是有序的集合：都保证按顺序存储元素</li><li>都允许存储重复元素：可以有多个相同的元素，并且都允许存储 null 元素。</li><li>都不线程安全</li></ul><p><strong>不同点</strong>：</p><ul><li><strong>底层数据结构</strong>：ArrayList的底层是动态数组，有扩容机制；LinkedList的底层是双向链表。</li><li><strong>操作复杂度</strong>：ArrayList的插入删除的复杂度，如果是头部和指定位置都是O(n)，如果是尾部插入，又分为需要扩容和不需要扩容的情况，如果需要扩容，那么会新建数组然后<code>copyOf()</code>，复杂度是O(n)，如果不需要扩容就是O(1)； LinkedList元素的添加都是O(1)，删除头尾也都是O(1)，但是删除中间节点的时候需要定位到节点，所以是O(n)。</li><li><strong>快速随机访问</strong>：<code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code>（实现了 <code>RandomAccess</code> 接口） 支持。</li><li><strong>内存空间占用</strong>：<code>ArrayList</code> 的空间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li><li><strong>应用场景</strong>：ArrayList 适合查询多，修改少的场景；LinkedList 适合插入和删除操作多的场景。</li></ul><hr><h1 id="map" tabindex="-1"><a class="header-anchor" href="#map"><span>Map</span></a></h1><h2 id="图" tabindex="-1"><a class="header-anchor" href="#图"><span>图</span></a></h2><h3 id="如何对map进行快速遍历" tabindex="-1"><a class="header-anchor" href="#如何对map进行快速遍历"><span>如何对map进行快速遍历？</span></a></h3><p>1，使用for-each循环和entrySet()方法：较为常见和简洁的遍历方式，可以同时获取<code>Map</code>中的键和值。</p><p>2，使用for-each循环和keySet()方法：只遍历键</p><p>3，使用迭代器：这种方式在需要删除元素等操作时比较有用。</p><p>4，使用 Lambda 表达式和forEach()方法</p><p>5，使用Stream API：可以将<code>Map</code>转换为流</p><hr><h3 id="哈希冲突的解决方法" tabindex="-1"><a class="header-anchor" href="#哈希冲突的解决方法"><span>哈希冲突的解决方法</span></a></h3><p>1，链接法：使用链表或其他数据结构来存储冲突的键值对，将它们链接在同一个哈希桶中。</p><p>2，开放寻址法：在哈希表中找到另一个可用的位置来存储冲突的键值对。常见的开放寻址方法包括线性探测、二次探测和双重散列。</p><p>3，再哈希法：使用另一个哈希函数再次计算键的哈希值，直到找到一个空槽来存储键值对。</p><p>4，哈希桶扩容：可以动态地扩大哈希桶的数量，重新分配键值对，以减少冲突的概率。</p><hr><h2 id="hashmap" tabindex="-1"><a class="header-anchor" href="#hashmap"><span>HashMap</span></a></h2><p>TreeMap和HashMap都继承自AbstractMap</p><p>HashMap的底层是数组+链表/红黑树，是非线程安全的，核心原理是<strong>通过 key 的 hash 值快速定位元素在数组中的位置</strong>，然后通过 <code>equals()</code> 判断是否为同一个 key，实现快速查找和插入；<strong>当put插入数据的时候</strong>，首先调用hashcode方法计算哈希值，然后hash方法又会对这个哈希值进行扰动处理（本质是添加高位信息的计算，降低低位重复的风险），目的是为了让哈希值更均匀，减少碰撞。然后会对数组长度取模得到数组下标，也就是桶的索引，如果这个位置是空的，就直接在这个位置放一个Node节点（键值对的封装对象），如果已经有数据了，说明发生了哈希冲突，这个时候会遍历桶的链表/红黑树，先用hash筛选可能的key，然后使用equals方法判断是不是同一个key，如果key已经存在，就更新value，反之，就添加这个节点，走链表（8之前头插，之后尾插，性能稍慢但是并发扩容不会造成<strong>循环链表</strong>）或红黑树的添加逻辑。如果某个桶的链表长度超过8并且总容量大于64，就会<strong>转化成红黑树</strong>，效率是O（logn）；当<strong>查找元素</strong>的时候，首先计算key的哈希值，再去桶遍历链表/红黑树，找hash值相等的节点，然后用equals判断是不是目标key，如果找到了就返回value；<strong>扩容</strong>：HashMap的默认初始容量是16，负载因子是0.75，当元素数量超过16*0.75=12的时候，发生扩容，扩容会把原数组容量扩大为原来的2倍，然后把原来的元素再次hash放到新位置，这一步的开销较大，因为涉及所有元素的重新计算和移动。</p><hr><p><strong>优先扩容而不是优先转化为红黑树</strong>，因为数组扩容能减少哈希冲突的概率，并且红黑树需要维持自平衡，维护成本较高，并且红黑树会增加复杂度（节点占用内存更大）。</p><hr><p><strong>为什么扩容是8和64</strong>：因为泊松分布表明，链表长度到达8的情况非常非常少。设为8可以保证性能和空间的平衡。64也是实践验证的经验值，优先扩容而不是优先转化红黑树，当数组大小达到64的时候，冲突概率较高，转化成红黑树的性能优势就明显了。</p><hr><p><strong>为什么扩容*2</strong>：目的是为了让hash计算更加高效；首先，HashMap的容量是2的幂，hash取模可以使用位运算代替，（n-1）&amp; hash；扩容后的再次hash更容易判断元素是否发生位置移动，重新hash后我们只需要看新增的哪一位是0还是1就能判断出来是否需要后移oldCapacity（是1就移）；</p><hr><p>**为什么负载因子是0.75？**默认负载因子为 0.75，是因为它提供了空间和时间复杂度之间的良好平衡。负载因子太低会导致大量的空桶浪费空间，负载因子太高会导致大量的碰撞，降低性能。</p><hr><p>**为什么HashMap线程不安全？**1.7之前头插法导致在多线程环境下扩容操作可能存在死循环问题；另外无论是7还是8都存在一个数据丢失的问题，实际上是数据覆盖，一种情况是线程1发现hash冲突并且equals满足，即将覆盖数据的时候，CPU执行权被线程2抢走，数据2覆盖了数据，等到线程1再次操作的时候就会把线程2的数据覆盖。还有一种情况是两个线程同时 <code>put</code> 操作导致 <code>size</code> 的值不正确，进而导致数据覆盖的问题。</p><hr><p><strong>死循环问题</strong>：JDK1.7 及之前版本的 <code>HashMap</code> 在多线程环境下扩容操作可能存在死循环问题，这是由于当一个桶位中有多个元素需要进行扩容时，多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><hr><p><strong>为什么红黑树而不是平衡二叉树(AVL树)</strong>：平衡二叉树追求的是一种 ”完全平衡“ 状态，导致每次进行插入/删除节点的时候都需要左旋右旋来维持平衡；红黑树追求 ”弱平衡“，虽然牺牲了一些查找的效率，但是维护成本低。</p><hr><p><strong>Key可以为null</strong>：null作为Key只能有一个，但是null作为value可以有多个。当key为空时，直接另key的哈希值为0，不走key.hashCode()方法。</p><hr><h3 id="hashmap-vs-hashset" tabindex="-1"><a class="header-anchor" href="#hashmap-vs-hashset"><span>HashMap vs HashSet</span></a></h3><p><code>HashMap</code> 是一个键值对集合，用来存储 key 和 value 的映射关系；而 <code>HashSet</code> 是一个不重复的集合，只存储元素本身，没有键值对的概念。</p><p>从实现上来看，<code>HashSet</code> 内部其实就是通过一个 <code>HashMap</code> 来实现的。我们每往 <code>HashSet</code> 加一个元素，底层就是把这个元素作为 <code>HashMap</code> 的 key，value 用一个固定的对象（通常是 <code>PRESENT</code>）。也就是说，<code>HashSet</code> 借用了 <code>HashMap</code> 的 key 去实现唯一性约束。</p><p>此外，在元素唯一性判断上，两者都靠 key 的 hashCode 和 equals 来判断唯一性，但 HashMap 还需要关注和操作与 key 相关联的 value，如<code>get(key)</code>，<code>putIfAbsent()</code> 等方法，而 HashSet 根本不涉及 value 的变化。</p><h3 id="treemap-vs-hashmap" tabindex="-1"><a class="header-anchor" href="#treemap-vs-hashmap"><span>TreeMap vs HashMap</span></a></h3><p>首先，<strong>排序方式</strong>是最显著的区别。<code>HashMap</code> 不保证任何顺序，它是无序的，元素的顺序是由哈希函数决定的。而 <code>TreeMap</code> 是基于红黑树实现的，它会根据键的自然顺序（即 <code>Comparable</code>）或者自定义的 <code>Comparator</code> 对键进行排序。因此，<code>TreeMap</code> 保证键的顺序是有序的。</p><p>第二，<strong>底层数据结构</strong>不同。<code>HashMap</code> 底层是基于哈希表实现的，键通过哈希值定位到桶（bucket）中，这使得它的查找、插入和删除操作平均时间复杂度是 O(1)，但是它的顺序是不可预测的。而 <code>TreeMap</code> 底层是基于红黑树的，操作时间复杂度是 O(log N)，但是它能够提供有序的键值对。</p><p>第三，<strong>线程安全性</strong>，<code>HashMap</code> 和 <code>TreeMap</code> 都是非线程安全的。如果在多线程环境下需要使用线程安全的 <code>Map</code>，需要使用 <code>ConcurrentHashMap</code> 或者通过显式加锁来实现。</p><p>最后，<strong>性能上的差异</strong>。由于 <code>TreeMap</code> 需要维护键的顺序，插入、删除、查找等操作的时间复杂度是 O(log N)，相较于 <code>HashMap</code> 的 O(1) 要慢。如果不需要排序，<code>HashMap</code> 会更快</p><h2 id="treemap" tabindex="-1"><a class="header-anchor" href="#treemap"><span>TreeMap</span></a></h2><p><code>TreeMap</code> 是 Java 中 <code>Map</code> 接口的一个实现类，最大的特点就是它可以对键进行自动排序。这个排序要么是按照键的自然顺序，也就是键实现了 <code>Comparable</code> 接口，要么是通过我们在构造时传入的 <code>Comparator</code> 进行自定义排序。</p><p>它的底层是基于红黑树实现的，也就是一种自平衡的二叉搜索树，所以它在插入、删除、查找时都能保证 logN 的时间复杂度。相比于 <code>HashMap</code> 来说，虽然性能略低一些，但它能保持顺序，这在需要范围查找、按序遍历时非常有用。</p><p>值得注意的是，<code>TreeMap</code> 不允许键为 null，因为排序时会涉及键的比较，而 null 不能参与比较操作。值是可以为 null 的。</p><p>另外，<code>TreeMap</code> 不是线程安全的，在并发场景下我们需要自己加锁或者使用工具方法进行同步包装。</p><p>总的来说，如果我们在业务中需要一个按照键排序的 Map，比如做排行榜、区间查找、时间线数据等，<code>TreeMap</code> 是一个很合适的选择。</p><h2 id="concurrehashmap" tabindex="-1"><a class="header-anchor" href="#concurrehashmap"><span>ConcurreHashMap</span></a></h2><p>ConcurreHashMap是线程安全版的hashmap。</p><p><strong>1.8之前</strong></p><p>在 JDK1.7 及之前，<code>ConcurrentHashMap</code> 的线程安全是通过**分段锁（Segment Lock）**实现的。它将整个哈希表分为若干个段（Segment），每个 Segment 其实是一个小的哈希表，同时每个 Segment 都维护一个独立的锁。</p><p>当我们对 <code>ConcurrentHashMap</code> 进行 put、get 或 remove 操作时，只会锁住对应的某个 Segment，而不是整个 map。这样多个线程只要访问的 Segment 不同，就可以并发执行操作，避免了 <code>Hashtable</code> 那种全表锁带来的性能瓶颈。</p><p>Segment 的数量一般是 2 的幂次方，比如默认是 16 个，也就是说最多可以有 16 个线程并发写入而不阻塞，从而提升了并发性能。</p><p>不过它的缺点也很明显：Segment 的数量是固定的，粒度不能再细，某个 Segment 上仍然可能成为热点，限制了更高的并发性。</p><p>JDK 1.7 ConcurrentHashMap中的分段锁是用了 ReentrantLock，是一个可重入的锁。</p><p><strong>1.8之后</strong></p><p>到了 JDK1.8，<code>ConcurrentHashMap</code> 的结构完全重写，不再使用 Segment，而是用<strong>数组 + 链表 + 红黑树</strong>的结构，同时结合了 <strong>CAS（无锁操作）</strong> 和 <strong>synchronized（细粒度同步）</strong>。</p><p>插入数据时，先通过 CAS 操作尝试将节点插入到桶中，如果该位置是空的，直接写入，无需加锁；如果该位置已经有元素（比如链表或红黑树），才会用 synchronized 加锁，但只锁当前桶的头节点，锁的粒度更细。</p><p>扩容时，多个线程可以<strong>协同迁移数据</strong>，称为协助扩容，避免了单线程扩容造成的阻塞。</p><p>get 操作是无锁的，通过 volatile 保证可见性，读取效率非常高。</p><p>相比 JDK1.7，1.8 的 <code>ConcurrentHashMap</code> 在并发性能、内存占用、锁竞争等方面都做了很大优化，彻底解决了分段锁机制下的扩展瓶颈。</p><hr><p><strong>已经用了synchronized，为什么还要用CAS</strong></p><p><code>ConcurrentHashMap</code> 之所以同时使用 <code>synchronized</code> 和 <code>CAS</code>，是为了在保证线程安全的同时最大程度提高并发性能，两者各有侧重，互相配合使用。</p><p>首先，<code>CAS</code>（Compare-And-Swap）是一种无锁原子操作，适用于一些简单、局部的并发修改场景，比如在插入元素之前先尝试占位节点（<code>initTable</code> 初始化时就使用了 CAS）。它可以在不加锁的前提下完成并发修改，从而提高并发效率，减少上下文切换。</p><p>但 <code>CAS</code> 也有局限，它只能保证单点原子性，不适用于需要多个步骤或者修改多个共享变量的复合操作。而对于某些复杂逻辑（如链表转红黑树、链表删除元素、扩容等），就必须使用传统的 <code>synchronized</code> 来保证原子性和一致性。</p><p>所以：</p><ul><li>CAS 适用于轻量级、简单、可乐观执行的操作，优先使用，提高性能。</li><li><code>synchronized</code> 适用于需要完整互斥控制的复杂操作，确保线程安全。</li></ul><p>这种组合方式体现了 <code>ConcurrentHashMap</code> 的设计思想：在保证线程安全的前提下，尽可能细化锁粒度、提升并发度和执行效率。</p><hr><p><strong>不允许为 null</strong></p><p><code>HashMap</code> 的 key 和 value 都能为 null，但 key 最多只能有一个为 null；而 <code>ConcurrentHashMap</code> 两者都不允许为 null，因为二义性，你没办法是不存在才返回null还是因为值本身就是null。多线程下无法正确判定键值对是否存在（存在其他线程修改的情况），单线程是可以的（不存在其他线程修改的情况）。</p><p><strong><code>ConcurrentHashMap</code> 是否支持复合操作的原子性时</strong></p><p>第一，它本身只保证单个方法的线程安全，比如 <code>get</code>、<code>put</code>、<code>remove</code> 等，内部都有并发控制机制，比如 CAS 或 synchronized。但如果我组合多个方法，比如 <code>if (!map.containsKey(k)) map.put(k, v)</code>，这就不是原子的，中间可能被其他线程修改，导致逻辑错误。</p><p>第二，JDK 1.8 开始提供了一些专门应对复合操作的原子方法，比如 <code>putIfAbsent</code>、<code>compute</code>、<code>computeIfAbsent</code>、<code>computeIfPresent</code> 和 <code>merge</code>，这些方法内部已经做了同步控制，可以安全地执行复合操作，所以我们要优先使用这些方法来避免并发问题。</p><p>第三，如果遇到更加复杂的逻辑，<code>ConcurrentHashMap</code> 没有提供直接支持的原子操作，那就需要 开发者自己加锁 来保证原子性，通常可以使用外部 <code>ReentrantLock</code> 或 <code>synchronized</code>。</p><h3 id="hashtable" tabindex="-1"><a class="header-anchor" href="#hashtable"><span>Hashtable</span></a></h3><p><code>Hashtable</code> 是 Java 中最早期提供的哈希表实现，已经过时，更推荐使用 <code>ConcurrentHashMap</code> 来替代它。</p><p>最大的特点是线程安全。<code>Hashtable</code> 的所有方法几乎都通过 <code>synchronized</code> 实现了同步控制，保证了多线程并发访问时的数据一致性。但也正因为如此，它的性能在高并发环境下会受到一定影响，因为每次访问都需要加锁，容易成为性能瓶颈。</p><p>从底层结构上看，<code>Hashtable</code> 和早期的 <code>HashMap</code> 类似，都是基于数组加链表的结构实现的哈希表。通过键的 <code>hashCode()</code> 方法计算哈希值，再定位到数组的某个槽位，发生哈希冲突时通过拉链法解决。</p><p>值得注意的是，<code>Hashtable</code> 不允许键或值为 <code>null</code>。这和 <code>HashMap</code> 不同，<code>HashMap</code> 允许一个 <code>null</code> 键和多个 <code>null</code> 值。</p><h3 id="concurrenthashmap-vs-hashtable" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap-vs-hashtable"><span>ConcurrentHashMap vs Hashtable</span></a></h3><p>首先，在实现线程安全的方式上，<code>Hashtable</code> 是通过对整个方法加上 <code>synchronized</code> 来实现同步的，也就是说每次读写操作都需要加锁，锁的粒度非常大，线程只能串行访问，性能比较低。而 <code>ConcurrentHashMap</code> 则是通过分段锁或者更细粒度的同步机制来实现并发控制的。在 JDK1.7 中，它使用的是分段锁结构，把整个桶数组分成多个 Segment，每个 Segment 有自己的锁，可以支持更高并发；到了 JDK1.8，它优化为使用 CAS 和 <code>synchronized</code> 结合的方式，锁粒度更小，性能进一步提升。</p><p>其次，<code>Hashtable</code> 在多线程下容易成为性能瓶颈，而 <code>ConcurrentHashMap</code> 在保证线程安全的同时兼顾了并发性能，是并发场景下更推荐的选择。</p><p>还有一点比较重要的是，<code>Hashtable</code> 不允许键或值为 <code>null</code>，<code>ConcurrentHashMap</code> 也不允许。这个设计是为了避免在并发场景下使用 <code>null</code> 带来的歧义，比如不能判断是没有映射还是映射为 null。</p><p>从实际开发角度来说，<code>Hashtable</code> 已经属于过时的类，几乎不会在新项目中使用了；而 <code>ConcurrentHashMap</code> 是目前在并发环境下使用最广泛的线程安全 Map 实现。</p><hr><h2 id="concurrentskiplistmap" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistmap"><span>ConcurrentSkipListMap</span></a></h2><p><code>ConcurrentSkipListMap</code> 是 Java 并发包中提供的一种线程安全的、可排序的 Map 实现，底层基于跳表（Skip List）结构。它可以保证键值对按照 key 的自然顺序或自定义 Comparator 排序，并支持高并发读写操作。</p><p>与 <code>ConcurrentHashMap</code> 相比，它最大的特点是有序；与 <code>TreeMap</code> 相比，它则具备线程安全性，并发性能更好。内部是通过 CAS 和分段锁来实现并发控制的，支持无锁读、局部加锁写，整体性能优于传统的全锁方案。</p><p>由于其有序性和线程安全特性，<code>ConcurrentSkipListMap</code> 特别适用于并发场景下需要排序功能的需求，比如实现排行榜、区间查找、按时间排序的数据存储等。</p><hr><h1 id="set" tabindex="-1"><a class="header-anchor" href="#set"><span>Set</span></a></h1><p>HashSet，LinedHashSet，TreeSet，都是Set接口的实现类，都能保证元素唯一，并且都不是线程安全的。</p><p>HashSet是基于HasmMap的Key唯一的特性实现的，用来实现HashSet的HasmMap的value是一个固定常量，一般是PRESENT。</p><blockquote><p>这个 <code>PRESENT</code> 是 <code>HashSet</code> 内部的一个 <code>private static final Object</code>，只用来占位，没有实际意义。每当我们往 <code>HashSet</code> 添加一个元素，底层就是执行 <code>map.put(element, PRESENT)</code>。</p><p><strong>不能是Null</strong></p><p>如果用 <code>null</code> 作为 value，那在调用 <code>map.get(key)</code> 的时候，永远返回的是 <code>null</code>，我们就无法区分到底这个 key 是真的存在，只是值是 null，还是这个 key 根本不存在。</p></blockquote><h2 id="linkedhashset" tabindex="-1"><a class="header-anchor" href="#linkedhashset"><span>LinkedHashSet</span></a></h2><p><code>LinkedHashSet</code> 是 <code>Set</code> 接口的一个实现类，它继承自 <code>HashSet</code>。</p><ol><li><strong>保持插入顺序</strong>： <code>LinkedHashSet</code> 通过双向链表来维护元素的插入顺序，这意味着在遍历时，它会按照元素添加的顺序进行输出。与 <code>HashSet</code> 不同，<code>HashSet</code> 是无序的，无法保证元素的顺序。</li><li><strong>底层实现</strong>： <code>LinkedHashSet</code> 是基于 <code>HashMap</code> 实现的，每个元素作为 <code>HashMap</code> 的 key，value 使用一个固定的对象（通常是 <code>PRESENT</code>）。同时，它通过双向链表来保持插入顺序。</li><li><strong>性能</strong>： <ul><li>和 <code>HashSet</code> 一样，<code>LinkedHashSet</code> 的 <code>add</code>、<code>remove</code>、<code>contains</code> 等操作的时间复杂度都是 O(1)。</li><li>由于需要维护插入顺序，它相较于 <code>HashSet</code> 会稍微多一些内存开销，因为它要额外存储双向链表的信息。</li></ul></li><li><strong>适用场景</strong>： <code>LinkedHashSet</code> 适用于那些需要保证元素顺序的场景，且不需要重复元素的集合。如果你需要元素的唯一性且保持插入顺序，就可以使用 <code>LinkedHashSet</code>。</li></ol><h2 id="treeset" tabindex="-1"><a class="header-anchor" href="#treeset"><span>TreeSet</span></a></h2><p><code>TreeSet</code> 是 <code>Set</code> 接口的一个实现类，底层基于 <code>TreeMap</code> 实现。</p><ol><li><strong>元素有序</strong>： <code>TreeSet</code> 会根据元素的自然顺序（即元素实现了 <code>Comparable</code> 接口）或者自定义的排序规则（通过构造函数传入 <code>Comparator</code>）对元素进行排序，遍历时是有序的。</li><li><strong>不允许重复元素</strong>： <code>TreeSet</code> 和其他 Set 一样，不能存储重复元素。它是通过比较元素的大小来判断是否重复的，而不是 <code>equals()</code>，所以自定义比较器或 <code>compareTo</code> 的逻辑要和 <code>equals</code> 保持一致，否则会出现逻辑冲突。</li><li><strong>底层实现</strong>： <code>TreeSet</code> 底层是基于 <code>TreeMap</code> 实现的，具体是将元素作为 <code>TreeMap</code> 的 key，value 是一个固定的常量。它本质上是一个红黑树结构，因此所有操作的时间复杂度是 O(log N)。</li><li><strong>不允许存储 <code>null</code> 元素</strong>： 因为比较时会抛出空指针异常，所以插入 <code>null</code> 会直接抛出 <code>NullPointerException</code>。</li><li><strong>适用场景</strong>： 当我们需要一个自动排序且不重复的集合时，就可以使用 <code>TreeSet</code>，比如处理排行榜、自动去重并排序的一些数据集合等。</li></ol><h2 id="concurrentskiplistset" tabindex="-1"><a class="header-anchor" href="#concurrentskiplistset"><span>ConcurrentSkipListSet</span></a></h2><h2 id="copyonwritearrayset" tabindex="-1"><a class="header-anchor" href="#copyonwritearrayset"><span>CopyOnWriteArraySet</span></a></h2><h1 id="queue" tabindex="-1"><a class="header-anchor" href="#queue"><span>Queue</span></a></h1><h2 id="priorityqueue" tabindex="-1"><a class="header-anchor" href="#priorityqueue"><span>PriorityQueue</span></a></h2><p><code>PriorityQueue</code> 是 Java 提供的一个<strong>基于优先级的队列</strong>实现，它实现了 <code>Queue</code> 接口，用来存储一组按照优先级自动排序的元素。</p><p>和普通队列不同，普通队列是先进先出，而 <code>PriorityQueue</code> 中的元素并不是按照插入顺序来出队的，而是按照优先级<strong>最小的元素优先出队</strong>，也就是默认是一个<strong>小顶堆结构</strong>。</p><p>它的底层是基于<strong>最小堆（binary heap）实现的数组结构</strong>，插入和删除操作的时间复杂度都是 O(logN)。元素入队后会自动按照优先级进行调整。</p><p>默认情况下，队列中的元素必须实现 <code>Comparable</code> 接口，使用元素的自然顺序进行排序；如果我们需要自定义排序方式，也可以在构造方法中传入一个 <code>Comparator</code>，从而按照指定的优先级进行排序。</p><p>值得注意的是，<code>PriorityQueue</code> 允许重复元素，但<strong>不允许插入 null</strong>，因为 null 会与内部比较操作冲突。此外，它<strong>不是线程安全的</strong>，在多线程环境下需要通过外部同步或使用并发版本的队列，比如 <code>PriorityBlockingQueue</code>。</p><p>典型应用场景包括：任务调度器、带权重的消息处理系统、Dijkstra 最短路径算法、Top-K 问题等。</p><h2 id="blockingqueue" tabindex="-1"><a class="header-anchor" href="#blockingqueue"><span>BlockingQueue</span></a></h2><p><code>BlockingQueue</code> 是 Java 中用于<strong>线程间通信</strong>和<strong>任务调度</strong>的一个接口，广泛用于生产者-消费者模型的实现。它的特点是：当队列为空时，消费者线程会被阻塞，直到有新元素加入；而当队列满时，生产者线程会被阻塞，直到队列有空间可以插入新元素。</p><p><code>BlockingQueue</code> 主要有两个特性：</p><ol><li><strong>阻塞</strong>：如果队列为空，调用 <code>take()</code> 方法的线程会被阻塞，直到队列中有元素可用。如果队列已满，调用 <code>put()</code> 方法的线程会被阻塞，直到队列有空位。</li><li><strong>线程安全</strong>：通过内部的锁机制（如使用 ReentrantLock 或其他同步机制）来确保多个线程同时访问时，不会产生数据不一致的问题，保证在高并发情况下的正确性和一致性。</li></ol><p><code>BlockingQueue</code> 接口有几个常用实现类：</p><ul><li><strong><code>ArrayBlockingQueue</code></strong>：基于数组实现的有界阻塞队列，队列的容量是固定的。</li><li><strong><code>LinkedBlockingQueue</code></strong>：基于链表实现的有界阻塞队列，可以设置最大容量，也可以不设置，默认是无界队列。</li><li><strong><code>PriorityBlockingQueue</code></strong>：基于优先级队列实现的阻塞队列，元素会按照优先级顺序排序。</li><li><strong><code>DelayQueue</code></strong>：一个支持延迟获取元素的队列，元素必须实现 <code>Delayed</code> 接口，适用于定时任务的场景。</li><li><strong><code>SynchronousQueue</code></strong>：没有任何容量的阻塞队列，每一个 <code>put</code> 操作必须等待另一个 <code>take</code> 操作才能完成，常用于任务传递。</li></ul><p>在实际应用中，<code>BlockingQueue</code> 被广泛应用于多线程的任务调度、线程池的实现、生产者-消费者模型等场景。</p><blockquote><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code>区别</p><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 都是常用的阻塞队列，具备线程安全和阻塞特性，但它们在底层结构、容量控制和性能表现上有明显区别。</p><p>首先，底层实现不同。<code>ArrayBlockingQueue</code> 是基于数组实现的，内部使用一个固定长度的数组作为存储结构，因此它的容量必须在创建时指定，无法动态扩容。而 <code>LinkedBlockingQueue</code> 是基于链表实现的，每个元素是一个独立的节点，通过链表串联起来，它支持有界和无界两种模式。如果构造时没有指定容量，默认容量是 Integer.MAX_VALUE，相当于一个理论上的无界队列。</p><p>其次，在性能和资源使用上也有区别。由于数组是连续内存，<code>ArrayBlockingQueue</code> 的内存利用更紧凑，内存开销相对较小，适合对内存敏感的场景。而 <code>LinkedBlockingQueue</code> 每个元素都需要额外的节点对象，内存开销相对更大，但在高并发场景下，它的插入和移除操作更加平稳，适合大规模数据流动。</p><p>此外，<code>LinkedBlockingQueue</code> 的 put 和 take 操作内部使用的是两把锁（分别用于读和写），而 <code>ArrayBlockingQueue</code> 只使用一把锁来控制整个队列，因此在某些高并发情况下，<code>LinkedBlockingQueue</code> 的吞吐量可能会更好一些。</p><p>应用场景上，如果我清楚队列的容量范围，比如用于线程池中的任务提交队列，我更倾向于使用 <code>ArrayBlockingQueue</code>，因为它更简单、内存开销更小。但如果任务量无法预估，或者系统允许更大的弹性空间，那么 <code>LinkedBlockingQueue</code> 会更适合一些。</p></blockquote><h2 id="concurrentlinkedqueue" tabindex="-1"><a class="header-anchor" href="#concurrentlinkedqueue"><span>ConcurrentLinkedQueue</span></a></h2><h2 id="queue和deque" tabindex="-1"><a class="header-anchor" href="#queue和deque"><span>Queue和Deque</span></a></h2><p><strong>Queue</strong> 是一个<strong>单端队列</strong>，遵循的是典型的“先进先出”（FIFO）原则。我们通常使用 <code>offer()</code> 添加元素，用 <code>poll()</code> 或 <code>remove()</code> 移除元素，从队首出，从队尾入。常见的实现类有 <code>LinkedList</code> 和 <code>PriorityQueue</code>，像任务调度、消息队列等场景都是使用 Queue。</p><p>而 <strong>Deque</strong> 是“双端队列”，全称是 Double Ended Queue，它既可以从队头添加或移除元素，也可以从队尾进行相同的操作。也就是说，<code>Deque</code> 同时支持 FIFO 和 LIFO（后进先出），因此它<strong>既可以当队列用，也可以当栈用</strong>。常用方法比如 <code>addFirst()</code>、<code>addLast()</code>、<code>removeFirst()</code>、<code>removeLast()</code>，而实现类像 <code>ArrayDeque</code> 和 <code>LinkedList</code> 都支持 Deque 接口。</p><p>所以总结来说，<strong>Queue 只能一端进、一端出，Deque 两端都能进出，更灵活</strong>，适合处理双向数据结构或实现栈这种结构。</p><h2 id="linkedblockingdeque" tabindex="-1"><a class="header-anchor" href="#linkedblockingdeque"><span>LinkedBlockingDeque</span></a></h2><h2 id="concurrentlinkeddeque" tabindex="-1"><a class="header-anchor" href="#concurrentlinkeddeque"><span>ConcurrentLinkedDeque</span></a></h2><h2 id="arraydeque-和-linkedlist" tabindex="-1"><a class="header-anchor" href="#arraydeque-和-linkedlist"><span><code>ArrayDeque</code> 和 <code>LinkedList</code></span></a></h2><p><strong><code>ArrayDeque</code> 是基于动态数组实现的</strong>，它内部用一个循环数组来存储元素。因为是数组结构，它在两端插入和删除元素时效率很高，几乎都是 O(1) 时间，并且由于没有指针开销，它的内存利用率也更好。</p><p>相比之下，<strong><code>LinkedList</code> 是基于双向链表实现的</strong>，每个节点都有前后指针。它的优势是插入和删除不会涉及数组扩容或元素移动，也支持插入 null 元素，但缺点是内存开销更大，随机访问效率低，性能波动也可能更明显。</p><p>此外，<strong><code>ArrayDeque</code> 不允许插入 null 元素</strong>，而 <code>LinkedList</code> 是允许的；另外在栈结构（比如替代 <code>Stack</code> 类）或队列结构中，<code>ArrayDeque</code> 通常比 <code>LinkedList</code> 表现更优，也更推荐使用。</p><h2 id="arraydeque-和-arraylist" tabindex="-1"><a class="header-anchor" href="#arraydeque-和-arraylist"><span><code>ArrayDeque</code> 和 <code>ArrayList</code></span></a></h2><p>虽然 <code>ArrayList</code> 和 <code>ArrayDeque</code> 的名字都带有 &quot;Array&quot;，而且底层都是用数组（Object[]）来存储数据，但它们的设计目的、使用方式以及性能特点有很大的不同。</p><p>首先，<strong><code>ArrayList</code> 实现了 <code>List</code> 接口</strong>，主要用于按顺序存储元素，强调的是<strong>随机访问和按索引管理数据</strong>。它的底层是一个<strong>线性动态数组</strong>，支持快速的索引访问，比如 <code>get(index)</code> 或 <code>set(index)</code> 的时间复杂度是 O(1)。但是如果在中间插入或删除元素，就会涉及到大量元素的移动，性能相对较差。</p><p>而 <strong><code>ArrayDeque</code> 实现了 <code>Deque</code> 接口</strong>，也就是双端队列，它的重点是支持从<strong>队头和队尾进行高效的插入和删除操作</strong>。它底层虽然也是数组，但用的是<strong>循环数组结构</strong>。当数组尾部空间不足时，它会自动绕回到数组头部去使用未占用的位置，这种<strong>环形结构</strong>可以避免频繁的数据移动，使得两端操作的性能非常稳定，都是 O(1) 的时间复杂度。</p><p>还有一些细节上的差异，比如：</p><ul><li><code>ArrayList</code> 允许插入 <code>null</code> 元素，而 <code>ArrayDeque</code> 明确禁止 <code>null</code>，因为它用 <code>null</code> 表示队列为空，这样更容易区分是否出队成功。</li><li>在扩容机制上，两者都支持动态扩容，但 <code>ArrayList</code> 是线性扩容（一般是原来容量的 1.5 倍），<code>ArrayDeque</code> 的容量总是 2 的幂次方，这有助于在循环数组中通过位运算快速定位元素位置。</li></ul><p>使用场景上也有差别：</p><ul><li>如果我们要频繁地访问元素，尤其是按下标访问，那肯定首选 <code>ArrayList</code>。</li><li>如果我们实现的是栈（LIFO）或队列（FIFO），尤其需要在两端进行频繁插入/删除，<code>ArrayDeque</code> 的性能和空间利用率都比 <code>LinkedList</code> 更好，更推荐使用。</li></ul><h1 id="其他" tabindex="-1"><a class="header-anchor" href="#其他"><span>其他</span></a></h1><h2 id="双向链表和双向循环链表" tabindex="-1"><a class="header-anchor" href="#双向链表和双向循环链表"><span>双向链表和双向循环链表</span></a></h2><p>在 JDK 1.6 之前，<code>LinkedList</code> 的实现是<strong>循环链表</strong>。而从 JDK 1.7 开始，Java 的 <code>LinkedList</code> 底层实现就不再使用循环链表，改用了<strong>普通的双向链表</strong>。</p><p><strong>双向链表：</strong> 包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><strong>双向循环链表：</strong> 最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><strong>为什么这么改？<strong>这个变化的主要原因是</strong>循环链表并不带来明显的性能优势</strong>，而反而可能带来一些复杂性和潜在的错误。例如，处理尾节点指向头节点的引用可能引发无限循环的问题，尤其是在垃圾回收时。改成普通双向链表后，结构更简单，代码也更加直观。</p><h2 id="randomaccess" tabindex="-1"><a class="header-anchor" href="#randomaccess"><span><code>RandomAccess</code></span></a></h2><p><code>RandomAccess</code> 接口不过是一个标识接口。标识实现这个接口的类具有随机访问功能。</p><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。究其原因还是和底层数据结构有关，数组天然支持随机访问，而链表需要遍历到特定位置才能访问特定位置的元素。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">public</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> interface</span><span style="--shiki-light:#C18401;--shiki-dark:#E5C07B;"> RandomAccess</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> {</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#E06C75;">    </span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="fail-fast和fail-safe" tabindex="-1"><a class="header-anchor" href="#fail-fast和fail-safe"><span><code>fail-fast</code>和<code>fail-safe</code></span></a></h2><p>Fail-fast 是一种设计策略，它会在集合被修改的情况下<strong>立即抛出异常</strong>。通常，当你在迭代集合时，如果集合被修改了，迭代器就会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>Fail-safe 是另一种设计策略，它允许在遍历集合的同时<strong>修改集合的结构</strong>，并且不会抛出异常。即使在迭代过程中发生修改，迭代器也能继续正常工作。</p><p><strong>fail-fast</strong> 更侧重于提前发现错误，<strong>fail-safe</strong> 更侧重于保证并发环境下的安全操作。</p><p><code>ArrayList</code> 和 <code>HashMap</code> 的迭代器就是 <strong>fail-fast</strong> 类型的。</p><p><code>CopyOnWriteArrayList</code> 和 <code>ConcurrentHashMap</code>，它们采用了 <strong>fail-safe</strong> 策略</p><h2 id="comparable和comparator" tabindex="-1"><a class="header-anchor" href="#comparable和comparator"><span><code>Comparable</code>和<code>Comparator</code></span></a></h2><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口</p><p>首先，<code>Comparable</code> 是一个 <strong>内部比较器</strong>，它是由类自己实现的排序规则。也就是说，如果一个类实现了 <code>Comparable</code> 接口，它就必须重写 <code>compareTo()</code> 方法，并在方法中定义自己的“自然排序规则”。比如像 <code>String</code>、<code>Integer</code>、<code>Date</code> 这些类本身就实现了 <code>Comparable</code>，可以直接进行排序。</p><p>而 <code>Comparator</code> 是一个 <strong>外部比较器</strong>，它通常在我们无法修改目标类源码，或者需要灵活定义多种排序规则时使用。通过实现 <code>Comparator</code> 接口中的 <code>compare()</code> 方法，我们可以在类的外部定义排序逻辑。像我们用 <code>Collections.sort(list, comparator)</code> 或 <code>TreeMap</code> 传入比较器时，都是在使用 <code>Comparator</code>。</p><p>简单理解的话，<code>Comparable</code> 是让“对象自己可比较”，而 <code>Comparator</code> 是“通过外部工具比较对象”。另外值得注意的是，<code>Comparator</code> 支持 Lambda 表达式，所以在 Java 8 之后我们可以用非常简洁的方式写出比较逻辑。</p><h2 id="collections和collection的区别" tabindex="-1"><a class="header-anchor" href="#collections和collection的区别"><span>Collections和Collection的区别</span></a></h2><p><strong>Collection</strong>是Java集合框架中的一个接口，它是所有集合类的基础接口。它定义了一组通用的操作和方法，如添加、删除、遍历等，用于操作和管理一组对象。Collection接口有许多实现类，如List、Set和Queue等。</p><p><strong>Collections</strong>（注意有一个s）是Java提供的一个工具类，位于java.util包中。它提供了一系列静态方法，用于对集合进行操作和算法。Collections类中的方法包括排序、查找、替换、反转、随机化等等。这些方法可以对实现了Collection接口的集合进行操作，如List和Set。</p>`,239)]))}const i=o(r,[["render",s]]),h=JSON.parse('{"path":"/1.Note/1.Java%20_%20CS/Java%E9%9B%86%E5%90%88.html","title":"Java集合","lang":"en-US","frontmatter":{"title":"Java集合","order":2},"git":{"createdTime":1755588710000,"updatedTime":1755588710000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":35.98,"words":10795},"filePathRelative":"1.Note/1.Java & CS/Java集合.md"}');export{i as comp,h as data};
