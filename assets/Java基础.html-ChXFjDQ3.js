import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as t,a as d,o}from"./app-Bf41fmjm.js";const s={};function n(c,a){return o(),t("div",null,a[0]||(a[0]=[d('<h2 id="包装类型" tabindex="-1"><a class="header-anchor" href="#包装类型"><span>包装类型</span></a></h2><h4 id="包装类和基本数据类型的区别" tabindex="-1"><a class="header-anchor" href="#包装类和基本数据类型的区别"><span>包装类和基本数据类型的区别</span></a></h4><p>包装类型是<code>java</code>为每种基本数据类型提供的对应的类对象类型，让基本类型具备对象的特性。</p><p>基本类型是<code>Java</code>最原始的数据类型，不是对象，操作效率高，内存占用小，如果是局部变量一般存储在栈内存，但是如果是成员变量就存储在堆<code>/方法区/元空间(static修饰的静态变量)</code>。</p><p>包装类型是基本类型的类，是对象，可以用于集合，支持泛型，引用可能在栈中，实际存储在堆中，对于一些比如说Integer范围内的常量，<code>JVM</code>会缓存，也就是包装类型的缓存机制，存储在常量池或栈。</p><h4 id="包装类型的缓存机制" tabindex="-1"><a class="header-anchor" href="#包装类型的缓存机制"><span>包装类型的缓存机制</span></a></h4><p><code>JVM</code>会将常见的重复使用的对象进行复用，避免每次都创建新的对象，提高性能，减少内存使用。</p><p>比如Integer，<code>JVM</code>会缓存<code>-128到127</code>的整数。调用<code>Integer.valueOf(int)</code>的时候，如果传入的整数在这个范围，<code>JVM</code>就返回一个已经创建好的共享对象，而不是在创建一个新的Integer对象。Boolean类型<code>JVM</code>只会缓存true和false两个值。</p><h4 id="自动装箱与拆箱" tabindex="-1"><a class="header-anchor" href="#自动装箱与拆箱"><span>自动装箱与拆箱</span></a></h4><p><strong>自动装箱</strong>是将基本数据类型转换为其对应的包装类的过程，<strong>拆箱</strong>则是将包装类转换为基本数据类型的过程。这两个过程是由编译器自动完成的。装箱的时候<code>JVM</code>调用包装类的构造方法或 <code>valueOf()</code> 方法，拆箱时会通过 <code>xxxValue()</code> 方法（如 <code>Integer.intValue()</code>）获取基本数据类型的值。另外包装类的缓存机制会避免重复创建对象，提升性能。</p><p>但是频繁的装箱可能会导致性能问题，因为如果你的基本数据类型的大小超过了缓存机制的界限，那么就会不断产生新的对象，增加垃圾回收的压力。</p><h2 id="数据类型" tabindex="-1"><a class="header-anchor" href="#数据类型"><span>数据类型</span></a></h2><h4 id="基本数据类型" tabindex="-1"><a class="header-anchor" href="#基本数据类型"><span>基本数据类型</span></a></h4><table><thead><tr><th>类型</th><th>占用内存</th><th>默认值</th><th>范围/说明</th></tr></thead><tbody><tr><td><code>byte</code></td><td>1 字节</td><td>0</td><td>-128 ~ 127</td></tr><tr><td><code>short</code></td><td>2 字节</td><td>0</td><td>-32,768 ~ 32,767</td></tr><tr><td><code>int</code></td><td>4 字节</td><td>0</td><td>-2³¹ ~ 2³¹-1</td></tr><tr><td><code>long</code></td><td>8 字节</td><td>0L</td><td>-2⁶³ ~ 2⁶³-1</td></tr><tr><td><code>float</code></td><td>4 字节</td><td>0.0f</td><td>约 ±3.4e38，7 位精度</td></tr><tr><td><code>double</code></td><td>8 字节</td><td>0.0d</td><td>约 ±1.8e308，15 位精度</td></tr><tr><td><code>char</code></td><td>2 字节</td><td>&#39;\\u0000&#39;</td><td>单个 Unicode 字符（0 ~ 65535）</td></tr><tr><td><code>boolean</code></td><td>1 位*</td><td>false</td><td>true / false（JVM 中通常按 1 字节处理）</td></tr></tbody></table><h4 id="浮点数精度丢失" tabindex="-1"><a class="header-anchor" href="#浮点数精度丢失"><span>浮点数精度丢失</span></a></h4><p>浮点数运算进度丢失是因为计算机二进制存储数字，但是有些小数不能在有限位数里转化成二进制，所以就需要截断，导致精度丢失</p><p>如何解决？</p><p>使用<code>BigDecimal</code>: 用字符串的形式存储小数位，以十进制方式精确表示每一位，适合做高精度运算，比如金额计算。</p><h4 id="超过long整型的数据" tabindex="-1"><a class="header-anchor" href="#超过long整型的数据"><span>超过long整型的数据</span></a></h4><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h4 id="string为什么不可变" tabindex="-1"><a class="header-anchor" href="#string为什么不可变"><span>String为什么不可变？</span></a></h4><p>首先在<code>Java</code>中，<code>final</code>修饰的引用数据类型不能再指向其他对象，而<code>string</code>的字段value底层存储数据的形式就是字符数组，这个数组被final修饰，并且还是私有的，其次string这个类本身也是被final修饰的，那么它就不能被继承，你就不能通过子类来修改，其次，<code>stringbuilder</code>和<code>stringbuffer</code>继承了<code>abstractstringbuilder</code>类，有append等修改字符串的方法，而string没有继承，自然也没有这种方法，这个原因也体现了<code>OOP</code>的封装特性，所以综上所述，<code>string</code>是不可修改的。</p><p>因为不可变性，<code>String</code> 是线程安全的，并且它可以作为常量存储在字符串池中，从而节省内存。</p><h2 id="关键字" tabindex="-1"><a class="header-anchor" href="#关键字"><span>关键字</span></a></h2><h4 id="static" tabindex="-1"><a class="header-anchor" href="#static"><span>static</span></a></h4><p>在 Java 中，<code>static</code> 是一个非常基础的关键字，表示“静态的”，意思就是这个东西不依赖于对象，而是属于类本身。可以修饰静态变量，静态方法，静态代码块，静态内部类，接口的static方法（8+），接口中的变量默认都是static final的。</p><p><strong>在类中</strong>，<code>static</code> 方法是属于类的，可以通过类名直接调用，不需要实例化对象，也<strong>不能被重写</strong>，因为它不属于实例，不参与多态。</p><p><strong>在接口中（Java 8+）</strong>，允许定义 <code>static</code> 方法，<strong>只能通过接口名调用，不能被实现类继承或重写</strong>，这主要是为了给接口提供一些工具方法。</p><h4 id="final" tabindex="-1"><a class="header-anchor" href="#final"><span>final</span></a></h4><p><code>final</code> 这个关键字在 Java 里主要是用来限制“修改”的，可以修饰变量、方法和类</p><p>如果修饰变量，基本数据类型就表示值不能再变了，引用数据类型表示这个引用不能再指向别的对象。</p><p>如果修饰方法，表示它不能被子类重写。</p><p>如果修饰类，表示不能被继承。</p><h4 id="static-final" tabindex="-1"><a class="header-anchor" href="#static-final"><span>static final</span></a></h4><p>组合在一起使用时表示这个变量是<strong>全局常量</strong>，在整个程序中只存在一份，值不能修改，是一种<strong>线程安全、全局唯一的只读变量</strong>。</p><h2 id="区别" tabindex="-1"><a class="header-anchor" href="#区别"><span>区别</span></a></h2><h4 id="vs-equals" tabindex="-1"><a class="header-anchor" href="#vs-equals"><span>== vs equals</span></a></h4><p>==是一个运算符，对于基本数据类型，表示对比值是否相等，对于引用数据类型，表示对比是否指向同一个对象，也就是在堆内存的内存地址是否相同</p><p>而equals是<code>Obejct</code>类的方法，默认实现就是<code>return this == obj</code>，也就是比较引用的地址，但是<code>Object</code>作为所有类的直接或间接的父类，有些标准类都是重写了<code>equals</code>方法的，比如<code>String</code>，<code>Integer</code>，用来比较对象的内容是否相等。</p><p>但是需要注意的一点是<code>Integer a = 127; Integer b = 127;</code> 比较时 <code>a == b</code> 为 <code>true</code>，因为 Java 会缓存 <code>-128</code> 到 <code>127</code> 之间的整数对象，也就是包装类的缓存机制。</p><h4 id="成员变量vs局部变量" tabindex="-1"><a class="header-anchor" href="#成员变量vs局部变量"><span>成员变量vs局部变量</span></a></h4><p>成员变量属于类，随着对象的创建而存在，可以被访问修饰符和<code>static</code>修饰，存于堆，如果没有默认赋值就按照类型默认复制，但是如果是final修饰就必须显式赋值</p><p>局部变量属于代码块或方法，随着方法的调用生成和消亡，存于栈内存，不会自动赋值，必须显式赋值</p><p>二者都能被final修饰</p><h4 id="静态方法vs实例方法" tabindex="-1"><a class="header-anchor" href="#静态方法vs实例方法"><span>静态方法vs实例方法</span></a></h4><p><strong>调用静态方法可以无需创建对象</strong>：前者可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，后者只能用第二种</p><p>静态方法只允许访问静态成员，不允许访问实例成员，而实例方法没有这种限制。</p><h4 id="构造代码块vs构造方法" tabindex="-1"><a class="header-anchor" href="#构造代码块vs构造方法"><span>构造代码块vs构造方法</span></a></h4><p>构造代码块是写在类中、没有方法名、没有修饰符的代码块。它在每次创建对象时都会执行，并且<strong>优先于构造方法执行</strong>。</p><p>构造方法用于创建对象时初始化，名字与类名相同，可以有多个重载版本。</p><h4 id="构造代码块vs静态代码块" tabindex="-1"><a class="header-anchor" href="#构造代码块vs静态代码块"><span>构造代码块vs静态代码块</span></a></h4><p>构造代码块在每次创建对象前都会执行，提取多个构造方法的共同行为，减少代码重复</p><p>静态代码块是在 Java 类中用 <code>static {}</code> 包裹的一段代码。<strong>它在类加载时执行，并且只执行一次</strong>，不管你创建了多少个对象。</p><h4 id="jmm-vs-jvm" tabindex="-1"><a class="header-anchor" href="#jmm-vs-jvm"><span>JMM vs JVM</span></a></h4><p><strong>JVM</strong> 是一个具体的虚拟机，它负责在特定的硬件和操作系统上运行 Java 程序。它包括内存管理、垃圾回收、执行字节码等多个方面。</p><p><strong>JMM</strong> 是 Java 语言的内存模型规范，它并不具体描述实现，而是提供了多线程编程中如何访问共享变量的规范，主要目的是确保并发编程中的线程安全。MM 主要定义了 <strong>内存可见性</strong>、<strong>原子性</strong> 和 <strong>有序性</strong> 三个方面的规则。</p><h4 id="值传递vs引用传递" tabindex="-1"><a class="header-anchor" href="#值传递vs引用传递"><span>值传递vs引用传递</span></a></h4><p>Java 是值传递</p><p><strong>方法调用时，传递的是变量中存储的值的副本</strong>，而不是变量本身。</p><p>基本类型：传的是值的拷贝，方法里怎么改都不会影响原来的。</p><p>引用类型：传的是引用地址的拷贝，能通过这个地址修改对象的内容，但不能改原来的引用指向。</p><h2 id="过程" tabindex="-1"><a class="header-anchor" href="#过程"><span>过程</span></a></h2><h4 id="类加载过程" tabindex="-1"><a class="header-anchor" href="#类加载过程"><span>类加载过程</span></a></h4><p>类加载是指 Java 程序在运行过程中，<strong>把 .class 文件加载到 JVM 中，并转化为 Class 对象的过程</strong>。</p><p>加载：JVM 通过类的全限定名查找 <code>.class</code> 文件，把它的字节码读取进内存，并创建一个 <code>Class</code> 对象。</p><p>验证：这一步是为了安全，检查这个字节码文件是否合法，比如语法结构、常量池是否合法、防止字节码被篡改等。</p><p>准备：这个阶段会为类的<strong>静态变量</strong>分配内存，并设置默认值，比如 <code>int</code> 是 0，<code>boolean</code> 是 false。</p><p>解析：把类中的符号引用（就是类似类名、字段名这种字符串）替换为真正的地址引用（也就是指向内存的引用）。</p><p>初始化：这一步才是真正执行代码，比如执行 <code>static</code> 代码块，或者静态变量的赋值操作，这些代码只会执行一次。</p><p>Java 类加载器采用的是<strong>双亲委派模型</strong>，意思是：<strong>一个类加载器在加载某个类时，先把请求交给它的父加载器，父加载器找不到，才由自己来加载</strong>。有两个好处，应该是避免重复加载，另一个是保证核心类的优先级。</p><h4 id="对象创建的过程" tabindex="-1"><a class="header-anchor" href="#对象创建的过程"><span>对象创建的过程</span></a></h4><p>当new一个对象的时候，JVM首先判断类是否已经加载，如果没有就加载，如果已经加载了，那么就会在 <strong>堆内存</strong> 中为这个对象分配内存，分配好内存后，JVM 会先对这块内存做默认初始化，比如 int 是 0，引用是 null 等，接下来会准备好 this 指针，把它绑定到刚才分配的那块内存上，进程初始化，执行父类的非静态变量和代码块、父类构造器、子类的非静态变量和代码块、子类构造器。最后返回这个对象在堆的引用。</p><h4 id="gc" tabindex="-1"><a class="header-anchor" href="#gc"><span>GC</span></a></h4><p>垃圾回收是自动管理内存的一部分，它的目的是释放堆内存中不再使用的对象。Java中的垃圾回收机制由JVM自动处理，开发者通常不需要手动释放内存。</p><p>垃圾回收算法有</p><p><strong>引用计数法</strong>：每个对象都有一个计数器，记录引用该对象的次数。</p><p><strong>可达性分析法</strong>：JVM采用的方式。通过根对象（GC Root）来追踪所有可以访问的对象。如果对象从GC Root出发无法访问到，就认为它不可达，可以被回收。</p><p><strong>标记-清除算法</strong>：首先标记所有可达的对象，然后清除所有未被标记的对象。</p><p><strong>复制算法</strong>：将堆内存划分为两块，使用一块，回收时将活动对象复制到另一块。优点是没有内存碎片，缺点是内存的使用效率较低，因为必须有两块内存。</p><p>常见的垃圾回收器有G1等</p><h2 id="静态方法为什么不能调用非静态成员" tabindex="-1"><a class="header-anchor" href="#静态方法为什么不能调用非静态成员"><span>静态方法为什么不能调用非静态成员?</span></a></h2><p>静态方法属于类而不是实例，而非静态成员属于对象（实例）。</p><p>静态方法在类加载时就可以访问，不依赖于类的具体实例。非静态成员只有在类的实例化对象存在时，才能访问。</p><p>静态方法没有<code>this</code>引用，不能访问与实例关联的成员。</p><h2 id="可变长参数" tabindex="-1"><a class="header-anchor" href="#可变长参数"><span>可变长参数</span></a></h2><p>从 <code>Java5 </code>开始，Java 支持定义可变长参数，它允许在方法中传递可变数量的参数来简化方法参数。</p><p>遇到方法重载的情况会优先匹配固定参数，因为固定参数的方法匹配度更高。</p>',88)]))}const h=e(s,[["render",n]]),i=JSON.parse('{"path":"/1.Note/1.Java%20_%20CS/Java%E5%9F%BA%E7%A1%80.html","title":"Java基础","lang":"en-US","frontmatter":{"title":"Java基础"},"git":{"createdTime":1750229490000,"updatedTime":1750229490000,"contributors":[{"name":"Nu11Cat","username":"Nu11Cat","email":"2111867383@qq.com","commits":1,"url":"https://github.com/Nu11Cat"}]},"readingTime":{"minutes":10.28,"words":3084},"filePathRelative":"1.Note/1.Java & CS/Java基础.md"}');export{h as comp,i as data};
